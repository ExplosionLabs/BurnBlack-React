
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PersonalDetail
 * 
 */
export type PersonalDetail = $Result.DefaultSelection<Prisma.$PersonalDetailPayload>
/**
 * Model ContactDetail
 * 
 */
export type ContactDetail = $Result.DefaultSelection<Prisma.$ContactDetailPayload>
/**
 * Model AddressDetail
 * 
 */
export type AddressDetail = $Result.DefaultSelection<Prisma.$AddressDetailPayload>
/**
 * Model BankDetail
 * 
 */
export type BankDetail = $Result.DefaultSelection<Prisma.$BankDetailPayload>
/**
 * Model Form16Data
 * 
 */
export type Form16Data = $Result.DefaultSelection<Prisma.$Form16DataPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model CapitalGain
 * 
 */
export type CapitalGain = $Result.DefaultSelection<Prisma.$CapitalGainPayload>
/**
 * Model InterestIncome
 * 
 */
export type InterestIncome = $Result.DefaultSelection<Prisma.$InterestIncomePayload>
/**
 * Model DividendIncome
 * 
 */
export type DividendIncome = $Result.DefaultSelection<Prisma.$DividendIncomePayload>
/**
 * Model BusinessIncome
 * 
 */
export type BusinessIncome = $Result.DefaultSelection<Prisma.$BusinessIncomePayload>
/**
 * Model ProfessionalIncome
 * 
 */
export type ProfessionalIncome = $Result.DefaultSelection<Prisma.$ProfessionalIncomePayload>
/**
 * Model ProfitLoss
 * 
 */
export type ProfitLoss = $Result.DefaultSelection<Prisma.$ProfitLossPayload>
/**
 * Model BalanceSheet
 * 
 */
export type BalanceSheet = $Result.DefaultSelection<Prisma.$BalanceSheetPayload>
/**
 * Model DepreciationEntry
 * 
 */
export type DepreciationEntry = $Result.DefaultSelection<Prisma.$DepreciationEntryPayload>
/**
 * Model CryptoIncome
 * 
 */
export type CryptoIncome = $Result.DefaultSelection<Prisma.$CryptoIncomePayload>
/**
 * Model AgriculturalIncome
 * 
 */
export type AgriculturalIncome = $Result.DefaultSelection<Prisma.$AgriculturalIncomePayload>
/**
 * Model ExemptIncome
 * 
 */
export type ExemptIncome = $Result.DefaultSelection<Prisma.$ExemptIncomePayload>
/**
 * Model TaxSavingInvestment
 * 
 */
export type TaxSavingInvestment = $Result.DefaultSelection<Prisma.$TaxSavingInvestmentPayload>
/**
 * Model Donation
 * 
 */
export type Donation = $Result.DefaultSelection<Prisma.$DonationPayload>
/**
 * Model MedicalInsurance
 * 
 */
export type MedicalInsurance = $Result.DefaultSelection<Prisma.$MedicalInsurancePayload>
/**
 * Model TaxPaid
 * 
 */
export type TaxPaid = $Result.DefaultSelection<Prisma.$TaxPaidPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model ITRGeneration
 * 
 */
export type ITRGeneration = $Result.DefaultSelection<Prisma.$ITRGenerationPayload>
/**
 * Model TaxSummary
 * 
 */
export type TaxSummary = $Result.DefaultSelection<Prisma.$TaxSummaryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const MaritalStatus: {
  SINGLE: 'SINGLE',
  MARRIED: 'MARRIED',
  DIVORCED: 'DIVORCED',
  WIDOWED: 'WIDOWED'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const ITRType: {
  ITR1: 'ITR1',
  ITR2: 'ITR2',
  ITR3: 'ITR3',
  ITR4: 'ITR4'
};

export type ITRType = (typeof ITRType)[keyof typeof ITRType]


export const ITRStatus: {
  GENERATED: 'GENERATED',
  DOWNLOADED: 'DOWNLOADED',
  FILED: 'FILED',
  PROCESSED: 'PROCESSED'
};

export type ITRStatus = (typeof ITRStatus)[keyof typeof ITRStatus]


export const TransactionType: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type ITRType = $Enums.ITRType

export const ITRType: typeof $Enums.ITRType

export type ITRStatus = $Enums.ITRStatus

export const ITRStatus: typeof $Enums.ITRStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalDetail`: Exposes CRUD operations for the **PersonalDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalDetails
    * const personalDetails = await prisma.personalDetail.findMany()
    * ```
    */
  get personalDetail(): Prisma.PersonalDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactDetail`: Exposes CRUD operations for the **ContactDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactDetails
    * const contactDetails = await prisma.contactDetail.findMany()
    * ```
    */
  get contactDetail(): Prisma.ContactDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addressDetail`: Exposes CRUD operations for the **AddressDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddressDetails
    * const addressDetails = await prisma.addressDetail.findMany()
    * ```
    */
  get addressDetail(): Prisma.AddressDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankDetail`: Exposes CRUD operations for the **BankDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetail.findMany()
    * ```
    */
  get bankDetail(): Prisma.BankDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.form16Data`: Exposes CRUD operations for the **Form16Data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Form16Data
    * const form16Data = await prisma.form16Data.findMany()
    * ```
    */
  get form16Data(): Prisma.Form16DataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capitalGain`: Exposes CRUD operations for the **CapitalGain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapitalGains
    * const capitalGains = await prisma.capitalGain.findMany()
    * ```
    */
  get capitalGain(): Prisma.CapitalGainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestIncome`: Exposes CRUD operations for the **InterestIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestIncomes
    * const interestIncomes = await prisma.interestIncome.findMany()
    * ```
    */
  get interestIncome(): Prisma.InterestIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dividendIncome`: Exposes CRUD operations for the **DividendIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DividendIncomes
    * const dividendIncomes = await prisma.dividendIncome.findMany()
    * ```
    */
  get dividendIncome(): Prisma.DividendIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessIncome`: Exposes CRUD operations for the **BusinessIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessIncomes
    * const businessIncomes = await prisma.businessIncome.findMany()
    * ```
    */
  get businessIncome(): Prisma.BusinessIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.professionalIncome`: Exposes CRUD operations for the **ProfessionalIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfessionalIncomes
    * const professionalIncomes = await prisma.professionalIncome.findMany()
    * ```
    */
  get professionalIncome(): Prisma.ProfessionalIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profitLoss`: Exposes CRUD operations for the **ProfitLoss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfitLosses
    * const profitLosses = await prisma.profitLoss.findMany()
    * ```
    */
  get profitLoss(): Prisma.ProfitLossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balanceSheet`: Exposes CRUD operations for the **BalanceSheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BalanceSheets
    * const balanceSheets = await prisma.balanceSheet.findMany()
    * ```
    */
  get balanceSheet(): Prisma.BalanceSheetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.depreciationEntry`: Exposes CRUD operations for the **DepreciationEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepreciationEntries
    * const depreciationEntries = await prisma.depreciationEntry.findMany()
    * ```
    */
  get depreciationEntry(): Prisma.DepreciationEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptoIncome`: Exposes CRUD operations for the **CryptoIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoIncomes
    * const cryptoIncomes = await prisma.cryptoIncome.findMany()
    * ```
    */
  get cryptoIncome(): Prisma.CryptoIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agriculturalIncome`: Exposes CRUD operations for the **AgriculturalIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgriculturalIncomes
    * const agriculturalIncomes = await prisma.agriculturalIncome.findMany()
    * ```
    */
  get agriculturalIncome(): Prisma.AgriculturalIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exemptIncome`: Exposes CRUD operations for the **ExemptIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExemptIncomes
    * const exemptIncomes = await prisma.exemptIncome.findMany()
    * ```
    */
  get exemptIncome(): Prisma.ExemptIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxSavingInvestment`: Exposes CRUD operations for the **TaxSavingInvestment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxSavingInvestments
    * const taxSavingInvestments = await prisma.taxSavingInvestment.findMany()
    * ```
    */
  get taxSavingInvestment(): Prisma.TaxSavingInvestmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalInsurance`: Exposes CRUD operations for the **MedicalInsurance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalInsurances
    * const medicalInsurances = await prisma.medicalInsurance.findMany()
    * ```
    */
  get medicalInsurance(): Prisma.MedicalInsuranceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxPaid`: Exposes CRUD operations for the **TaxPaid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxPaids
    * const taxPaids = await prisma.taxPaid.findMany()
    * ```
    */
  get taxPaid(): Prisma.TaxPaidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.iTRGeneration`: Exposes CRUD operations for the **ITRGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ITRGenerations
    * const iTRGenerations = await prisma.iTRGeneration.findMany()
    * ```
    */
  get iTRGeneration(): Prisma.ITRGenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxSummary`: Exposes CRUD operations for the **TaxSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxSummaries
    * const taxSummaries = await prisma.taxSummary.findMany()
    * ```
    */
  get taxSummary(): Prisma.TaxSummaryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    PersonalDetail: 'PersonalDetail',
    ContactDetail: 'ContactDetail',
    AddressDetail: 'AddressDetail',
    BankDetail: 'BankDetail',
    Form16Data: 'Form16Data',
    Property: 'Property',
    CapitalGain: 'CapitalGain',
    InterestIncome: 'InterestIncome',
    DividendIncome: 'DividendIncome',
    BusinessIncome: 'BusinessIncome',
    ProfessionalIncome: 'ProfessionalIncome',
    ProfitLoss: 'ProfitLoss',
    BalanceSheet: 'BalanceSheet',
    DepreciationEntry: 'DepreciationEntry',
    CryptoIncome: 'CryptoIncome',
    AgriculturalIncome: 'AgriculturalIncome',
    ExemptIncome: 'ExemptIncome',
    TaxSavingInvestment: 'TaxSavingInvestment',
    Donation: 'Donation',
    MedicalInsurance: 'MedicalInsurance',
    TaxPaid: 'TaxPaid',
    Wallet: 'Wallet',
    WalletTransaction: 'WalletTransaction',
    ITRGeneration: 'ITRGeneration',
    TaxSummary: 'TaxSummary'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "personalDetail" | "contactDetail" | "addressDetail" | "bankDetail" | "form16Data" | "property" | "capitalGain" | "interestIncome" | "dividendIncome" | "businessIncome" | "professionalIncome" | "profitLoss" | "balanceSheet" | "depreciationEntry" | "cryptoIncome" | "agriculturalIncome" | "exemptIncome" | "taxSavingInvestment" | "donation" | "medicalInsurance" | "taxPaid" | "wallet" | "walletTransaction" | "iTRGeneration" | "taxSummary"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PersonalDetail: {
        payload: Prisma.$PersonalDetailPayload<ExtArgs>
        fields: Prisma.PersonalDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>
          }
          findFirst: {
            args: Prisma.PersonalDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>
          }
          findMany: {
            args: Prisma.PersonalDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>[]
          }
          create: {
            args: Prisma.PersonalDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>
          }
          createMany: {
            args: Prisma.PersonalDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>[]
          }
          delete: {
            args: Prisma.PersonalDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>
          }
          update: {
            args: Prisma.PersonalDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>
          }
          deleteMany: {
            args: Prisma.PersonalDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonalDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>[]
          }
          upsert: {
            args: Prisma.PersonalDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailPayload>
          }
          aggregate: {
            args: Prisma.PersonalDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalDetail>
          }
          groupBy: {
            args: Prisma.PersonalDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalDetailCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalDetailCountAggregateOutputType> | number
          }
        }
      }
      ContactDetail: {
        payload: Prisma.$ContactDetailPayload<ExtArgs>
        fields: Prisma.ContactDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>
          }
          findFirst: {
            args: Prisma.ContactDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>
          }
          findMany: {
            args: Prisma.ContactDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>[]
          }
          create: {
            args: Prisma.ContactDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>
          }
          createMany: {
            args: Prisma.ContactDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>[]
          }
          delete: {
            args: Prisma.ContactDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>
          }
          update: {
            args: Prisma.ContactDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>
          }
          deleteMany: {
            args: Prisma.ContactDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>[]
          }
          upsert: {
            args: Prisma.ContactDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactDetailPayload>
          }
          aggregate: {
            args: Prisma.ContactDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactDetail>
          }
          groupBy: {
            args: Prisma.ContactDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ContactDetailCountAggregateOutputType> | number
          }
        }
      }
      AddressDetail: {
        payload: Prisma.$AddressDetailPayload<ExtArgs>
        fields: Prisma.AddressDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>
          }
          findFirst: {
            args: Prisma.AddressDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>
          }
          findMany: {
            args: Prisma.AddressDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>[]
          }
          create: {
            args: Prisma.AddressDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>
          }
          createMany: {
            args: Prisma.AddressDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>[]
          }
          delete: {
            args: Prisma.AddressDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>
          }
          update: {
            args: Prisma.AddressDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>
          }
          deleteMany: {
            args: Prisma.AddressDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>[]
          }
          upsert: {
            args: Prisma.AddressDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressDetailPayload>
          }
          aggregate: {
            args: Prisma.AddressDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddressDetail>
          }
          groupBy: {
            args: Prisma.AddressDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressDetailCountArgs<ExtArgs>
            result: $Utils.Optional<AddressDetailCountAggregateOutputType> | number
          }
        }
      }
      BankDetail: {
        payload: Prisma.$BankDetailPayload<ExtArgs>
        fields: Prisma.BankDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findFirst: {
            args: Prisma.BankDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findMany: {
            args: Prisma.BankDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          create: {
            args: Prisma.BankDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          createMany: {
            args: Prisma.BankDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          delete: {
            args: Prisma.BankDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          update: {
            args: Prisma.BankDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          upsert: {
            args: Prisma.BankDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          aggregate: {
            args: Prisma.BankDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankDetail>
          }
          groupBy: {
            args: Prisma.BankDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BankDetailCountAggregateOutputType> | number
          }
        }
      }
      Form16Data: {
        payload: Prisma.$Form16DataPayload<ExtArgs>
        fields: Prisma.Form16DataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Form16DataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Form16DataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>
          }
          findFirst: {
            args: Prisma.Form16DataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Form16DataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>
          }
          findMany: {
            args: Prisma.Form16DataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>[]
          }
          create: {
            args: Prisma.Form16DataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>
          }
          createMany: {
            args: Prisma.Form16DataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Form16DataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>[]
          }
          delete: {
            args: Prisma.Form16DataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>
          }
          update: {
            args: Prisma.Form16DataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>
          }
          deleteMany: {
            args: Prisma.Form16DataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Form16DataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Form16DataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>[]
          }
          upsert: {
            args: Prisma.Form16DataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Form16DataPayload>
          }
          aggregate: {
            args: Prisma.Form16DataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForm16Data>
          }
          groupBy: {
            args: Prisma.Form16DataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Form16DataGroupByOutputType>[]
          }
          count: {
            args: Prisma.Form16DataCountArgs<ExtArgs>
            result: $Utils.Optional<Form16DataCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      CapitalGain: {
        payload: Prisma.$CapitalGainPayload<ExtArgs>
        fields: Prisma.CapitalGainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapitalGainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapitalGainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>
          }
          findFirst: {
            args: Prisma.CapitalGainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapitalGainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>
          }
          findMany: {
            args: Prisma.CapitalGainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>[]
          }
          create: {
            args: Prisma.CapitalGainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>
          }
          createMany: {
            args: Prisma.CapitalGainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapitalGainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>[]
          }
          delete: {
            args: Prisma.CapitalGainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>
          }
          update: {
            args: Prisma.CapitalGainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>
          }
          deleteMany: {
            args: Prisma.CapitalGainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapitalGainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CapitalGainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>[]
          }
          upsert: {
            args: Prisma.CapitalGainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapitalGainPayload>
          }
          aggregate: {
            args: Prisma.CapitalGainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapitalGain>
          }
          groupBy: {
            args: Prisma.CapitalGainGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapitalGainGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapitalGainCountArgs<ExtArgs>
            result: $Utils.Optional<CapitalGainCountAggregateOutputType> | number
          }
        }
      }
      InterestIncome: {
        payload: Prisma.$InterestIncomePayload<ExtArgs>
        fields: Prisma.InterestIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>
          }
          findFirst: {
            args: Prisma.InterestIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>
          }
          findMany: {
            args: Prisma.InterestIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>[]
          }
          create: {
            args: Prisma.InterestIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>
          }
          createMany: {
            args: Prisma.InterestIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>[]
          }
          delete: {
            args: Prisma.InterestIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>
          }
          update: {
            args: Prisma.InterestIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>
          }
          deleteMany: {
            args: Prisma.InterestIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>[]
          }
          upsert: {
            args: Prisma.InterestIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestIncomePayload>
          }
          aggregate: {
            args: Prisma.InterestIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestIncome>
          }
          groupBy: {
            args: Prisma.InterestIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<InterestIncomeCountAggregateOutputType> | number
          }
        }
      }
      DividendIncome: {
        payload: Prisma.$DividendIncomePayload<ExtArgs>
        fields: Prisma.DividendIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DividendIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DividendIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>
          }
          findFirst: {
            args: Prisma.DividendIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DividendIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>
          }
          findMany: {
            args: Prisma.DividendIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>[]
          }
          create: {
            args: Prisma.DividendIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>
          }
          createMany: {
            args: Prisma.DividendIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DividendIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>[]
          }
          delete: {
            args: Prisma.DividendIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>
          }
          update: {
            args: Prisma.DividendIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>
          }
          deleteMany: {
            args: Prisma.DividendIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DividendIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DividendIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>[]
          }
          upsert: {
            args: Prisma.DividendIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DividendIncomePayload>
          }
          aggregate: {
            args: Prisma.DividendIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDividendIncome>
          }
          groupBy: {
            args: Prisma.DividendIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DividendIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DividendIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<DividendIncomeCountAggregateOutputType> | number
          }
        }
      }
      BusinessIncome: {
        payload: Prisma.$BusinessIncomePayload<ExtArgs>
        fields: Prisma.BusinessIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>
          }
          findFirst: {
            args: Prisma.BusinessIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>
          }
          findMany: {
            args: Prisma.BusinessIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>[]
          }
          create: {
            args: Prisma.BusinessIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>
          }
          createMany: {
            args: Prisma.BusinessIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>[]
          }
          delete: {
            args: Prisma.BusinessIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>
          }
          update: {
            args: Prisma.BusinessIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>
          }
          deleteMany: {
            args: Prisma.BusinessIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>[]
          }
          upsert: {
            args: Prisma.BusinessIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessIncomePayload>
          }
          aggregate: {
            args: Prisma.BusinessIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessIncome>
          }
          groupBy: {
            args: Prisma.BusinessIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessIncomeCountAggregateOutputType> | number
          }
        }
      }
      ProfessionalIncome: {
        payload: Prisma.$ProfessionalIncomePayload<ExtArgs>
        fields: Prisma.ProfessionalIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfessionalIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfessionalIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>
          }
          findFirst: {
            args: Prisma.ProfessionalIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfessionalIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>
          }
          findMany: {
            args: Prisma.ProfessionalIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>[]
          }
          create: {
            args: Prisma.ProfessionalIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>
          }
          createMany: {
            args: Prisma.ProfessionalIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfessionalIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>[]
          }
          delete: {
            args: Prisma.ProfessionalIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>
          }
          update: {
            args: Prisma.ProfessionalIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>
          }
          deleteMany: {
            args: Prisma.ProfessionalIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfessionalIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfessionalIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>[]
          }
          upsert: {
            args: Prisma.ProfessionalIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfessionalIncomePayload>
          }
          aggregate: {
            args: Prisma.ProfessionalIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfessionalIncome>
          }
          groupBy: {
            args: Prisma.ProfessionalIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfessionalIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfessionalIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<ProfessionalIncomeCountAggregateOutputType> | number
          }
        }
      }
      ProfitLoss: {
        payload: Prisma.$ProfitLossPayload<ExtArgs>
        fields: Prisma.ProfitLossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfitLossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfitLossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>
          }
          findFirst: {
            args: Prisma.ProfitLossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfitLossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>
          }
          findMany: {
            args: Prisma.ProfitLossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>[]
          }
          create: {
            args: Prisma.ProfitLossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>
          }
          createMany: {
            args: Prisma.ProfitLossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfitLossCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>[]
          }
          delete: {
            args: Prisma.ProfitLossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>
          }
          update: {
            args: Prisma.ProfitLossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>
          }
          deleteMany: {
            args: Prisma.ProfitLossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfitLossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfitLossUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>[]
          }
          upsert: {
            args: Prisma.ProfitLossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfitLossPayload>
          }
          aggregate: {
            args: Prisma.ProfitLossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfitLoss>
          }
          groupBy: {
            args: Prisma.ProfitLossGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfitLossGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfitLossCountArgs<ExtArgs>
            result: $Utils.Optional<ProfitLossCountAggregateOutputType> | number
          }
        }
      }
      BalanceSheet: {
        payload: Prisma.$BalanceSheetPayload<ExtArgs>
        fields: Prisma.BalanceSheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceSheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceSheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>
          }
          findFirst: {
            args: Prisma.BalanceSheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceSheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>
          }
          findMany: {
            args: Prisma.BalanceSheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>[]
          }
          create: {
            args: Prisma.BalanceSheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>
          }
          createMany: {
            args: Prisma.BalanceSheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceSheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>[]
          }
          delete: {
            args: Prisma.BalanceSheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>
          }
          update: {
            args: Prisma.BalanceSheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>
          }
          deleteMany: {
            args: Prisma.BalanceSheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceSheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceSheetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>[]
          }
          upsert: {
            args: Prisma.BalanceSheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalanceSheetPayload>
          }
          aggregate: {
            args: Prisma.BalanceSheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalanceSheet>
          }
          groupBy: {
            args: Prisma.BalanceSheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceSheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceSheetCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceSheetCountAggregateOutputType> | number
          }
        }
      }
      DepreciationEntry: {
        payload: Prisma.$DepreciationEntryPayload<ExtArgs>
        fields: Prisma.DepreciationEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepreciationEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepreciationEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>
          }
          findFirst: {
            args: Prisma.DepreciationEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepreciationEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>
          }
          findMany: {
            args: Prisma.DepreciationEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>[]
          }
          create: {
            args: Prisma.DepreciationEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>
          }
          createMany: {
            args: Prisma.DepreciationEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepreciationEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>[]
          }
          delete: {
            args: Prisma.DepreciationEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>
          }
          update: {
            args: Prisma.DepreciationEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>
          }
          deleteMany: {
            args: Prisma.DepreciationEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepreciationEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepreciationEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>[]
          }
          upsert: {
            args: Prisma.DepreciationEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepreciationEntryPayload>
          }
          aggregate: {
            args: Prisma.DepreciationEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepreciationEntry>
          }
          groupBy: {
            args: Prisma.DepreciationEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepreciationEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepreciationEntryCountArgs<ExtArgs>
            result: $Utils.Optional<DepreciationEntryCountAggregateOutputType> | number
          }
        }
      }
      CryptoIncome: {
        payload: Prisma.$CryptoIncomePayload<ExtArgs>
        fields: Prisma.CryptoIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>
          }
          findFirst: {
            args: Prisma.CryptoIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>
          }
          findMany: {
            args: Prisma.CryptoIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>[]
          }
          create: {
            args: Prisma.CryptoIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>
          }
          createMany: {
            args: Prisma.CryptoIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>[]
          }
          delete: {
            args: Prisma.CryptoIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>
          }
          update: {
            args: Prisma.CryptoIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>
          }
          deleteMany: {
            args: Prisma.CryptoIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CryptoIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>[]
          }
          upsert: {
            args: Prisma.CryptoIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoIncomePayload>
          }
          aggregate: {
            args: Prisma.CryptoIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoIncome>
          }
          groupBy: {
            args: Prisma.CryptoIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoIncomeCountAggregateOutputType> | number
          }
        }
      }
      AgriculturalIncome: {
        payload: Prisma.$AgriculturalIncomePayload<ExtArgs>
        fields: Prisma.AgriculturalIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgriculturalIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgriculturalIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>
          }
          findFirst: {
            args: Prisma.AgriculturalIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgriculturalIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>
          }
          findMany: {
            args: Prisma.AgriculturalIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>[]
          }
          create: {
            args: Prisma.AgriculturalIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>
          }
          createMany: {
            args: Prisma.AgriculturalIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgriculturalIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>[]
          }
          delete: {
            args: Prisma.AgriculturalIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>
          }
          update: {
            args: Prisma.AgriculturalIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>
          }
          deleteMany: {
            args: Prisma.AgriculturalIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgriculturalIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgriculturalIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>[]
          }
          upsert: {
            args: Prisma.AgriculturalIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgriculturalIncomePayload>
          }
          aggregate: {
            args: Prisma.AgriculturalIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgriculturalIncome>
          }
          groupBy: {
            args: Prisma.AgriculturalIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgriculturalIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgriculturalIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<AgriculturalIncomeCountAggregateOutputType> | number
          }
        }
      }
      ExemptIncome: {
        payload: Prisma.$ExemptIncomePayload<ExtArgs>
        fields: Prisma.ExemptIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExemptIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExemptIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>
          }
          findFirst: {
            args: Prisma.ExemptIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExemptIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>
          }
          findMany: {
            args: Prisma.ExemptIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>[]
          }
          create: {
            args: Prisma.ExemptIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>
          }
          createMany: {
            args: Prisma.ExemptIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExemptIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>[]
          }
          delete: {
            args: Prisma.ExemptIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>
          }
          update: {
            args: Prisma.ExemptIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>
          }
          deleteMany: {
            args: Prisma.ExemptIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExemptIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExemptIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>[]
          }
          upsert: {
            args: Prisma.ExemptIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExemptIncomePayload>
          }
          aggregate: {
            args: Prisma.ExemptIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExemptIncome>
          }
          groupBy: {
            args: Prisma.ExemptIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExemptIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExemptIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<ExemptIncomeCountAggregateOutputType> | number
          }
        }
      }
      TaxSavingInvestment: {
        payload: Prisma.$TaxSavingInvestmentPayload<ExtArgs>
        fields: Prisma.TaxSavingInvestmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxSavingInvestmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxSavingInvestmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>
          }
          findFirst: {
            args: Prisma.TaxSavingInvestmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxSavingInvestmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>
          }
          findMany: {
            args: Prisma.TaxSavingInvestmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>[]
          }
          create: {
            args: Prisma.TaxSavingInvestmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>
          }
          createMany: {
            args: Prisma.TaxSavingInvestmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxSavingInvestmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>[]
          }
          delete: {
            args: Prisma.TaxSavingInvestmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>
          }
          update: {
            args: Prisma.TaxSavingInvestmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>
          }
          deleteMany: {
            args: Prisma.TaxSavingInvestmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxSavingInvestmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxSavingInvestmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>[]
          }
          upsert: {
            args: Prisma.TaxSavingInvestmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSavingInvestmentPayload>
          }
          aggregate: {
            args: Prisma.TaxSavingInvestmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxSavingInvestment>
          }
          groupBy: {
            args: Prisma.TaxSavingInvestmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxSavingInvestmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxSavingInvestmentCountArgs<ExtArgs>
            result: $Utils.Optional<TaxSavingInvestmentCountAggregateOutputType> | number
          }
        }
      }
      Donation: {
        payload: Prisma.$DonationPayload<ExtArgs>
        fields: Prisma.DonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findFirst: {
            args: Prisma.DonationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findMany: {
            args: Prisma.DonationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          create: {
            args: Prisma.DonationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          createMany: {
            args: Prisma.DonationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DonationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          delete: {
            args: Prisma.DonationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          update: {
            args: Prisma.DonationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          deleteMany: {
            args: Prisma.DonationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DonationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          upsert: {
            args: Prisma.DonationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          aggregate: {
            args: Prisma.DonationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonation>
          }
          groupBy: {
            args: Prisma.DonationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonationCountArgs<ExtArgs>
            result: $Utils.Optional<DonationCountAggregateOutputType> | number
          }
        }
      }
      MedicalInsurance: {
        payload: Prisma.$MedicalInsurancePayload<ExtArgs>
        fields: Prisma.MedicalInsuranceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalInsuranceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalInsuranceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>
          }
          findFirst: {
            args: Prisma.MedicalInsuranceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalInsuranceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>
          }
          findMany: {
            args: Prisma.MedicalInsuranceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>[]
          }
          create: {
            args: Prisma.MedicalInsuranceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>
          }
          createMany: {
            args: Prisma.MedicalInsuranceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalInsuranceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>[]
          }
          delete: {
            args: Prisma.MedicalInsuranceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>
          }
          update: {
            args: Prisma.MedicalInsuranceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>
          }
          deleteMany: {
            args: Prisma.MedicalInsuranceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalInsuranceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalInsuranceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>[]
          }
          upsert: {
            args: Prisma.MedicalInsuranceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalInsurancePayload>
          }
          aggregate: {
            args: Prisma.MedicalInsuranceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalInsurance>
          }
          groupBy: {
            args: Prisma.MedicalInsuranceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalInsuranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalInsuranceCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalInsuranceCountAggregateOutputType> | number
          }
        }
      }
      TaxPaid: {
        payload: Prisma.$TaxPaidPayload<ExtArgs>
        fields: Prisma.TaxPaidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxPaidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxPaidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>
          }
          findFirst: {
            args: Prisma.TaxPaidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxPaidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>
          }
          findMany: {
            args: Prisma.TaxPaidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>[]
          }
          create: {
            args: Prisma.TaxPaidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>
          }
          createMany: {
            args: Prisma.TaxPaidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxPaidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>[]
          }
          delete: {
            args: Prisma.TaxPaidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>
          }
          update: {
            args: Prisma.TaxPaidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>
          }
          deleteMany: {
            args: Prisma.TaxPaidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxPaidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxPaidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>[]
          }
          upsert: {
            args: Prisma.TaxPaidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPaidPayload>
          }
          aggregate: {
            args: Prisma.TaxPaidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxPaid>
          }
          groupBy: {
            args: Prisma.TaxPaidGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxPaidGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxPaidCountArgs<ExtArgs>
            result: $Utils.Optional<TaxPaidCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      ITRGeneration: {
        payload: Prisma.$ITRGenerationPayload<ExtArgs>
        fields: Prisma.ITRGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ITRGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ITRGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>
          }
          findFirst: {
            args: Prisma.ITRGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ITRGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>
          }
          findMany: {
            args: Prisma.ITRGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>[]
          }
          create: {
            args: Prisma.ITRGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>
          }
          createMany: {
            args: Prisma.ITRGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ITRGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>[]
          }
          delete: {
            args: Prisma.ITRGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>
          }
          update: {
            args: Prisma.ITRGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>
          }
          deleteMany: {
            args: Prisma.ITRGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ITRGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ITRGenerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>[]
          }
          upsert: {
            args: Prisma.ITRGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ITRGenerationPayload>
          }
          aggregate: {
            args: Prisma.ITRGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateITRGeneration>
          }
          groupBy: {
            args: Prisma.ITRGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ITRGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ITRGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<ITRGenerationCountAggregateOutputType> | number
          }
        }
      }
      TaxSummary: {
        payload: Prisma.$TaxSummaryPayload<ExtArgs>
        fields: Prisma.TaxSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>
          }
          findFirst: {
            args: Prisma.TaxSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>
          }
          findMany: {
            args: Prisma.TaxSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>[]
          }
          create: {
            args: Prisma.TaxSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>
          }
          createMany: {
            args: Prisma.TaxSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxSummaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>[]
          }
          delete: {
            args: Prisma.TaxSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>
          }
          update: {
            args: Prisma.TaxSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>
          }
          deleteMany: {
            args: Prisma.TaxSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxSummaryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>[]
          }
          upsert: {
            args: Prisma.TaxSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxSummaryPayload>
          }
          aggregate: {
            args: Prisma.TaxSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxSummary>
          }
          groupBy: {
            args: Prisma.TaxSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<TaxSummaryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    personalDetail?: PersonalDetailOmit
    contactDetail?: ContactDetailOmit
    addressDetail?: AddressDetailOmit
    bankDetail?: BankDetailOmit
    form16Data?: Form16DataOmit
    property?: PropertyOmit
    capitalGain?: CapitalGainOmit
    interestIncome?: InterestIncomeOmit
    dividendIncome?: DividendIncomeOmit
    businessIncome?: BusinessIncomeOmit
    professionalIncome?: ProfessionalIncomeOmit
    profitLoss?: ProfitLossOmit
    balanceSheet?: BalanceSheetOmit
    depreciationEntry?: DepreciationEntryOmit
    cryptoIncome?: CryptoIncomeOmit
    agriculturalIncome?: AgriculturalIncomeOmit
    exemptIncome?: ExemptIncomeOmit
    taxSavingInvestment?: TaxSavingInvestmentOmit
    donation?: DonationOmit
    medicalInsurance?: MedicalInsuranceOmit
    taxPaid?: TaxPaidOmit
    wallet?: WalletOmit
    walletTransaction?: WalletTransactionOmit
    iTRGeneration?: ITRGenerationOmit
    taxSummary?: TaxSummaryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    form16Data: number
    properties: number
    capitalGains: number
    cryptoIncome: number
    donations: number
    medicalInsurance: number
    taxPaid: number
    interestIncome: number
    dividendIncome: number
    agriculturalIncome: number
    exemptIncome: number
    itrGenerations: number
    taxSummaries: number
    profitLoss: number
    balanceSheets: number
    depreciationEntries: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    form16Data?: boolean | UserCountOutputTypeCountForm16DataArgs
    properties?: boolean | UserCountOutputTypeCountPropertiesArgs
    capitalGains?: boolean | UserCountOutputTypeCountCapitalGainsArgs
    cryptoIncome?: boolean | UserCountOutputTypeCountCryptoIncomeArgs
    donations?: boolean | UserCountOutputTypeCountDonationsArgs
    medicalInsurance?: boolean | UserCountOutputTypeCountMedicalInsuranceArgs
    taxPaid?: boolean | UserCountOutputTypeCountTaxPaidArgs
    interestIncome?: boolean | UserCountOutputTypeCountInterestIncomeArgs
    dividendIncome?: boolean | UserCountOutputTypeCountDividendIncomeArgs
    agriculturalIncome?: boolean | UserCountOutputTypeCountAgriculturalIncomeArgs
    exemptIncome?: boolean | UserCountOutputTypeCountExemptIncomeArgs
    itrGenerations?: boolean | UserCountOutputTypeCountItrGenerationsArgs
    taxSummaries?: boolean | UserCountOutputTypeCountTaxSummariesArgs
    profitLoss?: boolean | UserCountOutputTypeCountProfitLossArgs
    balanceSheets?: boolean | UserCountOutputTypeCountBalanceSheetsArgs
    depreciationEntries?: boolean | UserCountOutputTypeCountDepreciationEntriesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForm16DataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Form16DataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCapitalGainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapitalGainWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCryptoIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoIncomeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicalInsuranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalInsuranceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaxPaidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxPaidWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterestIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestIncomeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDividendIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DividendIncomeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgriculturalIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgriculturalIncomeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExemptIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExemptIncomeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountItrGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ITRGenerationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaxSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxSummaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfitLossArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfitLossWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBalanceSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceSheetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepreciationEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepreciationEntryWhereInput
  }


  /**
   * Count Type BusinessIncomeCountOutputType
   */

  export type BusinessIncomeCountOutputType = {
    profitLoss: number
    balanceSheet: number
    depreciation: number
  }

  export type BusinessIncomeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profitLoss?: boolean | BusinessIncomeCountOutputTypeCountProfitLossArgs
    balanceSheet?: boolean | BusinessIncomeCountOutputTypeCountBalanceSheetArgs
    depreciation?: boolean | BusinessIncomeCountOutputTypeCountDepreciationArgs
  }

  // Custom InputTypes
  /**
   * BusinessIncomeCountOutputType without action
   */
  export type BusinessIncomeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncomeCountOutputType
     */
    select?: BusinessIncomeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessIncomeCountOutputType without action
   */
  export type BusinessIncomeCountOutputTypeCountProfitLossArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfitLossWhereInput
  }

  /**
   * BusinessIncomeCountOutputType without action
   */
  export type BusinessIncomeCountOutputTypeCountBalanceSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceSheetWhereInput
  }

  /**
   * BusinessIncomeCountOutputType without action
   */
  export type BusinessIncomeCountOutputTypeCountDepreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepreciationEntryWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    transactions: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    emailVerified: boolean | null
    emailVerificationDate: Date | null
    lastVerificationEmailSent: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    emailVerified: boolean | null
    emailVerificationDate: Date | null
    lastVerificationEmailSent: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    password: number
    role: number
    emailVerified: number
    emailVerificationDate: number
    lastVerificationEmailSent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    emailVerificationDate?: true
    lastVerificationEmailSent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    emailVerificationDate?: true
    lastVerificationEmailSent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    emailVerificationDate?: true
    lastVerificationEmailSent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    email: string
    password: string | null
    role: $Enums.Role
    emailVerified: boolean
    emailVerificationDate: Date | null
    lastVerificationEmailSent: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    emailVerificationDate?: boolean
    lastVerificationEmailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personalDetails?: boolean | User$personalDetailsArgs<ExtArgs>
    contactDetails?: boolean | User$contactDetailsArgs<ExtArgs>
    bankDetails?: boolean | User$bankDetailsArgs<ExtArgs>
    addressDetails?: boolean | User$addressDetailsArgs<ExtArgs>
    form16Data?: boolean | User$form16DataArgs<ExtArgs>
    properties?: boolean | User$propertiesArgs<ExtArgs>
    capitalGains?: boolean | User$capitalGainsArgs<ExtArgs>
    businessIncome?: boolean | User$businessIncomeArgs<ExtArgs>
    professionalIncome?: boolean | User$professionalIncomeArgs<ExtArgs>
    cryptoIncome?: boolean | User$cryptoIncomeArgs<ExtArgs>
    taxSavingInvestments?: boolean | User$taxSavingInvestmentsArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    medicalInsurance?: boolean | User$medicalInsuranceArgs<ExtArgs>
    taxPaid?: boolean | User$taxPaidArgs<ExtArgs>
    interestIncome?: boolean | User$interestIncomeArgs<ExtArgs>
    dividendIncome?: boolean | User$dividendIncomeArgs<ExtArgs>
    agriculturalIncome?: boolean | User$agriculturalIncomeArgs<ExtArgs>
    exemptIncome?: boolean | User$exemptIncomeArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    itrGenerations?: boolean | User$itrGenerationsArgs<ExtArgs>
    taxSummaries?: boolean | User$taxSummariesArgs<ExtArgs>
    profitLoss?: boolean | User$profitLossArgs<ExtArgs>
    balanceSheets?: boolean | User$balanceSheetsArgs<ExtArgs>
    depreciationEntries?: boolean | User$depreciationEntriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    emailVerificationDate?: boolean
    lastVerificationEmailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    emailVerificationDate?: boolean
    lastVerificationEmailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    emailVerificationDate?: boolean
    lastVerificationEmailSent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "password" | "role" | "emailVerified" | "emailVerificationDate" | "lastVerificationEmailSent" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalDetails?: boolean | User$personalDetailsArgs<ExtArgs>
    contactDetails?: boolean | User$contactDetailsArgs<ExtArgs>
    bankDetails?: boolean | User$bankDetailsArgs<ExtArgs>
    addressDetails?: boolean | User$addressDetailsArgs<ExtArgs>
    form16Data?: boolean | User$form16DataArgs<ExtArgs>
    properties?: boolean | User$propertiesArgs<ExtArgs>
    capitalGains?: boolean | User$capitalGainsArgs<ExtArgs>
    businessIncome?: boolean | User$businessIncomeArgs<ExtArgs>
    professionalIncome?: boolean | User$professionalIncomeArgs<ExtArgs>
    cryptoIncome?: boolean | User$cryptoIncomeArgs<ExtArgs>
    taxSavingInvestments?: boolean | User$taxSavingInvestmentsArgs<ExtArgs>
    donations?: boolean | User$donationsArgs<ExtArgs>
    medicalInsurance?: boolean | User$medicalInsuranceArgs<ExtArgs>
    taxPaid?: boolean | User$taxPaidArgs<ExtArgs>
    interestIncome?: boolean | User$interestIncomeArgs<ExtArgs>
    dividendIncome?: boolean | User$dividendIncomeArgs<ExtArgs>
    agriculturalIncome?: boolean | User$agriculturalIncomeArgs<ExtArgs>
    exemptIncome?: boolean | User$exemptIncomeArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    itrGenerations?: boolean | User$itrGenerationsArgs<ExtArgs>
    taxSummaries?: boolean | User$taxSummariesArgs<ExtArgs>
    profitLoss?: boolean | User$profitLossArgs<ExtArgs>
    balanceSheets?: boolean | User$balanceSheetsArgs<ExtArgs>
    depreciationEntries?: boolean | User$depreciationEntriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      personalDetails: Prisma.$PersonalDetailPayload<ExtArgs> | null
      contactDetails: Prisma.$ContactDetailPayload<ExtArgs> | null
      bankDetails: Prisma.$BankDetailPayload<ExtArgs> | null
      addressDetails: Prisma.$AddressDetailPayload<ExtArgs> | null
      form16Data: Prisma.$Form16DataPayload<ExtArgs>[]
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      capitalGains: Prisma.$CapitalGainPayload<ExtArgs>[]
      businessIncome: Prisma.$BusinessIncomePayload<ExtArgs> | null
      professionalIncome: Prisma.$ProfessionalIncomePayload<ExtArgs> | null
      cryptoIncome: Prisma.$CryptoIncomePayload<ExtArgs>[]
      taxSavingInvestments: Prisma.$TaxSavingInvestmentPayload<ExtArgs> | null
      donations: Prisma.$DonationPayload<ExtArgs>[]
      medicalInsurance: Prisma.$MedicalInsurancePayload<ExtArgs>[]
      taxPaid: Prisma.$TaxPaidPayload<ExtArgs>[]
      interestIncome: Prisma.$InterestIncomePayload<ExtArgs>[]
      dividendIncome: Prisma.$DividendIncomePayload<ExtArgs>[]
      agriculturalIncome: Prisma.$AgriculturalIncomePayload<ExtArgs>[]
      exemptIncome: Prisma.$ExemptIncomePayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      itrGenerations: Prisma.$ITRGenerationPayload<ExtArgs>[]
      taxSummaries: Prisma.$TaxSummaryPayload<ExtArgs>[]
      profitLoss: Prisma.$ProfitLossPayload<ExtArgs>[]
      balanceSheets: Prisma.$BalanceSheetPayload<ExtArgs>[]
      depreciationEntries: Prisma.$DepreciationEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      email: string
      password: string | null
      role: $Enums.Role
      emailVerified: boolean
      emailVerificationDate: Date | null
      lastVerificationEmailSent: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    personalDetails<T extends User$personalDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$personalDetailsArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contactDetails<T extends User$contactDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactDetailsArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bankDetails<T extends User$bankDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$bankDetailsArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addressDetails<T extends User$addressDetailsArgs<ExtArgs> = {}>(args?: Subset<T, User$addressDetailsArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    form16Data<T extends User$form16DataArgs<ExtArgs> = {}>(args?: Subset<T, User$form16DataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    properties<T extends User$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, User$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capitalGains<T extends User$capitalGainsArgs<ExtArgs> = {}>(args?: Subset<T, User$capitalGainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessIncome<T extends User$businessIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$businessIncomeArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    professionalIncome<T extends User$professionalIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$professionalIncomeArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cryptoIncome<T extends User$cryptoIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$cryptoIncomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxSavingInvestments<T extends User$taxSavingInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taxSavingInvestmentsArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    donations<T extends User$donationsArgs<ExtArgs> = {}>(args?: Subset<T, User$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalInsurance<T extends User$medicalInsuranceArgs<ExtArgs> = {}>(args?: Subset<T, User$medicalInsuranceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxPaid<T extends User$taxPaidArgs<ExtArgs> = {}>(args?: Subset<T, User$taxPaidArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interestIncome<T extends User$interestIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$interestIncomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dividendIncome<T extends User$dividendIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$dividendIncomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agriculturalIncome<T extends User$agriculturalIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$agriculturalIncomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exemptIncome<T extends User$exemptIncomeArgs<ExtArgs> = {}>(args?: Subset<T, User$exemptIncomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itrGenerations<T extends User$itrGenerationsArgs<ExtArgs> = {}>(args?: Subset<T, User$itrGenerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxSummaries<T extends User$taxSummariesArgs<ExtArgs> = {}>(args?: Subset<T, User$taxSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profitLoss<T extends User$profitLossArgs<ExtArgs> = {}>(args?: Subset<T, User$profitLossArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balanceSheets<T extends User$balanceSheetsArgs<ExtArgs> = {}>(args?: Subset<T, User$balanceSheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    depreciationEntries<T extends User$depreciationEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$depreciationEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerificationDate: FieldRef<"User", 'DateTime'>
    readonly lastVerificationEmailSent: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.personalDetails
   */
  export type User$personalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    where?: PersonalDetailWhereInput
  }

  /**
   * User.contactDetails
   */
  export type User$contactDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    where?: ContactDetailWhereInput
  }

  /**
   * User.bankDetails
   */
  export type User$bankDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    where?: BankDetailWhereInput
  }

  /**
   * User.addressDetails
   */
  export type User$addressDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    where?: AddressDetailWhereInput
  }

  /**
   * User.form16Data
   */
  export type User$form16DataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    where?: Form16DataWhereInput
    orderBy?: Form16DataOrderByWithRelationInput | Form16DataOrderByWithRelationInput[]
    cursor?: Form16DataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Form16DataScalarFieldEnum | Form16DataScalarFieldEnum[]
  }

  /**
   * User.properties
   */
  export type User$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.capitalGains
   */
  export type User$capitalGainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    where?: CapitalGainWhereInput
    orderBy?: CapitalGainOrderByWithRelationInput | CapitalGainOrderByWithRelationInput[]
    cursor?: CapitalGainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapitalGainScalarFieldEnum | CapitalGainScalarFieldEnum[]
  }

  /**
   * User.businessIncome
   */
  export type User$businessIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    where?: BusinessIncomeWhereInput
  }

  /**
   * User.professionalIncome
   */
  export type User$professionalIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    where?: ProfessionalIncomeWhereInput
  }

  /**
   * User.cryptoIncome
   */
  export type User$cryptoIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    where?: CryptoIncomeWhereInput
    orderBy?: CryptoIncomeOrderByWithRelationInput | CryptoIncomeOrderByWithRelationInput[]
    cursor?: CryptoIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoIncomeScalarFieldEnum | CryptoIncomeScalarFieldEnum[]
  }

  /**
   * User.taxSavingInvestments
   */
  export type User$taxSavingInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    where?: TaxSavingInvestmentWhereInput
  }

  /**
   * User.donations
   */
  export type User$donationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * User.medicalInsurance
   */
  export type User$medicalInsuranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    where?: MedicalInsuranceWhereInput
    orderBy?: MedicalInsuranceOrderByWithRelationInput | MedicalInsuranceOrderByWithRelationInput[]
    cursor?: MedicalInsuranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalInsuranceScalarFieldEnum | MedicalInsuranceScalarFieldEnum[]
  }

  /**
   * User.taxPaid
   */
  export type User$taxPaidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    where?: TaxPaidWhereInput
    orderBy?: TaxPaidOrderByWithRelationInput | TaxPaidOrderByWithRelationInput[]
    cursor?: TaxPaidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxPaidScalarFieldEnum | TaxPaidScalarFieldEnum[]
  }

  /**
   * User.interestIncome
   */
  export type User$interestIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    where?: InterestIncomeWhereInput
    orderBy?: InterestIncomeOrderByWithRelationInput | InterestIncomeOrderByWithRelationInput[]
    cursor?: InterestIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestIncomeScalarFieldEnum | InterestIncomeScalarFieldEnum[]
  }

  /**
   * User.dividendIncome
   */
  export type User$dividendIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    where?: DividendIncomeWhereInput
    orderBy?: DividendIncomeOrderByWithRelationInput | DividendIncomeOrderByWithRelationInput[]
    cursor?: DividendIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DividendIncomeScalarFieldEnum | DividendIncomeScalarFieldEnum[]
  }

  /**
   * User.agriculturalIncome
   */
  export type User$agriculturalIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    where?: AgriculturalIncomeWhereInput
    orderBy?: AgriculturalIncomeOrderByWithRelationInput | AgriculturalIncomeOrderByWithRelationInput[]
    cursor?: AgriculturalIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgriculturalIncomeScalarFieldEnum | AgriculturalIncomeScalarFieldEnum[]
  }

  /**
   * User.exemptIncome
   */
  export type User$exemptIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    where?: ExemptIncomeWhereInput
    orderBy?: ExemptIncomeOrderByWithRelationInput | ExemptIncomeOrderByWithRelationInput[]
    cursor?: ExemptIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExemptIncomeScalarFieldEnum | ExemptIncomeScalarFieldEnum[]
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.itrGenerations
   */
  export type User$itrGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    where?: ITRGenerationWhereInput
    orderBy?: ITRGenerationOrderByWithRelationInput | ITRGenerationOrderByWithRelationInput[]
    cursor?: ITRGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ITRGenerationScalarFieldEnum | ITRGenerationScalarFieldEnum[]
  }

  /**
   * User.taxSummaries
   */
  export type User$taxSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    where?: TaxSummaryWhereInput
    orderBy?: TaxSummaryOrderByWithRelationInput | TaxSummaryOrderByWithRelationInput[]
    cursor?: TaxSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxSummaryScalarFieldEnum | TaxSummaryScalarFieldEnum[]
  }

  /**
   * User.profitLoss
   */
  export type User$profitLossArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    where?: ProfitLossWhereInput
    orderBy?: ProfitLossOrderByWithRelationInput | ProfitLossOrderByWithRelationInput[]
    cursor?: ProfitLossWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * User.balanceSheets
   */
  export type User$balanceSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    where?: BalanceSheetWhereInput
    orderBy?: BalanceSheetOrderByWithRelationInput | BalanceSheetOrderByWithRelationInput[]
    cursor?: BalanceSheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceSheetScalarFieldEnum | BalanceSheetScalarFieldEnum[]
  }

  /**
   * User.depreciationEntries
   */
  export type User$depreciationEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    where?: DepreciationEntryWhereInput
    orderBy?: DepreciationEntryOrderByWithRelationInput | DepreciationEntryOrderByWithRelationInput[]
    cursor?: DepreciationEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepreciationEntryScalarFieldEnum | DepreciationEntryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PersonalDetail
   */

  export type AggregatePersonalDetail = {
    _count: PersonalDetailCountAggregateOutputType | null
    _min: PersonalDetailMinAggregateOutputType | null
    _max: PersonalDetailMaxAggregateOutputType | null
  }

  export type PersonalDetailMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    maritalStatus: $Enums.MaritalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalDetailMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    maritalStatus: $Enums.MaritalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalDetailCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    middleName: number
    lastName: number
    dob: number
    gender: number
    maritalStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonalDetailMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dob?: true
    gender?: true
    maritalStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalDetailMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dob?: true
    gender?: true
    maritalStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalDetailCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dob?: true
    gender?: true
    maritalStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonalDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalDetail to aggregate.
     */
    where?: PersonalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailOrderByWithRelationInput | PersonalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalDetails
    **/
    _count?: true | PersonalDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalDetailMaxAggregateInputType
  }

  export type GetPersonalDetailAggregateType<T extends PersonalDetailAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalDetail[P]>
      : GetScalarType<T[P], AggregatePersonalDetail[P]>
  }




  export type PersonalDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalDetailWhereInput
    orderBy?: PersonalDetailOrderByWithAggregationInput | PersonalDetailOrderByWithAggregationInput[]
    by: PersonalDetailScalarFieldEnum[] | PersonalDetailScalarFieldEnum
    having?: PersonalDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalDetailCountAggregateInputType | true
    _min?: PersonalDetailMinAggregateInputType
    _max?: PersonalDetailMaxAggregateInputType
  }

  export type PersonalDetailGroupByOutputType = {
    id: string
    userId: string
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dob: Date | null
    gender: $Enums.Gender | null
    maritalStatus: $Enums.MaritalStatus | null
    createdAt: Date
    updatedAt: Date
    _count: PersonalDetailCountAggregateOutputType | null
    _min: PersonalDetailMinAggregateOutputType | null
    _max: PersonalDetailMaxAggregateOutputType | null
  }

  type GetPersonalDetailGroupByPayload<T extends PersonalDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalDetailGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalDetailGroupByOutputType[P]>
        }
      >
    >


  export type PersonalDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetail"]>

  export type PersonalDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetail"]>

  export type PersonalDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetail"]>

  export type PersonalDetailSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonalDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "middleName" | "lastName" | "dob" | "gender" | "maritalStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["personalDetail"]>
  export type PersonalDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PersonalDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PersonalDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PersonalDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string | null
      middleName: string | null
      lastName: string | null
      dob: Date | null
      gender: $Enums.Gender | null
      maritalStatus: $Enums.MaritalStatus | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["personalDetail"]>
    composites: {}
  }

  type PersonalDetailGetPayload<S extends boolean | null | undefined | PersonalDetailDefaultArgs> = $Result.GetResult<Prisma.$PersonalDetailPayload, S>

  type PersonalDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonalDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalDetailCountAggregateInputType | true
    }

  export interface PersonalDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalDetail'], meta: { name: 'PersonalDetail' } }
    /**
     * Find zero or one PersonalDetail that matches the filter.
     * @param {PersonalDetailFindUniqueArgs} args - Arguments to find a PersonalDetail
     * @example
     * // Get one PersonalDetail
     * const personalDetail = await prisma.personalDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalDetailFindUniqueArgs>(args: SelectSubset<T, PersonalDetailFindUniqueArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonalDetailFindUniqueOrThrowArgs} args - Arguments to find a PersonalDetail
     * @example
     * // Get one PersonalDetail
     * const personalDetail = await prisma.personalDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailFindFirstArgs} args - Arguments to find a PersonalDetail
     * @example
     * // Get one PersonalDetail
     * const personalDetail = await prisma.personalDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalDetailFindFirstArgs>(args?: SelectSubset<T, PersonalDetailFindFirstArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailFindFirstOrThrowArgs} args - Arguments to find a PersonalDetail
     * @example
     * // Get one PersonalDetail
     * const personalDetail = await prisma.personalDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalDetails
     * const personalDetails = await prisma.personalDetail.findMany()
     * 
     * // Get first 10 PersonalDetails
     * const personalDetails = await prisma.personalDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalDetailWithIdOnly = await prisma.personalDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalDetailFindManyArgs>(args?: SelectSubset<T, PersonalDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalDetail.
     * @param {PersonalDetailCreateArgs} args - Arguments to create a PersonalDetail.
     * @example
     * // Create one PersonalDetail
     * const PersonalDetail = await prisma.personalDetail.create({
     *   data: {
     *     // ... data to create a PersonalDetail
     *   }
     * })
     * 
     */
    create<T extends PersonalDetailCreateArgs>(args: SelectSubset<T, PersonalDetailCreateArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalDetails.
     * @param {PersonalDetailCreateManyArgs} args - Arguments to create many PersonalDetails.
     * @example
     * // Create many PersonalDetails
     * const personalDetail = await prisma.personalDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalDetailCreateManyArgs>(args?: SelectSubset<T, PersonalDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalDetails and returns the data saved in the database.
     * @param {PersonalDetailCreateManyAndReturnArgs} args - Arguments to create many PersonalDetails.
     * @example
     * // Create many PersonalDetails
     * const personalDetail = await prisma.personalDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalDetails and only return the `id`
     * const personalDetailWithIdOnly = await prisma.personalDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalDetail.
     * @param {PersonalDetailDeleteArgs} args - Arguments to delete one PersonalDetail.
     * @example
     * // Delete one PersonalDetail
     * const PersonalDetail = await prisma.personalDetail.delete({
     *   where: {
     *     // ... filter to delete one PersonalDetail
     *   }
     * })
     * 
     */
    delete<T extends PersonalDetailDeleteArgs>(args: SelectSubset<T, PersonalDetailDeleteArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalDetail.
     * @param {PersonalDetailUpdateArgs} args - Arguments to update one PersonalDetail.
     * @example
     * // Update one PersonalDetail
     * const personalDetail = await prisma.personalDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalDetailUpdateArgs>(args: SelectSubset<T, PersonalDetailUpdateArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalDetails.
     * @param {PersonalDetailDeleteManyArgs} args - Arguments to filter PersonalDetails to delete.
     * @example
     * // Delete a few PersonalDetails
     * const { count } = await prisma.personalDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalDetailDeleteManyArgs>(args?: SelectSubset<T, PersonalDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalDetails
     * const personalDetail = await prisma.personalDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalDetailUpdateManyArgs>(args: SelectSubset<T, PersonalDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalDetails and returns the data updated in the database.
     * @param {PersonalDetailUpdateManyAndReturnArgs} args - Arguments to update many PersonalDetails.
     * @example
     * // Update many PersonalDetails
     * const personalDetail = await prisma.personalDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalDetails and only return the `id`
     * const personalDetailWithIdOnly = await prisma.personalDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonalDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonalDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalDetail.
     * @param {PersonalDetailUpsertArgs} args - Arguments to update or create a PersonalDetail.
     * @example
     * // Update or create a PersonalDetail
     * const personalDetail = await prisma.personalDetail.upsert({
     *   create: {
     *     // ... data to create a PersonalDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalDetail we want to update
     *   }
     * })
     */
    upsert<T extends PersonalDetailUpsertArgs>(args: SelectSubset<T, PersonalDetailUpsertArgs<ExtArgs>>): Prisma__PersonalDetailClient<$Result.GetResult<Prisma.$PersonalDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailCountArgs} args - Arguments to filter PersonalDetails to count.
     * @example
     * // Count the number of PersonalDetails
     * const count = await prisma.personalDetail.count({
     *   where: {
     *     // ... the filter for the PersonalDetails we want to count
     *   }
     * })
    **/
    count<T extends PersonalDetailCountArgs>(
      args?: Subset<T, PersonalDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalDetailAggregateArgs>(args: Subset<T, PersonalDetailAggregateArgs>): Prisma.PrismaPromise<GetPersonalDetailAggregateType<T>>

    /**
     * Group by PersonalDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalDetailGroupByArgs['orderBy'] }
        : { orderBy?: PersonalDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalDetail model
   */
  readonly fields: PersonalDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalDetail model
   */
  interface PersonalDetailFieldRefs {
    readonly id: FieldRef<"PersonalDetail", 'String'>
    readonly userId: FieldRef<"PersonalDetail", 'String'>
    readonly firstName: FieldRef<"PersonalDetail", 'String'>
    readonly middleName: FieldRef<"PersonalDetail", 'String'>
    readonly lastName: FieldRef<"PersonalDetail", 'String'>
    readonly dob: FieldRef<"PersonalDetail", 'DateTime'>
    readonly gender: FieldRef<"PersonalDetail", 'Gender'>
    readonly maritalStatus: FieldRef<"PersonalDetail", 'MaritalStatus'>
    readonly createdAt: FieldRef<"PersonalDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonalDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonalDetail findUnique
   */
  export type PersonalDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetail to fetch.
     */
    where: PersonalDetailWhereUniqueInput
  }

  /**
   * PersonalDetail findUniqueOrThrow
   */
  export type PersonalDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetail to fetch.
     */
    where: PersonalDetailWhereUniqueInput
  }

  /**
   * PersonalDetail findFirst
   */
  export type PersonalDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetail to fetch.
     */
    where?: PersonalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailOrderByWithRelationInput | PersonalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalDetails.
     */
    cursor?: PersonalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalDetails.
     */
    distinct?: PersonalDetailScalarFieldEnum | PersonalDetailScalarFieldEnum[]
  }

  /**
   * PersonalDetail findFirstOrThrow
   */
  export type PersonalDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetail to fetch.
     */
    where?: PersonalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailOrderByWithRelationInput | PersonalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalDetails.
     */
    cursor?: PersonalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalDetails.
     */
    distinct?: PersonalDetailScalarFieldEnum | PersonalDetailScalarFieldEnum[]
  }

  /**
   * PersonalDetail findMany
   */
  export type PersonalDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailOrderByWithRelationInput | PersonalDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalDetails.
     */
    cursor?: PersonalDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    distinct?: PersonalDetailScalarFieldEnum | PersonalDetailScalarFieldEnum[]
  }

  /**
   * PersonalDetail create
   */
  export type PersonalDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalDetail.
     */
    data: XOR<PersonalDetailCreateInput, PersonalDetailUncheckedCreateInput>
  }

  /**
   * PersonalDetail createMany
   */
  export type PersonalDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalDetails.
     */
    data: PersonalDetailCreateManyInput | PersonalDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalDetail createManyAndReturn
   */
  export type PersonalDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * The data used to create many PersonalDetails.
     */
    data: PersonalDetailCreateManyInput | PersonalDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalDetail update
   */
  export type PersonalDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalDetail.
     */
    data: XOR<PersonalDetailUpdateInput, PersonalDetailUncheckedUpdateInput>
    /**
     * Choose, which PersonalDetail to update.
     */
    where: PersonalDetailWhereUniqueInput
  }

  /**
   * PersonalDetail updateMany
   */
  export type PersonalDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalDetails.
     */
    data: XOR<PersonalDetailUpdateManyMutationInput, PersonalDetailUncheckedUpdateManyInput>
    /**
     * Filter which PersonalDetails to update
     */
    where?: PersonalDetailWhereInput
    /**
     * Limit how many PersonalDetails to update.
     */
    limit?: number
  }

  /**
   * PersonalDetail updateManyAndReturn
   */
  export type PersonalDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * The data used to update PersonalDetails.
     */
    data: XOR<PersonalDetailUpdateManyMutationInput, PersonalDetailUncheckedUpdateManyInput>
    /**
     * Filter which PersonalDetails to update
     */
    where?: PersonalDetailWhereInput
    /**
     * Limit how many PersonalDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonalDetail upsert
   */
  export type PersonalDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalDetail to update in case it exists.
     */
    where: PersonalDetailWhereUniqueInput
    /**
     * In case the PersonalDetail found by the `where` argument doesn't exist, create a new PersonalDetail with this data.
     */
    create: XOR<PersonalDetailCreateInput, PersonalDetailUncheckedCreateInput>
    /**
     * In case the PersonalDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalDetailUpdateInput, PersonalDetailUncheckedUpdateInput>
  }

  /**
   * PersonalDetail delete
   */
  export type PersonalDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
    /**
     * Filter which PersonalDetail to delete.
     */
    where: PersonalDetailWhereUniqueInput
  }

  /**
   * PersonalDetail deleteMany
   */
  export type PersonalDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalDetails to delete
     */
    where?: PersonalDetailWhereInput
    /**
     * Limit how many PersonalDetails to delete.
     */
    limit?: number
  }

  /**
   * PersonalDetail without action
   */
  export type PersonalDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetail
     */
    select?: PersonalDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonalDetail
     */
    omit?: PersonalDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailInclude<ExtArgs> | null
  }


  /**
   * Model ContactDetail
   */

  export type AggregateContactDetail = {
    _count: ContactDetailCountAggregateOutputType | null
    _min: ContactDetailMinAggregateOutputType | null
    _max: ContactDetailMaxAggregateOutputType | null
  }

  export type ContactDetailMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    phone: string | null
    panNumber: string | null
    aadharNumber: string | null
    alternativeEmail: string | null
    alternativePhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactDetailMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    phone: string | null
    panNumber: string | null
    aadharNumber: string | null
    alternativeEmail: string | null
    alternativePhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactDetailCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    phone: number
    panNumber: number
    aadharNumber: number
    alternativeEmail: number
    alternativePhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactDetailMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    panNumber?: true
    aadharNumber?: true
    alternativeEmail?: true
    alternativePhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactDetailMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    panNumber?: true
    aadharNumber?: true
    alternativeEmail?: true
    alternativePhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactDetailCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    phone?: true
    panNumber?: true
    aadharNumber?: true
    alternativeEmail?: true
    alternativePhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactDetail to aggregate.
     */
    where?: ContactDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactDetails to fetch.
     */
    orderBy?: ContactDetailOrderByWithRelationInput | ContactDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactDetails
    **/
    _count?: true | ContactDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactDetailMaxAggregateInputType
  }

  export type GetContactDetailAggregateType<T extends ContactDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateContactDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactDetail[P]>
      : GetScalarType<T[P], AggregateContactDetail[P]>
  }




  export type ContactDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactDetailWhereInput
    orderBy?: ContactDetailOrderByWithAggregationInput | ContactDetailOrderByWithAggregationInput[]
    by: ContactDetailScalarFieldEnum[] | ContactDetailScalarFieldEnum
    having?: ContactDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactDetailCountAggregateInputType | true
    _min?: ContactDetailMinAggregateInputType
    _max?: ContactDetailMaxAggregateInputType
  }

  export type ContactDetailGroupByOutputType = {
    id: string
    userId: string
    email: string | null
    phone: string | null
    panNumber: string | null
    aadharNumber: string | null
    alternativeEmail: string | null
    alternativePhone: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactDetailCountAggregateOutputType | null
    _min: ContactDetailMinAggregateOutputType | null
    _max: ContactDetailMaxAggregateOutputType | null
  }

  type GetContactDetailGroupByPayload<T extends ContactDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ContactDetailGroupByOutputType[P]>
        }
      >
    >


  export type ContactDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    panNumber?: boolean
    aadharNumber?: boolean
    alternativeEmail?: boolean
    alternativePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactDetail"]>

  export type ContactDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    panNumber?: boolean
    aadharNumber?: boolean
    alternativeEmail?: boolean
    alternativePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactDetail"]>

  export type ContactDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    panNumber?: boolean
    aadharNumber?: boolean
    alternativeEmail?: boolean
    alternativePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactDetail"]>

  export type ContactDetailSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    phone?: boolean
    panNumber?: boolean
    aadharNumber?: boolean
    alternativeEmail?: boolean
    alternativePhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "phone" | "panNumber" | "aadharNumber" | "alternativeEmail" | "alternativePhone" | "createdAt" | "updatedAt", ExtArgs["result"]["contactDetail"]>
  export type ContactDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string | null
      phone: string | null
      panNumber: string | null
      aadharNumber: string | null
      alternativeEmail: string | null
      alternativePhone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactDetail"]>
    composites: {}
  }

  type ContactDetailGetPayload<S extends boolean | null | undefined | ContactDetailDefaultArgs> = $Result.GetResult<Prisma.$ContactDetailPayload, S>

  type ContactDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactDetailCountAggregateInputType | true
    }

  export interface ContactDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactDetail'], meta: { name: 'ContactDetail' } }
    /**
     * Find zero or one ContactDetail that matches the filter.
     * @param {ContactDetailFindUniqueArgs} args - Arguments to find a ContactDetail
     * @example
     * // Get one ContactDetail
     * const contactDetail = await prisma.contactDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactDetailFindUniqueArgs>(args: SelectSubset<T, ContactDetailFindUniqueArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactDetailFindUniqueOrThrowArgs} args - Arguments to find a ContactDetail
     * @example
     * // Get one ContactDetail
     * const contactDetail = await prisma.contactDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailFindFirstArgs} args - Arguments to find a ContactDetail
     * @example
     * // Get one ContactDetail
     * const contactDetail = await prisma.contactDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactDetailFindFirstArgs>(args?: SelectSubset<T, ContactDetailFindFirstArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailFindFirstOrThrowArgs} args - Arguments to find a ContactDetail
     * @example
     * // Get one ContactDetail
     * const contactDetail = await prisma.contactDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactDetails
     * const contactDetails = await prisma.contactDetail.findMany()
     * 
     * // Get first 10 ContactDetails
     * const contactDetails = await prisma.contactDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactDetailWithIdOnly = await prisma.contactDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactDetailFindManyArgs>(args?: SelectSubset<T, ContactDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactDetail.
     * @param {ContactDetailCreateArgs} args - Arguments to create a ContactDetail.
     * @example
     * // Create one ContactDetail
     * const ContactDetail = await prisma.contactDetail.create({
     *   data: {
     *     // ... data to create a ContactDetail
     *   }
     * })
     * 
     */
    create<T extends ContactDetailCreateArgs>(args: SelectSubset<T, ContactDetailCreateArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactDetails.
     * @param {ContactDetailCreateManyArgs} args - Arguments to create many ContactDetails.
     * @example
     * // Create many ContactDetails
     * const contactDetail = await prisma.contactDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactDetailCreateManyArgs>(args?: SelectSubset<T, ContactDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactDetails and returns the data saved in the database.
     * @param {ContactDetailCreateManyAndReturnArgs} args - Arguments to create many ContactDetails.
     * @example
     * // Create many ContactDetails
     * const contactDetail = await prisma.contactDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactDetails and only return the `id`
     * const contactDetailWithIdOnly = await prisma.contactDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactDetail.
     * @param {ContactDetailDeleteArgs} args - Arguments to delete one ContactDetail.
     * @example
     * // Delete one ContactDetail
     * const ContactDetail = await prisma.contactDetail.delete({
     *   where: {
     *     // ... filter to delete one ContactDetail
     *   }
     * })
     * 
     */
    delete<T extends ContactDetailDeleteArgs>(args: SelectSubset<T, ContactDetailDeleteArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactDetail.
     * @param {ContactDetailUpdateArgs} args - Arguments to update one ContactDetail.
     * @example
     * // Update one ContactDetail
     * const contactDetail = await prisma.contactDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactDetailUpdateArgs>(args: SelectSubset<T, ContactDetailUpdateArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactDetails.
     * @param {ContactDetailDeleteManyArgs} args - Arguments to filter ContactDetails to delete.
     * @example
     * // Delete a few ContactDetails
     * const { count } = await prisma.contactDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDetailDeleteManyArgs>(args?: SelectSubset<T, ContactDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactDetails
     * const contactDetail = await prisma.contactDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactDetailUpdateManyArgs>(args: SelectSubset<T, ContactDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactDetails and returns the data updated in the database.
     * @param {ContactDetailUpdateManyAndReturnArgs} args - Arguments to update many ContactDetails.
     * @example
     * // Update many ContactDetails
     * const contactDetail = await prisma.contactDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactDetails and only return the `id`
     * const contactDetailWithIdOnly = await prisma.contactDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactDetail.
     * @param {ContactDetailUpsertArgs} args - Arguments to update or create a ContactDetail.
     * @example
     * // Update or create a ContactDetail
     * const contactDetail = await prisma.contactDetail.upsert({
     *   create: {
     *     // ... data to create a ContactDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactDetail we want to update
     *   }
     * })
     */
    upsert<T extends ContactDetailUpsertArgs>(args: SelectSubset<T, ContactDetailUpsertArgs<ExtArgs>>): Prisma__ContactDetailClient<$Result.GetResult<Prisma.$ContactDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailCountArgs} args - Arguments to filter ContactDetails to count.
     * @example
     * // Count the number of ContactDetails
     * const count = await prisma.contactDetail.count({
     *   where: {
     *     // ... the filter for the ContactDetails we want to count
     *   }
     * })
    **/
    count<T extends ContactDetailCountArgs>(
      args?: Subset<T, ContactDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactDetailAggregateArgs>(args: Subset<T, ContactDetailAggregateArgs>): Prisma.PrismaPromise<GetContactDetailAggregateType<T>>

    /**
     * Group by ContactDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactDetailGroupByArgs['orderBy'] }
        : { orderBy?: ContactDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactDetail model
   */
  readonly fields: ContactDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactDetail model
   */
  interface ContactDetailFieldRefs {
    readonly id: FieldRef<"ContactDetail", 'String'>
    readonly userId: FieldRef<"ContactDetail", 'String'>
    readonly email: FieldRef<"ContactDetail", 'String'>
    readonly phone: FieldRef<"ContactDetail", 'String'>
    readonly panNumber: FieldRef<"ContactDetail", 'String'>
    readonly aadharNumber: FieldRef<"ContactDetail", 'String'>
    readonly alternativeEmail: FieldRef<"ContactDetail", 'String'>
    readonly alternativePhone: FieldRef<"ContactDetail", 'String'>
    readonly createdAt: FieldRef<"ContactDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactDetail findUnique
   */
  export type ContactDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContactDetail to fetch.
     */
    where: ContactDetailWhereUniqueInput
  }

  /**
   * ContactDetail findUniqueOrThrow
   */
  export type ContactDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContactDetail to fetch.
     */
    where: ContactDetailWhereUniqueInput
  }

  /**
   * ContactDetail findFirst
   */
  export type ContactDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContactDetail to fetch.
     */
    where?: ContactDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactDetails to fetch.
     */
    orderBy?: ContactDetailOrderByWithRelationInput | ContactDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactDetails.
     */
    cursor?: ContactDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactDetails.
     */
    distinct?: ContactDetailScalarFieldEnum | ContactDetailScalarFieldEnum[]
  }

  /**
   * ContactDetail findFirstOrThrow
   */
  export type ContactDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContactDetail to fetch.
     */
    where?: ContactDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactDetails to fetch.
     */
    orderBy?: ContactDetailOrderByWithRelationInput | ContactDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactDetails.
     */
    cursor?: ContactDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactDetails.
     */
    distinct?: ContactDetailScalarFieldEnum | ContactDetailScalarFieldEnum[]
  }

  /**
   * ContactDetail findMany
   */
  export type ContactDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContactDetails to fetch.
     */
    where?: ContactDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactDetails to fetch.
     */
    orderBy?: ContactDetailOrderByWithRelationInput | ContactDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactDetails.
     */
    cursor?: ContactDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactDetails.
     */
    skip?: number
    distinct?: ContactDetailScalarFieldEnum | ContactDetailScalarFieldEnum[]
  }

  /**
   * ContactDetail create
   */
  export type ContactDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactDetail.
     */
    data: XOR<ContactDetailCreateInput, ContactDetailUncheckedCreateInput>
  }

  /**
   * ContactDetail createMany
   */
  export type ContactDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactDetails.
     */
    data: ContactDetailCreateManyInput | ContactDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactDetail createManyAndReturn
   */
  export type ContactDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * The data used to create many ContactDetails.
     */
    data: ContactDetailCreateManyInput | ContactDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactDetail update
   */
  export type ContactDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactDetail.
     */
    data: XOR<ContactDetailUpdateInput, ContactDetailUncheckedUpdateInput>
    /**
     * Choose, which ContactDetail to update.
     */
    where: ContactDetailWhereUniqueInput
  }

  /**
   * ContactDetail updateMany
   */
  export type ContactDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactDetails.
     */
    data: XOR<ContactDetailUpdateManyMutationInput, ContactDetailUncheckedUpdateManyInput>
    /**
     * Filter which ContactDetails to update
     */
    where?: ContactDetailWhereInput
    /**
     * Limit how many ContactDetails to update.
     */
    limit?: number
  }

  /**
   * ContactDetail updateManyAndReturn
   */
  export type ContactDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * The data used to update ContactDetails.
     */
    data: XOR<ContactDetailUpdateManyMutationInput, ContactDetailUncheckedUpdateManyInput>
    /**
     * Filter which ContactDetails to update
     */
    where?: ContactDetailWhereInput
    /**
     * Limit how many ContactDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactDetail upsert
   */
  export type ContactDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactDetail to update in case it exists.
     */
    where: ContactDetailWhereUniqueInput
    /**
     * In case the ContactDetail found by the `where` argument doesn't exist, create a new ContactDetail with this data.
     */
    create: XOR<ContactDetailCreateInput, ContactDetailUncheckedCreateInput>
    /**
     * In case the ContactDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactDetailUpdateInput, ContactDetailUncheckedUpdateInput>
  }

  /**
   * ContactDetail delete
   */
  export type ContactDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
    /**
     * Filter which ContactDetail to delete.
     */
    where: ContactDetailWhereUniqueInput
  }

  /**
   * ContactDetail deleteMany
   */
  export type ContactDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactDetails to delete
     */
    where?: ContactDetailWhereInput
    /**
     * Limit how many ContactDetails to delete.
     */
    limit?: number
  }

  /**
   * ContactDetail without action
   */
  export type ContactDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactDetail
     */
    select?: ContactDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactDetail
     */
    omit?: ContactDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactDetailInclude<ExtArgs> | null
  }


  /**
   * Model AddressDetail
   */

  export type AggregateAddressDetail = {
    _count: AddressDetailCountAggregateOutputType | null
    _min: AddressDetailMinAggregateOutputType | null
    _max: AddressDetailMaxAggregateOutputType | null
  }

  export type AddressDetailMinAggregateOutputType = {
    id: string | null
    userId: string | null
    flatNo: string | null
    premiseName: string | null
    road: string | null
    area: string | null
    pincode: string | null
    country: string | null
    state: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressDetailMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    flatNo: string | null
    premiseName: string | null
    road: string | null
    area: string | null
    pincode: string | null
    country: string | null
    state: string | null
    city: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressDetailCountAggregateOutputType = {
    id: number
    userId: number
    flatNo: number
    premiseName: number
    road: number
    area: number
    pincode: number
    country: number
    state: number
    city: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressDetailMinAggregateInputType = {
    id?: true
    userId?: true
    flatNo?: true
    premiseName?: true
    road?: true
    area?: true
    pincode?: true
    country?: true
    state?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressDetailMaxAggregateInputType = {
    id?: true
    userId?: true
    flatNo?: true
    premiseName?: true
    road?: true
    area?: true
    pincode?: true
    country?: true
    state?: true
    city?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressDetailCountAggregateInputType = {
    id?: true
    userId?: true
    flatNo?: true
    premiseName?: true
    road?: true
    area?: true
    pincode?: true
    country?: true
    state?: true
    city?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressDetail to aggregate.
     */
    where?: AddressDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressDetails to fetch.
     */
    orderBy?: AddressDetailOrderByWithRelationInput | AddressDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddressDetails
    **/
    _count?: true | AddressDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressDetailMaxAggregateInputType
  }

  export type GetAddressDetailAggregateType<T extends AddressDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateAddressDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddressDetail[P]>
      : GetScalarType<T[P], AggregateAddressDetail[P]>
  }




  export type AddressDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressDetailWhereInput
    orderBy?: AddressDetailOrderByWithAggregationInput | AddressDetailOrderByWithAggregationInput[]
    by: AddressDetailScalarFieldEnum[] | AddressDetailScalarFieldEnum
    having?: AddressDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressDetailCountAggregateInputType | true
    _min?: AddressDetailMinAggregateInputType
    _max?: AddressDetailMaxAggregateInputType
  }

  export type AddressDetailGroupByOutputType = {
    id: string
    userId: string
    flatNo: string | null
    premiseName: string | null
    road: string | null
    area: string | null
    pincode: string | null
    country: string | null
    state: string | null
    city: string | null
    createdAt: Date
    updatedAt: Date
    _count: AddressDetailCountAggregateOutputType | null
    _min: AddressDetailMinAggregateOutputType | null
    _max: AddressDetailMaxAggregateOutputType | null
  }

  type GetAddressDetailGroupByPayload<T extends AddressDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressDetailGroupByOutputType[P]>
            : GetScalarType<T[P], AddressDetailGroupByOutputType[P]>
        }
      >
    >


  export type AddressDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    flatNo?: boolean
    premiseName?: boolean
    road?: boolean
    area?: boolean
    pincode?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressDetail"]>

  export type AddressDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    flatNo?: boolean
    premiseName?: boolean
    road?: boolean
    area?: boolean
    pincode?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressDetail"]>

  export type AddressDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    flatNo?: boolean
    premiseName?: boolean
    road?: boolean
    area?: boolean
    pincode?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressDetail"]>

  export type AddressDetailSelectScalar = {
    id?: boolean
    userId?: boolean
    flatNo?: boolean
    premiseName?: boolean
    road?: boolean
    area?: boolean
    pincode?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "flatNo" | "premiseName" | "road" | "area" | "pincode" | "country" | "state" | "city" | "createdAt" | "updatedAt", ExtArgs["result"]["addressDetail"]>
  export type AddressDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AddressDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AddressDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AddressDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddressDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      flatNo: string | null
      premiseName: string | null
      road: string | null
      area: string | null
      pincode: string | null
      country: string | null
      state: string | null
      city: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["addressDetail"]>
    composites: {}
  }

  type AddressDetailGetPayload<S extends boolean | null | undefined | AddressDetailDefaultArgs> = $Result.GetResult<Prisma.$AddressDetailPayload, S>

  type AddressDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressDetailCountAggregateInputType | true
    }

  export interface AddressDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddressDetail'], meta: { name: 'AddressDetail' } }
    /**
     * Find zero or one AddressDetail that matches the filter.
     * @param {AddressDetailFindUniqueArgs} args - Arguments to find a AddressDetail
     * @example
     * // Get one AddressDetail
     * const addressDetail = await prisma.addressDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressDetailFindUniqueArgs>(args: SelectSubset<T, AddressDetailFindUniqueArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddressDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressDetailFindUniqueOrThrowArgs} args - Arguments to find a AddressDetail
     * @example
     * // Get one AddressDetail
     * const addressDetail = await prisma.addressDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddressDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailFindFirstArgs} args - Arguments to find a AddressDetail
     * @example
     * // Get one AddressDetail
     * const addressDetail = await prisma.addressDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressDetailFindFirstArgs>(args?: SelectSubset<T, AddressDetailFindFirstArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddressDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailFindFirstOrThrowArgs} args - Arguments to find a AddressDetail
     * @example
     * // Get one AddressDetail
     * const addressDetail = await prisma.addressDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddressDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddressDetails
     * const addressDetails = await prisma.addressDetail.findMany()
     * 
     * // Get first 10 AddressDetails
     * const addressDetails = await prisma.addressDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressDetailWithIdOnly = await prisma.addressDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressDetailFindManyArgs>(args?: SelectSubset<T, AddressDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddressDetail.
     * @param {AddressDetailCreateArgs} args - Arguments to create a AddressDetail.
     * @example
     * // Create one AddressDetail
     * const AddressDetail = await prisma.addressDetail.create({
     *   data: {
     *     // ... data to create a AddressDetail
     *   }
     * })
     * 
     */
    create<T extends AddressDetailCreateArgs>(args: SelectSubset<T, AddressDetailCreateArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddressDetails.
     * @param {AddressDetailCreateManyArgs} args - Arguments to create many AddressDetails.
     * @example
     * // Create many AddressDetails
     * const addressDetail = await prisma.addressDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressDetailCreateManyArgs>(args?: SelectSubset<T, AddressDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddressDetails and returns the data saved in the database.
     * @param {AddressDetailCreateManyAndReturnArgs} args - Arguments to create many AddressDetails.
     * @example
     * // Create many AddressDetails
     * const addressDetail = await prisma.addressDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddressDetails and only return the `id`
     * const addressDetailWithIdOnly = await prisma.addressDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddressDetail.
     * @param {AddressDetailDeleteArgs} args - Arguments to delete one AddressDetail.
     * @example
     * // Delete one AddressDetail
     * const AddressDetail = await prisma.addressDetail.delete({
     *   where: {
     *     // ... filter to delete one AddressDetail
     *   }
     * })
     * 
     */
    delete<T extends AddressDetailDeleteArgs>(args: SelectSubset<T, AddressDetailDeleteArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddressDetail.
     * @param {AddressDetailUpdateArgs} args - Arguments to update one AddressDetail.
     * @example
     * // Update one AddressDetail
     * const addressDetail = await prisma.addressDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressDetailUpdateArgs>(args: SelectSubset<T, AddressDetailUpdateArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddressDetails.
     * @param {AddressDetailDeleteManyArgs} args - Arguments to filter AddressDetails to delete.
     * @example
     * // Delete a few AddressDetails
     * const { count } = await prisma.addressDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDetailDeleteManyArgs>(args?: SelectSubset<T, AddressDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddressDetails
     * const addressDetail = await prisma.addressDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressDetailUpdateManyArgs>(args: SelectSubset<T, AddressDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressDetails and returns the data updated in the database.
     * @param {AddressDetailUpdateManyAndReturnArgs} args - Arguments to update many AddressDetails.
     * @example
     * // Update many AddressDetails
     * const addressDetail = await prisma.addressDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddressDetails and only return the `id`
     * const addressDetailWithIdOnly = await prisma.addressDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddressDetail.
     * @param {AddressDetailUpsertArgs} args - Arguments to update or create a AddressDetail.
     * @example
     * // Update or create a AddressDetail
     * const addressDetail = await prisma.addressDetail.upsert({
     *   create: {
     *     // ... data to create a AddressDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddressDetail we want to update
     *   }
     * })
     */
    upsert<T extends AddressDetailUpsertArgs>(args: SelectSubset<T, AddressDetailUpsertArgs<ExtArgs>>): Prisma__AddressDetailClient<$Result.GetResult<Prisma.$AddressDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddressDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailCountArgs} args - Arguments to filter AddressDetails to count.
     * @example
     * // Count the number of AddressDetails
     * const count = await prisma.addressDetail.count({
     *   where: {
     *     // ... the filter for the AddressDetails we want to count
     *   }
     * })
    **/
    count<T extends AddressDetailCountArgs>(
      args?: Subset<T, AddressDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddressDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressDetailAggregateArgs>(args: Subset<T, AddressDetailAggregateArgs>): Prisma.PrismaPromise<GetAddressDetailAggregateType<T>>

    /**
     * Group by AddressDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressDetailGroupByArgs['orderBy'] }
        : { orderBy?: AddressDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddressDetail model
   */
  readonly fields: AddressDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddressDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddressDetail model
   */
  interface AddressDetailFieldRefs {
    readonly id: FieldRef<"AddressDetail", 'String'>
    readonly userId: FieldRef<"AddressDetail", 'String'>
    readonly flatNo: FieldRef<"AddressDetail", 'String'>
    readonly premiseName: FieldRef<"AddressDetail", 'String'>
    readonly road: FieldRef<"AddressDetail", 'String'>
    readonly area: FieldRef<"AddressDetail", 'String'>
    readonly pincode: FieldRef<"AddressDetail", 'String'>
    readonly country: FieldRef<"AddressDetail", 'String'>
    readonly state: FieldRef<"AddressDetail", 'String'>
    readonly city: FieldRef<"AddressDetail", 'String'>
    readonly createdAt: FieldRef<"AddressDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"AddressDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AddressDetail findUnique
   */
  export type AddressDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * Filter, which AddressDetail to fetch.
     */
    where: AddressDetailWhereUniqueInput
  }

  /**
   * AddressDetail findUniqueOrThrow
   */
  export type AddressDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * Filter, which AddressDetail to fetch.
     */
    where: AddressDetailWhereUniqueInput
  }

  /**
   * AddressDetail findFirst
   */
  export type AddressDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * Filter, which AddressDetail to fetch.
     */
    where?: AddressDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressDetails to fetch.
     */
    orderBy?: AddressDetailOrderByWithRelationInput | AddressDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressDetails.
     */
    cursor?: AddressDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressDetails.
     */
    distinct?: AddressDetailScalarFieldEnum | AddressDetailScalarFieldEnum[]
  }

  /**
   * AddressDetail findFirstOrThrow
   */
  export type AddressDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * Filter, which AddressDetail to fetch.
     */
    where?: AddressDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressDetails to fetch.
     */
    orderBy?: AddressDetailOrderByWithRelationInput | AddressDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressDetails.
     */
    cursor?: AddressDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressDetails.
     */
    distinct?: AddressDetailScalarFieldEnum | AddressDetailScalarFieldEnum[]
  }

  /**
   * AddressDetail findMany
   */
  export type AddressDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * Filter, which AddressDetails to fetch.
     */
    where?: AddressDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressDetails to fetch.
     */
    orderBy?: AddressDetailOrderByWithRelationInput | AddressDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddressDetails.
     */
    cursor?: AddressDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressDetails.
     */
    skip?: number
    distinct?: AddressDetailScalarFieldEnum | AddressDetailScalarFieldEnum[]
  }

  /**
   * AddressDetail create
   */
  export type AddressDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a AddressDetail.
     */
    data: XOR<AddressDetailCreateInput, AddressDetailUncheckedCreateInput>
  }

  /**
   * AddressDetail createMany
   */
  export type AddressDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddressDetails.
     */
    data: AddressDetailCreateManyInput | AddressDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddressDetail createManyAndReturn
   */
  export type AddressDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * The data used to create many AddressDetails.
     */
    data: AddressDetailCreateManyInput | AddressDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddressDetail update
   */
  export type AddressDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a AddressDetail.
     */
    data: XOR<AddressDetailUpdateInput, AddressDetailUncheckedUpdateInput>
    /**
     * Choose, which AddressDetail to update.
     */
    where: AddressDetailWhereUniqueInput
  }

  /**
   * AddressDetail updateMany
   */
  export type AddressDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddressDetails.
     */
    data: XOR<AddressDetailUpdateManyMutationInput, AddressDetailUncheckedUpdateManyInput>
    /**
     * Filter which AddressDetails to update
     */
    where?: AddressDetailWhereInput
    /**
     * Limit how many AddressDetails to update.
     */
    limit?: number
  }

  /**
   * AddressDetail updateManyAndReturn
   */
  export type AddressDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * The data used to update AddressDetails.
     */
    data: XOR<AddressDetailUpdateManyMutationInput, AddressDetailUncheckedUpdateManyInput>
    /**
     * Filter which AddressDetails to update
     */
    where?: AddressDetailWhereInput
    /**
     * Limit how many AddressDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddressDetail upsert
   */
  export type AddressDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the AddressDetail to update in case it exists.
     */
    where: AddressDetailWhereUniqueInput
    /**
     * In case the AddressDetail found by the `where` argument doesn't exist, create a new AddressDetail with this data.
     */
    create: XOR<AddressDetailCreateInput, AddressDetailUncheckedCreateInput>
    /**
     * In case the AddressDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressDetailUpdateInput, AddressDetailUncheckedUpdateInput>
  }

  /**
   * AddressDetail delete
   */
  export type AddressDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
    /**
     * Filter which AddressDetail to delete.
     */
    where: AddressDetailWhereUniqueInput
  }

  /**
   * AddressDetail deleteMany
   */
  export type AddressDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressDetails to delete
     */
    where?: AddressDetailWhereInput
    /**
     * Limit how many AddressDetails to delete.
     */
    limit?: number
  }

  /**
   * AddressDetail without action
   */
  export type AddressDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressDetail
     */
    select?: AddressDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddressDetail
     */
    omit?: AddressDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressDetailInclude<ExtArgs> | null
  }


  /**
   * Model BankDetail
   */

  export type AggregateBankDetail = {
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  export type BankDetailMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountNumber: string | null
    ifscCode: string | null
    bankName: string | null
    accountType: string | null
    accountHolderName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountNumber: string | null
    ifscCode: string | null
    bankName: string | null
    accountType: string | null
    accountHolderName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailCountAggregateOutputType = {
    id: number
    userId: number
    accountNumber: number
    ifscCode: number
    bankName: number
    accountType: number
    accountHolderName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankDetailMinAggregateInputType = {
    id?: true
    userId?: true
    accountNumber?: true
    ifscCode?: true
    bankName?: true
    accountType?: true
    accountHolderName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailMaxAggregateInputType = {
    id?: true
    userId?: true
    accountNumber?: true
    ifscCode?: true
    bankName?: true
    accountType?: true
    accountHolderName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailCountAggregateInputType = {
    id?: true
    userId?: true
    accountNumber?: true
    ifscCode?: true
    bankName?: true
    accountType?: true
    accountHolderName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetail to aggregate.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailMaxAggregateInputType
  }

  export type GetBankDetailAggregateType<T extends BankDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetail[P]>
      : GetScalarType<T[P], AggregateBankDetail[P]>
  }




  export type BankDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailWhereInput
    orderBy?: BankDetailOrderByWithAggregationInput | BankDetailOrderByWithAggregationInput[]
    by: BankDetailScalarFieldEnum[] | BankDetailScalarFieldEnum
    having?: BankDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailCountAggregateInputType | true
    _min?: BankDetailMinAggregateInputType
    _max?: BankDetailMaxAggregateInputType
  }

  export type BankDetailGroupByOutputType = {
    id: string
    userId: string
    accountNumber: string | null
    ifscCode: string | null
    bankName: string | null
    accountType: string | null
    accountHolderName: string | null
    createdAt: Date
    updatedAt: Date
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  type GetBankDetailGroupByPayload<T extends BankDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    bankName?: boolean
    accountType?: boolean
    accountHolderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    bankName?: boolean
    accountType?: boolean
    accountHolderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    bankName?: boolean
    accountType?: boolean
    accountHolderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectScalar = {
    id?: boolean
    userId?: boolean
    accountNumber?: boolean
    ifscCode?: boolean
    bankName?: boolean
    accountType?: boolean
    accountHolderName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountNumber" | "ifscCode" | "bankName" | "accountType" | "accountHolderName" | "createdAt" | "updatedAt", ExtArgs["result"]["bankDetail"]>
  export type BankDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BankDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BankDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BankDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankDetail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountNumber: string | null
      ifscCode: string | null
      bankName: string | null
      accountType: string | null
      accountHolderName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankDetail"]>
    composites: {}
  }

  type BankDetailGetPayload<S extends boolean | null | undefined | BankDetailDefaultArgs> = $Result.GetResult<Prisma.$BankDetailPayload, S>

  type BankDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankDetailCountAggregateInputType | true
    }

  export interface BankDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetail'], meta: { name: 'BankDetail' } }
    /**
     * Find zero or one BankDetail that matches the filter.
     * @param {BankDetailFindUniqueArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankDetailFindUniqueArgs>(args: SelectSubset<T, BankDetailFindUniqueArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankDetailFindUniqueOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BankDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankDetailFindFirstArgs>(args?: SelectSubset<T, BankDetailFindFirstArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BankDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetail.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankDetailFindManyArgs>(args?: SelectSubset<T, BankDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankDetail.
     * @param {BankDetailCreateArgs} args - Arguments to create a BankDetail.
     * @example
     * // Create one BankDetail
     * const BankDetail = await prisma.bankDetail.create({
     *   data: {
     *     // ... data to create a BankDetail
     *   }
     * })
     * 
     */
    create<T extends BankDetailCreateArgs>(args: SelectSubset<T, BankDetailCreateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankDetails.
     * @param {BankDetailCreateManyArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankDetailCreateManyArgs>(args?: SelectSubset<T, BankDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankDetails and returns the data saved in the database.
     * @param {BankDetailCreateManyAndReturnArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BankDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankDetail.
     * @param {BankDetailDeleteArgs} args - Arguments to delete one BankDetail.
     * @example
     * // Delete one BankDetail
     * const BankDetail = await prisma.bankDetail.delete({
     *   where: {
     *     // ... filter to delete one BankDetail
     *   }
     * })
     * 
     */
    delete<T extends BankDetailDeleteArgs>(args: SelectSubset<T, BankDetailDeleteArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankDetail.
     * @param {BankDetailUpdateArgs} args - Arguments to update one BankDetail.
     * @example
     * // Update one BankDetail
     * const bankDetail = await prisma.bankDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankDetailUpdateArgs>(args: SelectSubset<T, BankDetailUpdateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankDetailDeleteManyArgs>(args?: SelectSubset<T, BankDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankDetailUpdateManyArgs>(args: SelectSubset<T, BankDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails and returns the data updated in the database.
     * @param {BankDetailUpdateManyAndReturnArgs} args - Arguments to update many BankDetails.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BankDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankDetail.
     * @param {BankDetailUpsertArgs} args - Arguments to update or create a BankDetail.
     * @example
     * // Update or create a BankDetail
     * const bankDetail = await prisma.bankDetail.upsert({
     *   create: {
     *     // ... data to create a BankDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetail we want to update
     *   }
     * })
     */
    upsert<T extends BankDetailUpsertArgs>(args: SelectSubset<T, BankDetailUpsertArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetail.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailCountArgs>(
      args?: Subset<T, BankDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailAggregateArgs>(args: Subset<T, BankDetailAggregateArgs>): Prisma.PrismaPromise<GetBankDetailAggregateType<T>>

    /**
     * Group by BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankDetail model
   */
  readonly fields: BankDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankDetail model
   */
  interface BankDetailFieldRefs {
    readonly id: FieldRef<"BankDetail", 'String'>
    readonly userId: FieldRef<"BankDetail", 'String'>
    readonly accountNumber: FieldRef<"BankDetail", 'String'>
    readonly ifscCode: FieldRef<"BankDetail", 'String'>
    readonly bankName: FieldRef<"BankDetail", 'String'>
    readonly accountType: FieldRef<"BankDetail", 'String'>
    readonly accountHolderName: FieldRef<"BankDetail", 'String'>
    readonly createdAt: FieldRef<"BankDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BankDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankDetail findUnique
   */
  export type BankDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findUniqueOrThrow
   */
  export type BankDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findFirst
   */
  export type BankDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findFirstOrThrow
   */
  export type BankDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findMany
   */
  export type BankDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail create
   */
  export type BankDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BankDetail.
     */
    data: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
  }

  /**
   * BankDetail createMany
   */
  export type BankDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetail createManyAndReturn
   */
  export type BankDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetail update
   */
  export type BankDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BankDetail.
     */
    data: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
    /**
     * Choose, which BankDetail to update.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail updateMany
   */
  export type BankDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetail updateManyAndReturn
   */
  export type BankDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankDetail upsert
   */
  export type BankDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BankDetail to update in case it exists.
     */
    where: BankDetailWhereUniqueInput
    /**
     * In case the BankDetail found by the `where` argument doesn't exist, create a new BankDetail with this data.
     */
    create: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
    /**
     * In case the BankDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
  }

  /**
   * BankDetail delete
   */
  export type BankDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
    /**
     * Filter which BankDetail to delete.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail deleteMany
   */
  export type BankDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to delete.
     */
    limit?: number
  }

  /**
   * BankDetail without action
   */
  export type BankDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankDetailInclude<ExtArgs> | null
  }


  /**
   * Model Form16Data
   */

  export type AggregateForm16Data = {
    _count: Form16DataCountAggregateOutputType | null
    _avg: Form16DataAvgAggregateOutputType | null
    _sum: Form16DataSumAggregateOutputType | null
    _min: Form16DataMinAggregateOutputType | null
    _max: Form16DataMaxAggregateOutputType | null
  }

  export type Form16DataAvgAggregateOutputType = {
    totalTax: Decimal | null
    grossSalary: Decimal | null
    notifiedIncome: Decimal | null
    perquisitesAmount: Decimal | null
    profitAmount: Decimal | null
    notifiedIncomeOtherCountry: Decimal | null
    previousYearIncomeTax: Decimal | null
    exemptAllowance: Decimal | null
    balance: Decimal | null
    standardDeduction: Decimal | null
    professionalTax: Decimal | null
    reliefUnder89: Decimal | null
    incomeClaimed: Decimal | null
  }

  export type Form16DataSumAggregateOutputType = {
    totalTax: Decimal | null
    grossSalary: Decimal | null
    notifiedIncome: Decimal | null
    perquisitesAmount: Decimal | null
    profitAmount: Decimal | null
    notifiedIncomeOtherCountry: Decimal | null
    previousYearIncomeTax: Decimal | null
    exemptAllowance: Decimal | null
    balance: Decimal | null
    standardDeduction: Decimal | null
    professionalTax: Decimal | null
    reliefUnder89: Decimal | null
    incomeClaimed: Decimal | null
  }

  export type Form16DataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employerName: string | null
    employerTAN: string | null
    employerCategory: string | null
    totalTax: Decimal | null
    grossSalary: Decimal | null
    notifiedIncome: Decimal | null
    perquisitesAmount: Decimal | null
    profitAmount: Decimal | null
    notifiedIncomeOtherCountry: Decimal | null
    previousYearIncomeTax: Decimal | null
    exemptAllowance: Decimal | null
    balance: Decimal | null
    standardDeduction: Decimal | null
    professionalTax: Decimal | null
    reliefUnder89: Decimal | null
    incomeClaimed: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Form16DataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employerName: string | null
    employerTAN: string | null
    employerCategory: string | null
    totalTax: Decimal | null
    grossSalary: Decimal | null
    notifiedIncome: Decimal | null
    perquisitesAmount: Decimal | null
    profitAmount: Decimal | null
    notifiedIncomeOtherCountry: Decimal | null
    previousYearIncomeTax: Decimal | null
    exemptAllowance: Decimal | null
    balance: Decimal | null
    standardDeduction: Decimal | null
    professionalTax: Decimal | null
    reliefUnder89: Decimal | null
    incomeClaimed: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Form16DataCountAggregateOutputType = {
    id: number
    userId: number
    employerName: number
    employerTAN: number
    employerCategory: number
    totalTax: number
    grossSalary: number
    notifiedIncome: number
    salaryBreakup: number
    perquisitesAmount: number
    perquisites: number
    profitAmount: number
    profitsInLieu: number
    notifiedCountry: number
    notifiedIncomeOtherCountry: number
    previousYearIncomeTax: number
    exemptAllowance: number
    exemptAllowanceBreakup: number
    balance: number
    standardDeduction: number
    professionalTax: number
    reliefUnder89: number
    incomeClaimed: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Form16DataAvgAggregateInputType = {
    totalTax?: true
    grossSalary?: true
    notifiedIncome?: true
    perquisitesAmount?: true
    profitAmount?: true
    notifiedIncomeOtherCountry?: true
    previousYearIncomeTax?: true
    exemptAllowance?: true
    balance?: true
    standardDeduction?: true
    professionalTax?: true
    reliefUnder89?: true
    incomeClaimed?: true
  }

  export type Form16DataSumAggregateInputType = {
    totalTax?: true
    grossSalary?: true
    notifiedIncome?: true
    perquisitesAmount?: true
    profitAmount?: true
    notifiedIncomeOtherCountry?: true
    previousYearIncomeTax?: true
    exemptAllowance?: true
    balance?: true
    standardDeduction?: true
    professionalTax?: true
    reliefUnder89?: true
    incomeClaimed?: true
  }

  export type Form16DataMinAggregateInputType = {
    id?: true
    userId?: true
    employerName?: true
    employerTAN?: true
    employerCategory?: true
    totalTax?: true
    grossSalary?: true
    notifiedIncome?: true
    perquisitesAmount?: true
    profitAmount?: true
    notifiedIncomeOtherCountry?: true
    previousYearIncomeTax?: true
    exemptAllowance?: true
    balance?: true
    standardDeduction?: true
    professionalTax?: true
    reliefUnder89?: true
    incomeClaimed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Form16DataMaxAggregateInputType = {
    id?: true
    userId?: true
    employerName?: true
    employerTAN?: true
    employerCategory?: true
    totalTax?: true
    grossSalary?: true
    notifiedIncome?: true
    perquisitesAmount?: true
    profitAmount?: true
    notifiedIncomeOtherCountry?: true
    previousYearIncomeTax?: true
    exemptAllowance?: true
    balance?: true
    standardDeduction?: true
    professionalTax?: true
    reliefUnder89?: true
    incomeClaimed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Form16DataCountAggregateInputType = {
    id?: true
    userId?: true
    employerName?: true
    employerTAN?: true
    employerCategory?: true
    totalTax?: true
    grossSalary?: true
    notifiedIncome?: true
    salaryBreakup?: true
    perquisitesAmount?: true
    perquisites?: true
    profitAmount?: true
    profitsInLieu?: true
    notifiedCountry?: true
    notifiedIncomeOtherCountry?: true
    previousYearIncomeTax?: true
    exemptAllowance?: true
    exemptAllowanceBreakup?: true
    balance?: true
    standardDeduction?: true
    professionalTax?: true
    reliefUnder89?: true
    incomeClaimed?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Form16DataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form16Data to aggregate.
     */
    where?: Form16DataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Form16Data to fetch.
     */
    orderBy?: Form16DataOrderByWithRelationInput | Form16DataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Form16DataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Form16Data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Form16Data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Form16Data
    **/
    _count?: true | Form16DataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Form16DataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Form16DataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Form16DataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Form16DataMaxAggregateInputType
  }

  export type GetForm16DataAggregateType<T extends Form16DataAggregateArgs> = {
        [P in keyof T & keyof AggregateForm16Data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm16Data[P]>
      : GetScalarType<T[P], AggregateForm16Data[P]>
  }




  export type Form16DataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Form16DataWhereInput
    orderBy?: Form16DataOrderByWithAggregationInput | Form16DataOrderByWithAggregationInput[]
    by: Form16DataScalarFieldEnum[] | Form16DataScalarFieldEnum
    having?: Form16DataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Form16DataCountAggregateInputType | true
    _avg?: Form16DataAvgAggregateInputType
    _sum?: Form16DataSumAggregateInputType
    _min?: Form16DataMinAggregateInputType
    _max?: Form16DataMaxAggregateInputType
  }

  export type Form16DataGroupByOutputType = {
    id: string
    userId: string
    employerName: string | null
    employerTAN: string | null
    employerCategory: string | null
    totalTax: Decimal | null
    grossSalary: Decimal | null
    notifiedIncome: Decimal | null
    salaryBreakup: JsonValue | null
    perquisitesAmount: Decimal | null
    perquisites: JsonValue | null
    profitAmount: Decimal | null
    profitsInLieu: JsonValue | null
    notifiedCountry: JsonValue | null
    notifiedIncomeOtherCountry: Decimal | null
    previousYearIncomeTax: Decimal | null
    exemptAllowance: Decimal | null
    exemptAllowanceBreakup: JsonValue | null
    balance: Decimal | null
    standardDeduction: Decimal | null
    professionalTax: Decimal | null
    reliefUnder89: Decimal | null
    incomeClaimed: Decimal | null
    address: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: Form16DataCountAggregateOutputType | null
    _avg: Form16DataAvgAggregateOutputType | null
    _sum: Form16DataSumAggregateOutputType | null
    _min: Form16DataMinAggregateOutputType | null
    _max: Form16DataMaxAggregateOutputType | null
  }

  type GetForm16DataGroupByPayload<T extends Form16DataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Form16DataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Form16DataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Form16DataGroupByOutputType[P]>
            : GetScalarType<T[P], Form16DataGroupByOutputType[P]>
        }
      >
    >


  export type Form16DataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employerName?: boolean
    employerTAN?: boolean
    employerCategory?: boolean
    totalTax?: boolean
    grossSalary?: boolean
    notifiedIncome?: boolean
    salaryBreakup?: boolean
    perquisitesAmount?: boolean
    perquisites?: boolean
    profitAmount?: boolean
    profitsInLieu?: boolean
    notifiedCountry?: boolean
    notifiedIncomeOtherCountry?: boolean
    previousYearIncomeTax?: boolean
    exemptAllowance?: boolean
    exemptAllowanceBreakup?: boolean
    balance?: boolean
    standardDeduction?: boolean
    professionalTax?: boolean
    reliefUnder89?: boolean
    incomeClaimed?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form16Data"]>

  export type Form16DataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employerName?: boolean
    employerTAN?: boolean
    employerCategory?: boolean
    totalTax?: boolean
    grossSalary?: boolean
    notifiedIncome?: boolean
    salaryBreakup?: boolean
    perquisitesAmount?: boolean
    perquisites?: boolean
    profitAmount?: boolean
    profitsInLieu?: boolean
    notifiedCountry?: boolean
    notifiedIncomeOtherCountry?: boolean
    previousYearIncomeTax?: boolean
    exemptAllowance?: boolean
    exemptAllowanceBreakup?: boolean
    balance?: boolean
    standardDeduction?: boolean
    professionalTax?: boolean
    reliefUnder89?: boolean
    incomeClaimed?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form16Data"]>

  export type Form16DataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employerName?: boolean
    employerTAN?: boolean
    employerCategory?: boolean
    totalTax?: boolean
    grossSalary?: boolean
    notifiedIncome?: boolean
    salaryBreakup?: boolean
    perquisitesAmount?: boolean
    perquisites?: boolean
    profitAmount?: boolean
    profitsInLieu?: boolean
    notifiedCountry?: boolean
    notifiedIncomeOtherCountry?: boolean
    previousYearIncomeTax?: boolean
    exemptAllowance?: boolean
    exemptAllowanceBreakup?: boolean
    balance?: boolean
    standardDeduction?: boolean
    professionalTax?: boolean
    reliefUnder89?: boolean
    incomeClaimed?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["form16Data"]>

  export type Form16DataSelectScalar = {
    id?: boolean
    userId?: boolean
    employerName?: boolean
    employerTAN?: boolean
    employerCategory?: boolean
    totalTax?: boolean
    grossSalary?: boolean
    notifiedIncome?: boolean
    salaryBreakup?: boolean
    perquisitesAmount?: boolean
    perquisites?: boolean
    profitAmount?: boolean
    profitsInLieu?: boolean
    notifiedCountry?: boolean
    notifiedIncomeOtherCountry?: boolean
    previousYearIncomeTax?: boolean
    exemptAllowance?: boolean
    exemptAllowanceBreakup?: boolean
    balance?: boolean
    standardDeduction?: boolean
    professionalTax?: boolean
    reliefUnder89?: boolean
    incomeClaimed?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Form16DataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employerName" | "employerTAN" | "employerCategory" | "totalTax" | "grossSalary" | "notifiedIncome" | "salaryBreakup" | "perquisitesAmount" | "perquisites" | "profitAmount" | "profitsInLieu" | "notifiedCountry" | "notifiedIncomeOtherCountry" | "previousYearIncomeTax" | "exemptAllowance" | "exemptAllowanceBreakup" | "balance" | "standardDeduction" | "professionalTax" | "reliefUnder89" | "incomeClaimed" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["form16Data"]>
  export type Form16DataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type Form16DataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type Form16DataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $Form16DataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Form16Data"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      employerName: string | null
      employerTAN: string | null
      employerCategory: string | null
      totalTax: Prisma.Decimal | null
      grossSalary: Prisma.Decimal | null
      notifiedIncome: Prisma.Decimal | null
      salaryBreakup: Prisma.JsonValue | null
      perquisitesAmount: Prisma.Decimal | null
      perquisites: Prisma.JsonValue | null
      profitAmount: Prisma.Decimal | null
      profitsInLieu: Prisma.JsonValue | null
      notifiedCountry: Prisma.JsonValue | null
      notifiedIncomeOtherCountry: Prisma.Decimal | null
      previousYearIncomeTax: Prisma.Decimal | null
      exemptAllowance: Prisma.Decimal | null
      exemptAllowanceBreakup: Prisma.JsonValue | null
      balance: Prisma.Decimal | null
      standardDeduction: Prisma.Decimal | null
      professionalTax: Prisma.Decimal | null
      reliefUnder89: Prisma.Decimal | null
      incomeClaimed: Prisma.Decimal | null
      address: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["form16Data"]>
    composites: {}
  }

  type Form16DataGetPayload<S extends boolean | null | undefined | Form16DataDefaultArgs> = $Result.GetResult<Prisma.$Form16DataPayload, S>

  type Form16DataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Form16DataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Form16DataCountAggregateInputType | true
    }

  export interface Form16DataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Form16Data'], meta: { name: 'Form16Data' } }
    /**
     * Find zero or one Form16Data that matches the filter.
     * @param {Form16DataFindUniqueArgs} args - Arguments to find a Form16Data
     * @example
     * // Get one Form16Data
     * const form16Data = await prisma.form16Data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Form16DataFindUniqueArgs>(args: SelectSubset<T, Form16DataFindUniqueArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Form16Data that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Form16DataFindUniqueOrThrowArgs} args - Arguments to find a Form16Data
     * @example
     * // Get one Form16Data
     * const form16Data = await prisma.form16Data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Form16DataFindUniqueOrThrowArgs>(args: SelectSubset<T, Form16DataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form16Data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataFindFirstArgs} args - Arguments to find a Form16Data
     * @example
     * // Get one Form16Data
     * const form16Data = await prisma.form16Data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Form16DataFindFirstArgs>(args?: SelectSubset<T, Form16DataFindFirstArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Form16Data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataFindFirstOrThrowArgs} args - Arguments to find a Form16Data
     * @example
     * // Get one Form16Data
     * const form16Data = await prisma.form16Data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Form16DataFindFirstOrThrowArgs>(args?: SelectSubset<T, Form16DataFindFirstOrThrowArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Form16Data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Form16Data
     * const form16Data = await prisma.form16Data.findMany()
     * 
     * // Get first 10 Form16Data
     * const form16Data = await prisma.form16Data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const form16DataWithIdOnly = await prisma.form16Data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Form16DataFindManyArgs>(args?: SelectSubset<T, Form16DataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Form16Data.
     * @param {Form16DataCreateArgs} args - Arguments to create a Form16Data.
     * @example
     * // Create one Form16Data
     * const Form16Data = await prisma.form16Data.create({
     *   data: {
     *     // ... data to create a Form16Data
     *   }
     * })
     * 
     */
    create<T extends Form16DataCreateArgs>(args: SelectSubset<T, Form16DataCreateArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Form16Data.
     * @param {Form16DataCreateManyArgs} args - Arguments to create many Form16Data.
     * @example
     * // Create many Form16Data
     * const form16Data = await prisma.form16Data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Form16DataCreateManyArgs>(args?: SelectSubset<T, Form16DataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Form16Data and returns the data saved in the database.
     * @param {Form16DataCreateManyAndReturnArgs} args - Arguments to create many Form16Data.
     * @example
     * // Create many Form16Data
     * const form16Data = await prisma.form16Data.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Form16Data and only return the `id`
     * const form16DataWithIdOnly = await prisma.form16Data.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Form16DataCreateManyAndReturnArgs>(args?: SelectSubset<T, Form16DataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Form16Data.
     * @param {Form16DataDeleteArgs} args - Arguments to delete one Form16Data.
     * @example
     * // Delete one Form16Data
     * const Form16Data = await prisma.form16Data.delete({
     *   where: {
     *     // ... filter to delete one Form16Data
     *   }
     * })
     * 
     */
    delete<T extends Form16DataDeleteArgs>(args: SelectSubset<T, Form16DataDeleteArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Form16Data.
     * @param {Form16DataUpdateArgs} args - Arguments to update one Form16Data.
     * @example
     * // Update one Form16Data
     * const form16Data = await prisma.form16Data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Form16DataUpdateArgs>(args: SelectSubset<T, Form16DataUpdateArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Form16Data.
     * @param {Form16DataDeleteManyArgs} args - Arguments to filter Form16Data to delete.
     * @example
     * // Delete a few Form16Data
     * const { count } = await prisma.form16Data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Form16DataDeleteManyArgs>(args?: SelectSubset<T, Form16DataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Form16Data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Form16Data
     * const form16Data = await prisma.form16Data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Form16DataUpdateManyArgs>(args: SelectSubset<T, Form16DataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Form16Data and returns the data updated in the database.
     * @param {Form16DataUpdateManyAndReturnArgs} args - Arguments to update many Form16Data.
     * @example
     * // Update many Form16Data
     * const form16Data = await prisma.form16Data.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Form16Data and only return the `id`
     * const form16DataWithIdOnly = await prisma.form16Data.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Form16DataUpdateManyAndReturnArgs>(args: SelectSubset<T, Form16DataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Form16Data.
     * @param {Form16DataUpsertArgs} args - Arguments to update or create a Form16Data.
     * @example
     * // Update or create a Form16Data
     * const form16Data = await prisma.form16Data.upsert({
     *   create: {
     *     // ... data to create a Form16Data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form16Data we want to update
     *   }
     * })
     */
    upsert<T extends Form16DataUpsertArgs>(args: SelectSubset<T, Form16DataUpsertArgs<ExtArgs>>): Prisma__Form16DataClient<$Result.GetResult<Prisma.$Form16DataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Form16Data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataCountArgs} args - Arguments to filter Form16Data to count.
     * @example
     * // Count the number of Form16Data
     * const count = await prisma.form16Data.count({
     *   where: {
     *     // ... the filter for the Form16Data we want to count
     *   }
     * })
    **/
    count<T extends Form16DataCountArgs>(
      args?: Subset<T, Form16DataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Form16DataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form16Data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Form16DataAggregateArgs>(args: Subset<T, Form16DataAggregateArgs>): Prisma.PrismaPromise<GetForm16DataAggregateType<T>>

    /**
     * Group by Form16Data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Form16DataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Form16DataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Form16DataGroupByArgs['orderBy'] }
        : { orderBy?: Form16DataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Form16DataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForm16DataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Form16Data model
   */
  readonly fields: Form16DataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Form16Data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Form16DataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Form16Data model
   */
  interface Form16DataFieldRefs {
    readonly id: FieldRef<"Form16Data", 'String'>
    readonly userId: FieldRef<"Form16Data", 'String'>
    readonly employerName: FieldRef<"Form16Data", 'String'>
    readonly employerTAN: FieldRef<"Form16Data", 'String'>
    readonly employerCategory: FieldRef<"Form16Data", 'String'>
    readonly totalTax: FieldRef<"Form16Data", 'Decimal'>
    readonly grossSalary: FieldRef<"Form16Data", 'Decimal'>
    readonly notifiedIncome: FieldRef<"Form16Data", 'Decimal'>
    readonly salaryBreakup: FieldRef<"Form16Data", 'Json'>
    readonly perquisitesAmount: FieldRef<"Form16Data", 'Decimal'>
    readonly perquisites: FieldRef<"Form16Data", 'Json'>
    readonly profitAmount: FieldRef<"Form16Data", 'Decimal'>
    readonly profitsInLieu: FieldRef<"Form16Data", 'Json'>
    readonly notifiedCountry: FieldRef<"Form16Data", 'Json'>
    readonly notifiedIncomeOtherCountry: FieldRef<"Form16Data", 'Decimal'>
    readonly previousYearIncomeTax: FieldRef<"Form16Data", 'Decimal'>
    readonly exemptAllowance: FieldRef<"Form16Data", 'Decimal'>
    readonly exemptAllowanceBreakup: FieldRef<"Form16Data", 'Json'>
    readonly balance: FieldRef<"Form16Data", 'Decimal'>
    readonly standardDeduction: FieldRef<"Form16Data", 'Decimal'>
    readonly professionalTax: FieldRef<"Form16Data", 'Decimal'>
    readonly reliefUnder89: FieldRef<"Form16Data", 'Decimal'>
    readonly incomeClaimed: FieldRef<"Form16Data", 'Decimal'>
    readonly address: FieldRef<"Form16Data", 'Json'>
    readonly createdAt: FieldRef<"Form16Data", 'DateTime'>
    readonly updatedAt: FieldRef<"Form16Data", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Form16Data findUnique
   */
  export type Form16DataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * Filter, which Form16Data to fetch.
     */
    where: Form16DataWhereUniqueInput
  }

  /**
   * Form16Data findUniqueOrThrow
   */
  export type Form16DataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * Filter, which Form16Data to fetch.
     */
    where: Form16DataWhereUniqueInput
  }

  /**
   * Form16Data findFirst
   */
  export type Form16DataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * Filter, which Form16Data to fetch.
     */
    where?: Form16DataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Form16Data to fetch.
     */
    orderBy?: Form16DataOrderByWithRelationInput | Form16DataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Form16Data.
     */
    cursor?: Form16DataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Form16Data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Form16Data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Form16Data.
     */
    distinct?: Form16DataScalarFieldEnum | Form16DataScalarFieldEnum[]
  }

  /**
   * Form16Data findFirstOrThrow
   */
  export type Form16DataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * Filter, which Form16Data to fetch.
     */
    where?: Form16DataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Form16Data to fetch.
     */
    orderBy?: Form16DataOrderByWithRelationInput | Form16DataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Form16Data.
     */
    cursor?: Form16DataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Form16Data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Form16Data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Form16Data.
     */
    distinct?: Form16DataScalarFieldEnum | Form16DataScalarFieldEnum[]
  }

  /**
   * Form16Data findMany
   */
  export type Form16DataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * Filter, which Form16Data to fetch.
     */
    where?: Form16DataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Form16Data to fetch.
     */
    orderBy?: Form16DataOrderByWithRelationInput | Form16DataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Form16Data.
     */
    cursor?: Form16DataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Form16Data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Form16Data.
     */
    skip?: number
    distinct?: Form16DataScalarFieldEnum | Form16DataScalarFieldEnum[]
  }

  /**
   * Form16Data create
   */
  export type Form16DataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * The data needed to create a Form16Data.
     */
    data: XOR<Form16DataCreateInput, Form16DataUncheckedCreateInput>
  }

  /**
   * Form16Data createMany
   */
  export type Form16DataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Form16Data.
     */
    data: Form16DataCreateManyInput | Form16DataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Form16Data createManyAndReturn
   */
  export type Form16DataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * The data used to create many Form16Data.
     */
    data: Form16DataCreateManyInput | Form16DataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form16Data update
   */
  export type Form16DataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * The data needed to update a Form16Data.
     */
    data: XOR<Form16DataUpdateInput, Form16DataUncheckedUpdateInput>
    /**
     * Choose, which Form16Data to update.
     */
    where: Form16DataWhereUniqueInput
  }

  /**
   * Form16Data updateMany
   */
  export type Form16DataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Form16Data.
     */
    data: XOR<Form16DataUpdateManyMutationInput, Form16DataUncheckedUpdateManyInput>
    /**
     * Filter which Form16Data to update
     */
    where?: Form16DataWhereInput
    /**
     * Limit how many Form16Data to update.
     */
    limit?: number
  }

  /**
   * Form16Data updateManyAndReturn
   */
  export type Form16DataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * The data used to update Form16Data.
     */
    data: XOR<Form16DataUpdateManyMutationInput, Form16DataUncheckedUpdateManyInput>
    /**
     * Filter which Form16Data to update
     */
    where?: Form16DataWhereInput
    /**
     * Limit how many Form16Data to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Form16Data upsert
   */
  export type Form16DataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * The filter to search for the Form16Data to update in case it exists.
     */
    where: Form16DataWhereUniqueInput
    /**
     * In case the Form16Data found by the `where` argument doesn't exist, create a new Form16Data with this data.
     */
    create: XOR<Form16DataCreateInput, Form16DataUncheckedCreateInput>
    /**
     * In case the Form16Data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Form16DataUpdateInput, Form16DataUncheckedUpdateInput>
  }

  /**
   * Form16Data delete
   */
  export type Form16DataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
    /**
     * Filter which Form16Data to delete.
     */
    where: Form16DataWhereUniqueInput
  }

  /**
   * Form16Data deleteMany
   */
  export type Form16DataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Form16Data to delete
     */
    where?: Form16DataWhereInput
    /**
     * Limit how many Form16Data to delete.
     */
    limit?: number
  }

  /**
   * Form16Data without action
   */
  export type Form16DataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Form16Data
     */
    select?: Form16DataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Form16Data
     */
    omit?: Form16DataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Form16DataInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    netTaxableIncome: Decimal | null
  }

  export type PropertySumAggregateOutputType = {
    netTaxableIncome: Decimal | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyIndex: string | null
    propertyType: string | null
    netTaxableIncome: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyIndex: string | null
    propertyType: string | null
    netTaxableIncome: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    userId: number
    propertyIndex: number
    propertyType: number
    netTaxableIncome: number
    houseAddress: number
    ownerDetails: number
    taxSavings: number
    rentalIncomeDetails: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    netTaxableIncome?: true
  }

  export type PropertySumAggregateInputType = {
    netTaxableIncome?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    userId?: true
    propertyIndex?: true
    propertyType?: true
    netTaxableIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    userId?: true
    propertyIndex?: true
    propertyType?: true
    netTaxableIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    userId?: true
    propertyIndex?: true
    propertyType?: true
    netTaxableIncome?: true
    houseAddress?: true
    ownerDetails?: true
    taxSavings?: true
    rentalIncomeDetails?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    userId: string
    propertyIndex: string | null
    propertyType: string | null
    netTaxableIncome: Decimal | null
    houseAddress: JsonValue | null
    ownerDetails: JsonValue | null
    taxSavings: JsonValue | null
    rentalIncomeDetails: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyIndex?: boolean
    propertyType?: boolean
    netTaxableIncome?: boolean
    houseAddress?: boolean
    ownerDetails?: boolean
    taxSavings?: boolean
    rentalIncomeDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyIndex?: boolean
    propertyType?: boolean
    netTaxableIncome?: boolean
    houseAddress?: boolean
    ownerDetails?: boolean
    taxSavings?: boolean
    rentalIncomeDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyIndex?: boolean
    propertyType?: boolean
    netTaxableIncome?: boolean
    houseAddress?: boolean
    ownerDetails?: boolean
    taxSavings?: boolean
    rentalIncomeDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    userId?: boolean
    propertyIndex?: boolean
    propertyType?: boolean
    netTaxableIncome?: boolean
    houseAddress?: boolean
    ownerDetails?: boolean
    taxSavings?: boolean
    rentalIncomeDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "propertyIndex" | "propertyType" | "netTaxableIncome" | "houseAddress" | "ownerDetails" | "taxSavings" | "rentalIncomeDetails" | "createdAt" | "updatedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      propertyIndex: string | null
      propertyType: string | null
      netTaxableIncome: Prisma.Decimal | null
      houseAddress: Prisma.JsonValue | null
      ownerDetails: Prisma.JsonValue | null
      taxSavings: Prisma.JsonValue | null
      rentalIncomeDetails: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly userId: FieldRef<"Property", 'String'>
    readonly propertyIndex: FieldRef<"Property", 'String'>
    readonly propertyType: FieldRef<"Property", 'String'>
    readonly netTaxableIncome: FieldRef<"Property", 'Decimal'>
    readonly houseAddress: FieldRef<"Property", 'Json'>
    readonly ownerDetails: FieldRef<"Property", 'Json'>
    readonly taxSavings: FieldRef<"Property", 'Json'>
    readonly rentalIncomeDetails: FieldRef<"Property", 'Json'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model CapitalGain
   */

  export type AggregateCapitalGain = {
    _count: CapitalGainCountAggregateOutputType | null
    _avg: CapitalGainAvgAggregateOutputType | null
    _sum: CapitalGainSumAggregateOutputType | null
    _min: CapitalGainMinAggregateOutputType | null
    _max: CapitalGainMaxAggregateOutputType | null
  }

  export type CapitalGainAvgAggregateOutputType = {
    salePrice: Decimal | null
    transferExpenses: Decimal | null
    purchasePrice: Decimal | null
    totalProfit: Decimal | null
    indexationCost: Decimal | null
  }

  export type CapitalGainSumAggregateOutputType = {
    salePrice: Decimal | null
    transferExpenses: Decimal | null
    purchasePrice: Decimal | null
    totalProfit: Decimal | null
    indexationCost: Decimal | null
  }

  export type CapitalGainMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assetType: string | null
    assetSubType: string | null
    dateOfSale: Date | null
    dateOfPurchase: Date | null
    description: string | null
    salePrice: Decimal | null
    transferExpenses: Decimal | null
    purchasePrice: Decimal | null
    sttPaid: boolean | null
    totalProfit: Decimal | null
    indexationCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapitalGainMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assetType: string | null
    assetSubType: string | null
    dateOfSale: Date | null
    dateOfPurchase: Date | null
    description: string | null
    salePrice: Decimal | null
    transferExpenses: Decimal | null
    purchasePrice: Decimal | null
    sttPaid: boolean | null
    totalProfit: Decimal | null
    indexationCost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CapitalGainCountAggregateOutputType = {
    id: number
    userId: number
    assetType: number
    assetSubType: number
    dateOfSale: number
    dateOfPurchase: number
    description: number
    salePrice: number
    transferExpenses: number
    purchasePrice: number
    sttPaid: number
    totalProfit: number
    indexationCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CapitalGainAvgAggregateInputType = {
    salePrice?: true
    transferExpenses?: true
    purchasePrice?: true
    totalProfit?: true
    indexationCost?: true
  }

  export type CapitalGainSumAggregateInputType = {
    salePrice?: true
    transferExpenses?: true
    purchasePrice?: true
    totalProfit?: true
    indexationCost?: true
  }

  export type CapitalGainMinAggregateInputType = {
    id?: true
    userId?: true
    assetType?: true
    assetSubType?: true
    dateOfSale?: true
    dateOfPurchase?: true
    description?: true
    salePrice?: true
    transferExpenses?: true
    purchasePrice?: true
    sttPaid?: true
    totalProfit?: true
    indexationCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapitalGainMaxAggregateInputType = {
    id?: true
    userId?: true
    assetType?: true
    assetSubType?: true
    dateOfSale?: true
    dateOfPurchase?: true
    description?: true
    salePrice?: true
    transferExpenses?: true
    purchasePrice?: true
    sttPaid?: true
    totalProfit?: true
    indexationCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CapitalGainCountAggregateInputType = {
    id?: true
    userId?: true
    assetType?: true
    assetSubType?: true
    dateOfSale?: true
    dateOfPurchase?: true
    description?: true
    salePrice?: true
    transferExpenses?: true
    purchasePrice?: true
    sttPaid?: true
    totalProfit?: true
    indexationCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CapitalGainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapitalGain to aggregate.
     */
    where?: CapitalGainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapitalGains to fetch.
     */
    orderBy?: CapitalGainOrderByWithRelationInput | CapitalGainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapitalGainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapitalGains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapitalGains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapitalGains
    **/
    _count?: true | CapitalGainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapitalGainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapitalGainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapitalGainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapitalGainMaxAggregateInputType
  }

  export type GetCapitalGainAggregateType<T extends CapitalGainAggregateArgs> = {
        [P in keyof T & keyof AggregateCapitalGain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapitalGain[P]>
      : GetScalarType<T[P], AggregateCapitalGain[P]>
  }




  export type CapitalGainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapitalGainWhereInput
    orderBy?: CapitalGainOrderByWithAggregationInput | CapitalGainOrderByWithAggregationInput[]
    by: CapitalGainScalarFieldEnum[] | CapitalGainScalarFieldEnum
    having?: CapitalGainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapitalGainCountAggregateInputType | true
    _avg?: CapitalGainAvgAggregateInputType
    _sum?: CapitalGainSumAggregateInputType
    _min?: CapitalGainMinAggregateInputType
    _max?: CapitalGainMaxAggregateInputType
  }

  export type CapitalGainGroupByOutputType = {
    id: string
    userId: string
    assetType: string | null
    assetSubType: string | null
    dateOfSale: Date | null
    dateOfPurchase: Date | null
    description: string | null
    salePrice: Decimal | null
    transferExpenses: Decimal | null
    purchasePrice: Decimal | null
    sttPaid: boolean
    totalProfit: Decimal | null
    indexationCost: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CapitalGainCountAggregateOutputType | null
    _avg: CapitalGainAvgAggregateOutputType | null
    _sum: CapitalGainSumAggregateOutputType | null
    _min: CapitalGainMinAggregateOutputType | null
    _max: CapitalGainMaxAggregateOutputType | null
  }

  type GetCapitalGainGroupByPayload<T extends CapitalGainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapitalGainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapitalGainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapitalGainGroupByOutputType[P]>
            : GetScalarType<T[P], CapitalGainGroupByOutputType[P]>
        }
      >
    >


  export type CapitalGainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assetType?: boolean
    assetSubType?: boolean
    dateOfSale?: boolean
    dateOfPurchase?: boolean
    description?: boolean
    salePrice?: boolean
    transferExpenses?: boolean
    purchasePrice?: boolean
    sttPaid?: boolean
    totalProfit?: boolean
    indexationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capitalGain"]>

  export type CapitalGainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assetType?: boolean
    assetSubType?: boolean
    dateOfSale?: boolean
    dateOfPurchase?: boolean
    description?: boolean
    salePrice?: boolean
    transferExpenses?: boolean
    purchasePrice?: boolean
    sttPaid?: boolean
    totalProfit?: boolean
    indexationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capitalGain"]>

  export type CapitalGainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assetType?: boolean
    assetSubType?: boolean
    dateOfSale?: boolean
    dateOfPurchase?: boolean
    description?: boolean
    salePrice?: boolean
    transferExpenses?: boolean
    purchasePrice?: boolean
    sttPaid?: boolean
    totalProfit?: boolean
    indexationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capitalGain"]>

  export type CapitalGainSelectScalar = {
    id?: boolean
    userId?: boolean
    assetType?: boolean
    assetSubType?: boolean
    dateOfSale?: boolean
    dateOfPurchase?: boolean
    description?: boolean
    salePrice?: boolean
    transferExpenses?: boolean
    purchasePrice?: boolean
    sttPaid?: boolean
    totalProfit?: boolean
    indexationCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CapitalGainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assetType" | "assetSubType" | "dateOfSale" | "dateOfPurchase" | "description" | "salePrice" | "transferExpenses" | "purchasePrice" | "sttPaid" | "totalProfit" | "indexationCost" | "createdAt" | "updatedAt", ExtArgs["result"]["capitalGain"]>
  export type CapitalGainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CapitalGainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CapitalGainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CapitalGainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapitalGain"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assetType: string | null
      assetSubType: string | null
      dateOfSale: Date | null
      dateOfPurchase: Date | null
      description: string | null
      salePrice: Prisma.Decimal | null
      transferExpenses: Prisma.Decimal | null
      purchasePrice: Prisma.Decimal | null
      sttPaid: boolean
      totalProfit: Prisma.Decimal | null
      indexationCost: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["capitalGain"]>
    composites: {}
  }

  type CapitalGainGetPayload<S extends boolean | null | undefined | CapitalGainDefaultArgs> = $Result.GetResult<Prisma.$CapitalGainPayload, S>

  type CapitalGainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapitalGainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapitalGainCountAggregateInputType | true
    }

  export interface CapitalGainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapitalGain'], meta: { name: 'CapitalGain' } }
    /**
     * Find zero or one CapitalGain that matches the filter.
     * @param {CapitalGainFindUniqueArgs} args - Arguments to find a CapitalGain
     * @example
     * // Get one CapitalGain
     * const capitalGain = await prisma.capitalGain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapitalGainFindUniqueArgs>(args: SelectSubset<T, CapitalGainFindUniqueArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CapitalGain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapitalGainFindUniqueOrThrowArgs} args - Arguments to find a CapitalGain
     * @example
     * // Get one CapitalGain
     * const capitalGain = await prisma.capitalGain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapitalGainFindUniqueOrThrowArgs>(args: SelectSubset<T, CapitalGainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapitalGain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainFindFirstArgs} args - Arguments to find a CapitalGain
     * @example
     * // Get one CapitalGain
     * const capitalGain = await prisma.capitalGain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapitalGainFindFirstArgs>(args?: SelectSubset<T, CapitalGainFindFirstArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapitalGain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainFindFirstOrThrowArgs} args - Arguments to find a CapitalGain
     * @example
     * // Get one CapitalGain
     * const capitalGain = await prisma.capitalGain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapitalGainFindFirstOrThrowArgs>(args?: SelectSubset<T, CapitalGainFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapitalGains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapitalGains
     * const capitalGains = await prisma.capitalGain.findMany()
     * 
     * // Get first 10 CapitalGains
     * const capitalGains = await prisma.capitalGain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capitalGainWithIdOnly = await prisma.capitalGain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapitalGainFindManyArgs>(args?: SelectSubset<T, CapitalGainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CapitalGain.
     * @param {CapitalGainCreateArgs} args - Arguments to create a CapitalGain.
     * @example
     * // Create one CapitalGain
     * const CapitalGain = await prisma.capitalGain.create({
     *   data: {
     *     // ... data to create a CapitalGain
     *   }
     * })
     * 
     */
    create<T extends CapitalGainCreateArgs>(args: SelectSubset<T, CapitalGainCreateArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CapitalGains.
     * @param {CapitalGainCreateManyArgs} args - Arguments to create many CapitalGains.
     * @example
     * // Create many CapitalGains
     * const capitalGain = await prisma.capitalGain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapitalGainCreateManyArgs>(args?: SelectSubset<T, CapitalGainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CapitalGains and returns the data saved in the database.
     * @param {CapitalGainCreateManyAndReturnArgs} args - Arguments to create many CapitalGains.
     * @example
     * // Create many CapitalGains
     * const capitalGain = await prisma.capitalGain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CapitalGains and only return the `id`
     * const capitalGainWithIdOnly = await prisma.capitalGain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapitalGainCreateManyAndReturnArgs>(args?: SelectSubset<T, CapitalGainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CapitalGain.
     * @param {CapitalGainDeleteArgs} args - Arguments to delete one CapitalGain.
     * @example
     * // Delete one CapitalGain
     * const CapitalGain = await prisma.capitalGain.delete({
     *   where: {
     *     // ... filter to delete one CapitalGain
     *   }
     * })
     * 
     */
    delete<T extends CapitalGainDeleteArgs>(args: SelectSubset<T, CapitalGainDeleteArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CapitalGain.
     * @param {CapitalGainUpdateArgs} args - Arguments to update one CapitalGain.
     * @example
     * // Update one CapitalGain
     * const capitalGain = await prisma.capitalGain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapitalGainUpdateArgs>(args: SelectSubset<T, CapitalGainUpdateArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CapitalGains.
     * @param {CapitalGainDeleteManyArgs} args - Arguments to filter CapitalGains to delete.
     * @example
     * // Delete a few CapitalGains
     * const { count } = await prisma.capitalGain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapitalGainDeleteManyArgs>(args?: SelectSubset<T, CapitalGainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapitalGains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapitalGains
     * const capitalGain = await prisma.capitalGain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapitalGainUpdateManyArgs>(args: SelectSubset<T, CapitalGainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapitalGains and returns the data updated in the database.
     * @param {CapitalGainUpdateManyAndReturnArgs} args - Arguments to update many CapitalGains.
     * @example
     * // Update many CapitalGains
     * const capitalGain = await prisma.capitalGain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CapitalGains and only return the `id`
     * const capitalGainWithIdOnly = await prisma.capitalGain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CapitalGainUpdateManyAndReturnArgs>(args: SelectSubset<T, CapitalGainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CapitalGain.
     * @param {CapitalGainUpsertArgs} args - Arguments to update or create a CapitalGain.
     * @example
     * // Update or create a CapitalGain
     * const capitalGain = await prisma.capitalGain.upsert({
     *   create: {
     *     // ... data to create a CapitalGain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapitalGain we want to update
     *   }
     * })
     */
    upsert<T extends CapitalGainUpsertArgs>(args: SelectSubset<T, CapitalGainUpsertArgs<ExtArgs>>): Prisma__CapitalGainClient<$Result.GetResult<Prisma.$CapitalGainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CapitalGains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainCountArgs} args - Arguments to filter CapitalGains to count.
     * @example
     * // Count the number of CapitalGains
     * const count = await prisma.capitalGain.count({
     *   where: {
     *     // ... the filter for the CapitalGains we want to count
     *   }
     * })
    **/
    count<T extends CapitalGainCountArgs>(
      args?: Subset<T, CapitalGainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapitalGainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapitalGain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapitalGainAggregateArgs>(args: Subset<T, CapitalGainAggregateArgs>): Prisma.PrismaPromise<GetCapitalGainAggregateType<T>>

    /**
     * Group by CapitalGain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitalGainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapitalGainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapitalGainGroupByArgs['orderBy'] }
        : { orderBy?: CapitalGainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapitalGainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapitalGainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapitalGain model
   */
  readonly fields: CapitalGainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapitalGain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapitalGainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapitalGain model
   */
  interface CapitalGainFieldRefs {
    readonly id: FieldRef<"CapitalGain", 'String'>
    readonly userId: FieldRef<"CapitalGain", 'String'>
    readonly assetType: FieldRef<"CapitalGain", 'String'>
    readonly assetSubType: FieldRef<"CapitalGain", 'String'>
    readonly dateOfSale: FieldRef<"CapitalGain", 'DateTime'>
    readonly dateOfPurchase: FieldRef<"CapitalGain", 'DateTime'>
    readonly description: FieldRef<"CapitalGain", 'String'>
    readonly salePrice: FieldRef<"CapitalGain", 'Decimal'>
    readonly transferExpenses: FieldRef<"CapitalGain", 'Decimal'>
    readonly purchasePrice: FieldRef<"CapitalGain", 'Decimal'>
    readonly sttPaid: FieldRef<"CapitalGain", 'Boolean'>
    readonly totalProfit: FieldRef<"CapitalGain", 'Decimal'>
    readonly indexationCost: FieldRef<"CapitalGain", 'Decimal'>
    readonly createdAt: FieldRef<"CapitalGain", 'DateTime'>
    readonly updatedAt: FieldRef<"CapitalGain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CapitalGain findUnique
   */
  export type CapitalGainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * Filter, which CapitalGain to fetch.
     */
    where: CapitalGainWhereUniqueInput
  }

  /**
   * CapitalGain findUniqueOrThrow
   */
  export type CapitalGainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * Filter, which CapitalGain to fetch.
     */
    where: CapitalGainWhereUniqueInput
  }

  /**
   * CapitalGain findFirst
   */
  export type CapitalGainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * Filter, which CapitalGain to fetch.
     */
    where?: CapitalGainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapitalGains to fetch.
     */
    orderBy?: CapitalGainOrderByWithRelationInput | CapitalGainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapitalGains.
     */
    cursor?: CapitalGainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapitalGains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapitalGains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapitalGains.
     */
    distinct?: CapitalGainScalarFieldEnum | CapitalGainScalarFieldEnum[]
  }

  /**
   * CapitalGain findFirstOrThrow
   */
  export type CapitalGainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * Filter, which CapitalGain to fetch.
     */
    where?: CapitalGainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapitalGains to fetch.
     */
    orderBy?: CapitalGainOrderByWithRelationInput | CapitalGainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapitalGains.
     */
    cursor?: CapitalGainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapitalGains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapitalGains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapitalGains.
     */
    distinct?: CapitalGainScalarFieldEnum | CapitalGainScalarFieldEnum[]
  }

  /**
   * CapitalGain findMany
   */
  export type CapitalGainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * Filter, which CapitalGains to fetch.
     */
    where?: CapitalGainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapitalGains to fetch.
     */
    orderBy?: CapitalGainOrderByWithRelationInput | CapitalGainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapitalGains.
     */
    cursor?: CapitalGainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CapitalGains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapitalGains.
     */
    skip?: number
    distinct?: CapitalGainScalarFieldEnum | CapitalGainScalarFieldEnum[]
  }

  /**
   * CapitalGain create
   */
  export type CapitalGainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * The data needed to create a CapitalGain.
     */
    data: XOR<CapitalGainCreateInput, CapitalGainUncheckedCreateInput>
  }

  /**
   * CapitalGain createMany
   */
  export type CapitalGainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapitalGains.
     */
    data: CapitalGainCreateManyInput | CapitalGainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapitalGain createManyAndReturn
   */
  export type CapitalGainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * The data used to create many CapitalGains.
     */
    data: CapitalGainCreateManyInput | CapitalGainCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapitalGain update
   */
  export type CapitalGainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * The data needed to update a CapitalGain.
     */
    data: XOR<CapitalGainUpdateInput, CapitalGainUncheckedUpdateInput>
    /**
     * Choose, which CapitalGain to update.
     */
    where: CapitalGainWhereUniqueInput
  }

  /**
   * CapitalGain updateMany
   */
  export type CapitalGainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapitalGains.
     */
    data: XOR<CapitalGainUpdateManyMutationInput, CapitalGainUncheckedUpdateManyInput>
    /**
     * Filter which CapitalGains to update
     */
    where?: CapitalGainWhereInput
    /**
     * Limit how many CapitalGains to update.
     */
    limit?: number
  }

  /**
   * CapitalGain updateManyAndReturn
   */
  export type CapitalGainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * The data used to update CapitalGains.
     */
    data: XOR<CapitalGainUpdateManyMutationInput, CapitalGainUncheckedUpdateManyInput>
    /**
     * Filter which CapitalGains to update
     */
    where?: CapitalGainWhereInput
    /**
     * Limit how many CapitalGains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CapitalGain upsert
   */
  export type CapitalGainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * The filter to search for the CapitalGain to update in case it exists.
     */
    where: CapitalGainWhereUniqueInput
    /**
     * In case the CapitalGain found by the `where` argument doesn't exist, create a new CapitalGain with this data.
     */
    create: XOR<CapitalGainCreateInput, CapitalGainUncheckedCreateInput>
    /**
     * In case the CapitalGain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapitalGainUpdateInput, CapitalGainUncheckedUpdateInput>
  }

  /**
   * CapitalGain delete
   */
  export type CapitalGainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
    /**
     * Filter which CapitalGain to delete.
     */
    where: CapitalGainWhereUniqueInput
  }

  /**
   * CapitalGain deleteMany
   */
  export type CapitalGainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapitalGains to delete
     */
    where?: CapitalGainWhereInput
    /**
     * Limit how many CapitalGains to delete.
     */
    limit?: number
  }

  /**
   * CapitalGain without action
   */
  export type CapitalGainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitalGain
     */
    select?: CapitalGainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapitalGain
     */
    omit?: CapitalGainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CapitalGainInclude<ExtArgs> | null
  }


  /**
   * Model InterestIncome
   */

  export type AggregateInterestIncome = {
    _count: InterestIncomeCountAggregateOutputType | null
    _avg: InterestIncomeAvgAggregateOutputType | null
    _sum: InterestIncomeSumAggregateOutputType | null
    _min: InterestIncomeMinAggregateOutputType | null
    _max: InterestIncomeMaxAggregateOutputType | null
  }

  export type InterestIncomeAvgAggregateOutputType = {
    interestAmount: Decimal | null
    tdsDeducted: Decimal | null
  }

  export type InterestIncomeSumAggregateOutputType = {
    interestAmount: Decimal | null
    tdsDeducted: Decimal | null
  }

  export type InterestIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sourceType: string | null
    bankName: string | null
    accountNumber: string | null
    interestAmount: Decimal | null
    tdsDeducted: Decimal | null
    financialYear: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterestIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sourceType: string | null
    bankName: string | null
    accountNumber: string | null
    interestAmount: Decimal | null
    tdsDeducted: Decimal | null
    financialYear: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterestIncomeCountAggregateOutputType = {
    id: number
    userId: number
    sourceType: number
    bankName: number
    accountNumber: number
    interestAmount: number
    tdsDeducted: number
    financialYear: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterestIncomeAvgAggregateInputType = {
    interestAmount?: true
    tdsDeducted?: true
  }

  export type InterestIncomeSumAggregateInputType = {
    interestAmount?: true
    tdsDeducted?: true
  }

  export type InterestIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    sourceType?: true
    bankName?: true
    accountNumber?: true
    interestAmount?: true
    tdsDeducted?: true
    financialYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterestIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    sourceType?: true
    bankName?: true
    accountNumber?: true
    interestAmount?: true
    tdsDeducted?: true
    financialYear?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterestIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    sourceType?: true
    bankName?: true
    accountNumber?: true
    interestAmount?: true
    tdsDeducted?: true
    financialYear?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterestIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestIncome to aggregate.
     */
    where?: InterestIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestIncomes to fetch.
     */
    orderBy?: InterestIncomeOrderByWithRelationInput | InterestIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestIncomes
    **/
    _count?: true | InterestIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestIncomeMaxAggregateInputType
  }

  export type GetInterestIncomeAggregateType<T extends InterestIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestIncome[P]>
      : GetScalarType<T[P], AggregateInterestIncome[P]>
  }




  export type InterestIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestIncomeWhereInput
    orderBy?: InterestIncomeOrderByWithAggregationInput | InterestIncomeOrderByWithAggregationInput[]
    by: InterestIncomeScalarFieldEnum[] | InterestIncomeScalarFieldEnum
    having?: InterestIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestIncomeCountAggregateInputType | true
    _avg?: InterestIncomeAvgAggregateInputType
    _sum?: InterestIncomeSumAggregateInputType
    _min?: InterestIncomeMinAggregateInputType
    _max?: InterestIncomeMaxAggregateInputType
  }

  export type InterestIncomeGroupByOutputType = {
    id: string
    userId: string
    sourceType: string | null
    bankName: string | null
    accountNumber: string | null
    interestAmount: Decimal | null
    tdsDeducted: Decimal | null
    financialYear: string | null
    createdAt: Date
    updatedAt: Date
    _count: InterestIncomeCountAggregateOutputType | null
    _avg: InterestIncomeAvgAggregateOutputType | null
    _sum: InterestIncomeSumAggregateOutputType | null
    _min: InterestIncomeMinAggregateOutputType | null
    _max: InterestIncomeMaxAggregateOutputType | null
  }

  type GetInterestIncomeGroupByPayload<T extends InterestIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], InterestIncomeGroupByOutputType[P]>
        }
      >
    >


  export type InterestIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sourceType?: boolean
    bankName?: boolean
    accountNumber?: boolean
    interestAmount?: boolean
    tdsDeducted?: boolean
    financialYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestIncome"]>

  export type InterestIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sourceType?: boolean
    bankName?: boolean
    accountNumber?: boolean
    interestAmount?: boolean
    tdsDeducted?: boolean
    financialYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestIncome"]>

  export type InterestIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sourceType?: boolean
    bankName?: boolean
    accountNumber?: boolean
    interestAmount?: boolean
    tdsDeducted?: boolean
    financialYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestIncome"]>

  export type InterestIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    sourceType?: boolean
    bankName?: boolean
    accountNumber?: boolean
    interestAmount?: boolean
    tdsDeducted?: boolean
    financialYear?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterestIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sourceType" | "bankName" | "accountNumber" | "interestAmount" | "tdsDeducted" | "financialYear" | "createdAt" | "updatedAt", ExtArgs["result"]["interestIncome"]>
  export type InterestIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterestIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterestIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterestIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sourceType: string | null
      bankName: string | null
      accountNumber: string | null
      interestAmount: Prisma.Decimal | null
      tdsDeducted: Prisma.Decimal | null
      financialYear: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interestIncome"]>
    composites: {}
  }

  type InterestIncomeGetPayload<S extends boolean | null | undefined | InterestIncomeDefaultArgs> = $Result.GetResult<Prisma.$InterestIncomePayload, S>

  type InterestIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestIncomeCountAggregateInputType | true
    }

  export interface InterestIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestIncome'], meta: { name: 'InterestIncome' } }
    /**
     * Find zero or one InterestIncome that matches the filter.
     * @param {InterestIncomeFindUniqueArgs} args - Arguments to find a InterestIncome
     * @example
     * // Get one InterestIncome
     * const interestIncome = await prisma.interestIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestIncomeFindUniqueArgs>(args: SelectSubset<T, InterestIncomeFindUniqueArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestIncomeFindUniqueOrThrowArgs} args - Arguments to find a InterestIncome
     * @example
     * // Get one InterestIncome
     * const interestIncome = await prisma.interestIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeFindFirstArgs} args - Arguments to find a InterestIncome
     * @example
     * // Get one InterestIncome
     * const interestIncome = await prisma.interestIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestIncomeFindFirstArgs>(args?: SelectSubset<T, InterestIncomeFindFirstArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeFindFirstOrThrowArgs} args - Arguments to find a InterestIncome
     * @example
     * // Get one InterestIncome
     * const interestIncome = await prisma.interestIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestIncomes
     * const interestIncomes = await prisma.interestIncome.findMany()
     * 
     * // Get first 10 InterestIncomes
     * const interestIncomes = await prisma.interestIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestIncomeWithIdOnly = await prisma.interestIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestIncomeFindManyArgs>(args?: SelectSubset<T, InterestIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestIncome.
     * @param {InterestIncomeCreateArgs} args - Arguments to create a InterestIncome.
     * @example
     * // Create one InterestIncome
     * const InterestIncome = await prisma.interestIncome.create({
     *   data: {
     *     // ... data to create a InterestIncome
     *   }
     * })
     * 
     */
    create<T extends InterestIncomeCreateArgs>(args: SelectSubset<T, InterestIncomeCreateArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestIncomes.
     * @param {InterestIncomeCreateManyArgs} args - Arguments to create many InterestIncomes.
     * @example
     * // Create many InterestIncomes
     * const interestIncome = await prisma.interestIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestIncomeCreateManyArgs>(args?: SelectSubset<T, InterestIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestIncomes and returns the data saved in the database.
     * @param {InterestIncomeCreateManyAndReturnArgs} args - Arguments to create many InterestIncomes.
     * @example
     * // Create many InterestIncomes
     * const interestIncome = await prisma.interestIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestIncomes and only return the `id`
     * const interestIncomeWithIdOnly = await prisma.interestIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestIncome.
     * @param {InterestIncomeDeleteArgs} args - Arguments to delete one InterestIncome.
     * @example
     * // Delete one InterestIncome
     * const InterestIncome = await prisma.interestIncome.delete({
     *   where: {
     *     // ... filter to delete one InterestIncome
     *   }
     * })
     * 
     */
    delete<T extends InterestIncomeDeleteArgs>(args: SelectSubset<T, InterestIncomeDeleteArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestIncome.
     * @param {InterestIncomeUpdateArgs} args - Arguments to update one InterestIncome.
     * @example
     * // Update one InterestIncome
     * const interestIncome = await prisma.interestIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestIncomeUpdateArgs>(args: SelectSubset<T, InterestIncomeUpdateArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestIncomes.
     * @param {InterestIncomeDeleteManyArgs} args - Arguments to filter InterestIncomes to delete.
     * @example
     * // Delete a few InterestIncomes
     * const { count } = await prisma.interestIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestIncomeDeleteManyArgs>(args?: SelectSubset<T, InterestIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestIncomes
     * const interestIncome = await prisma.interestIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestIncomeUpdateManyArgs>(args: SelectSubset<T, InterestIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestIncomes and returns the data updated in the database.
     * @param {InterestIncomeUpdateManyAndReturnArgs} args - Arguments to update many InterestIncomes.
     * @example
     * // Update many InterestIncomes
     * const interestIncome = await prisma.interestIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestIncomes and only return the `id`
     * const interestIncomeWithIdOnly = await prisma.interestIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestIncome.
     * @param {InterestIncomeUpsertArgs} args - Arguments to update or create a InterestIncome.
     * @example
     * // Update or create a InterestIncome
     * const interestIncome = await prisma.interestIncome.upsert({
     *   create: {
     *     // ... data to create a InterestIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestIncome we want to update
     *   }
     * })
     */
    upsert<T extends InterestIncomeUpsertArgs>(args: SelectSubset<T, InterestIncomeUpsertArgs<ExtArgs>>): Prisma__InterestIncomeClient<$Result.GetResult<Prisma.$InterestIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeCountArgs} args - Arguments to filter InterestIncomes to count.
     * @example
     * // Count the number of InterestIncomes
     * const count = await prisma.interestIncome.count({
     *   where: {
     *     // ... the filter for the InterestIncomes we want to count
     *   }
     * })
    **/
    count<T extends InterestIncomeCountArgs>(
      args?: Subset<T, InterestIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestIncomeAggregateArgs>(args: Subset<T, InterestIncomeAggregateArgs>): Prisma.PrismaPromise<GetInterestIncomeAggregateType<T>>

    /**
     * Group by InterestIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestIncomeGroupByArgs['orderBy'] }
        : { orderBy?: InterestIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestIncome model
   */
  readonly fields: InterestIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestIncome model
   */
  interface InterestIncomeFieldRefs {
    readonly id: FieldRef<"InterestIncome", 'String'>
    readonly userId: FieldRef<"InterestIncome", 'String'>
    readonly sourceType: FieldRef<"InterestIncome", 'String'>
    readonly bankName: FieldRef<"InterestIncome", 'String'>
    readonly accountNumber: FieldRef<"InterestIncome", 'String'>
    readonly interestAmount: FieldRef<"InterestIncome", 'Decimal'>
    readonly tdsDeducted: FieldRef<"InterestIncome", 'Decimal'>
    readonly financialYear: FieldRef<"InterestIncome", 'String'>
    readonly createdAt: FieldRef<"InterestIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"InterestIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterestIncome findUnique
   */
  export type InterestIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * Filter, which InterestIncome to fetch.
     */
    where: InterestIncomeWhereUniqueInput
  }

  /**
   * InterestIncome findUniqueOrThrow
   */
  export type InterestIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * Filter, which InterestIncome to fetch.
     */
    where: InterestIncomeWhereUniqueInput
  }

  /**
   * InterestIncome findFirst
   */
  export type InterestIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * Filter, which InterestIncome to fetch.
     */
    where?: InterestIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestIncomes to fetch.
     */
    orderBy?: InterestIncomeOrderByWithRelationInput | InterestIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestIncomes.
     */
    cursor?: InterestIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestIncomes.
     */
    distinct?: InterestIncomeScalarFieldEnum | InterestIncomeScalarFieldEnum[]
  }

  /**
   * InterestIncome findFirstOrThrow
   */
  export type InterestIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * Filter, which InterestIncome to fetch.
     */
    where?: InterestIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestIncomes to fetch.
     */
    orderBy?: InterestIncomeOrderByWithRelationInput | InterestIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestIncomes.
     */
    cursor?: InterestIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestIncomes.
     */
    distinct?: InterestIncomeScalarFieldEnum | InterestIncomeScalarFieldEnum[]
  }

  /**
   * InterestIncome findMany
   */
  export type InterestIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * Filter, which InterestIncomes to fetch.
     */
    where?: InterestIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestIncomes to fetch.
     */
    orderBy?: InterestIncomeOrderByWithRelationInput | InterestIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestIncomes.
     */
    cursor?: InterestIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestIncomes.
     */
    skip?: number
    distinct?: InterestIncomeScalarFieldEnum | InterestIncomeScalarFieldEnum[]
  }

  /**
   * InterestIncome create
   */
  export type InterestIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestIncome.
     */
    data: XOR<InterestIncomeCreateInput, InterestIncomeUncheckedCreateInput>
  }

  /**
   * InterestIncome createMany
   */
  export type InterestIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestIncomes.
     */
    data: InterestIncomeCreateManyInput | InterestIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestIncome createManyAndReturn
   */
  export type InterestIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many InterestIncomes.
     */
    data: InterestIncomeCreateManyInput | InterestIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestIncome update
   */
  export type InterestIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestIncome.
     */
    data: XOR<InterestIncomeUpdateInput, InterestIncomeUncheckedUpdateInput>
    /**
     * Choose, which InterestIncome to update.
     */
    where: InterestIncomeWhereUniqueInput
  }

  /**
   * InterestIncome updateMany
   */
  export type InterestIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestIncomes.
     */
    data: XOR<InterestIncomeUpdateManyMutationInput, InterestIncomeUncheckedUpdateManyInput>
    /**
     * Filter which InterestIncomes to update
     */
    where?: InterestIncomeWhereInput
    /**
     * Limit how many InterestIncomes to update.
     */
    limit?: number
  }

  /**
   * InterestIncome updateManyAndReturn
   */
  export type InterestIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * The data used to update InterestIncomes.
     */
    data: XOR<InterestIncomeUpdateManyMutationInput, InterestIncomeUncheckedUpdateManyInput>
    /**
     * Filter which InterestIncomes to update
     */
    where?: InterestIncomeWhereInput
    /**
     * Limit how many InterestIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestIncome upsert
   */
  export type InterestIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestIncome to update in case it exists.
     */
    where: InterestIncomeWhereUniqueInput
    /**
     * In case the InterestIncome found by the `where` argument doesn't exist, create a new InterestIncome with this data.
     */
    create: XOR<InterestIncomeCreateInput, InterestIncomeUncheckedCreateInput>
    /**
     * In case the InterestIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestIncomeUpdateInput, InterestIncomeUncheckedUpdateInput>
  }

  /**
   * InterestIncome delete
   */
  export type InterestIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
    /**
     * Filter which InterestIncome to delete.
     */
    where: InterestIncomeWhereUniqueInput
  }

  /**
   * InterestIncome deleteMany
   */
  export type InterestIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestIncomes to delete
     */
    where?: InterestIncomeWhereInput
    /**
     * Limit how many InterestIncomes to delete.
     */
    limit?: number
  }

  /**
   * InterestIncome without action
   */
  export type InterestIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestIncome
     */
    select?: InterestIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestIncome
     */
    omit?: InterestIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestIncomeInclude<ExtArgs> | null
  }


  /**
   * Model DividendIncome
   */

  export type AggregateDividendIncome = {
    _count: DividendIncomeCountAggregateOutputType | null
    _avg: DividendIncomeAvgAggregateOutputType | null
    _sum: DividendIncomeSumAggregateOutputType | null
    _min: DividendIncomeMinAggregateOutputType | null
    _max: DividendIncomeMaxAggregateOutputType | null
  }

  export type DividendIncomeAvgAggregateOutputType = {
    dividendAmount: Decimal | null
    taxDeducted: Decimal | null
    shareQuantity: number | null
  }

  export type DividendIncomeSumAggregateOutputType = {
    dividendAmount: Decimal | null
    taxDeducted: Decimal | null
    shareQuantity: number | null
  }

  export type DividendIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    dividendAmount: Decimal | null
    taxDeducted: Decimal | null
    dateReceived: Date | null
    shareQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DividendIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    dividendAmount: Decimal | null
    taxDeducted: Decimal | null
    dateReceived: Date | null
    shareQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DividendIncomeCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    dividendAmount: number
    taxDeducted: number
    dateReceived: number
    shareQuantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DividendIncomeAvgAggregateInputType = {
    dividendAmount?: true
    taxDeducted?: true
    shareQuantity?: true
  }

  export type DividendIncomeSumAggregateInputType = {
    dividendAmount?: true
    taxDeducted?: true
    shareQuantity?: true
  }

  export type DividendIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    dividendAmount?: true
    taxDeducted?: true
    dateReceived?: true
    shareQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DividendIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    dividendAmount?: true
    taxDeducted?: true
    dateReceived?: true
    shareQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DividendIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    dividendAmount?: true
    taxDeducted?: true
    dateReceived?: true
    shareQuantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DividendIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DividendIncome to aggregate.
     */
    where?: DividendIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DividendIncomes to fetch.
     */
    orderBy?: DividendIncomeOrderByWithRelationInput | DividendIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DividendIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DividendIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DividendIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DividendIncomes
    **/
    _count?: true | DividendIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DividendIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DividendIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DividendIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DividendIncomeMaxAggregateInputType
  }

  export type GetDividendIncomeAggregateType<T extends DividendIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateDividendIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDividendIncome[P]>
      : GetScalarType<T[P], AggregateDividendIncome[P]>
  }




  export type DividendIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DividendIncomeWhereInput
    orderBy?: DividendIncomeOrderByWithAggregationInput | DividendIncomeOrderByWithAggregationInput[]
    by: DividendIncomeScalarFieldEnum[] | DividendIncomeScalarFieldEnum
    having?: DividendIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DividendIncomeCountAggregateInputType | true
    _avg?: DividendIncomeAvgAggregateInputType
    _sum?: DividendIncomeSumAggregateInputType
    _min?: DividendIncomeMinAggregateInputType
    _max?: DividendIncomeMaxAggregateInputType
  }

  export type DividendIncomeGroupByOutputType = {
    id: string
    userId: string
    companyName: string | null
    dividendAmount: Decimal | null
    taxDeducted: Decimal | null
    dateReceived: Date | null
    shareQuantity: number | null
    createdAt: Date
    updatedAt: Date
    _count: DividendIncomeCountAggregateOutputType | null
    _avg: DividendIncomeAvgAggregateOutputType | null
    _sum: DividendIncomeSumAggregateOutputType | null
    _min: DividendIncomeMinAggregateOutputType | null
    _max: DividendIncomeMaxAggregateOutputType | null
  }

  type GetDividendIncomeGroupByPayload<T extends DividendIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DividendIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DividendIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DividendIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], DividendIncomeGroupByOutputType[P]>
        }
      >
    >


  export type DividendIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    dividendAmount?: boolean
    taxDeducted?: boolean
    dateReceived?: boolean
    shareQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dividendIncome"]>

  export type DividendIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    dividendAmount?: boolean
    taxDeducted?: boolean
    dateReceived?: boolean
    shareQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dividendIncome"]>

  export type DividendIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    dividendAmount?: boolean
    taxDeducted?: boolean
    dateReceived?: boolean
    shareQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dividendIncome"]>

  export type DividendIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    dividendAmount?: boolean
    taxDeducted?: boolean
    dateReceived?: boolean
    shareQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DividendIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "dividendAmount" | "taxDeducted" | "dateReceived" | "shareQuantity" | "createdAt" | "updatedAt", ExtArgs["result"]["dividendIncome"]>
  export type DividendIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DividendIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DividendIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DividendIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DividendIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string | null
      dividendAmount: Prisma.Decimal | null
      taxDeducted: Prisma.Decimal | null
      dateReceived: Date | null
      shareQuantity: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dividendIncome"]>
    composites: {}
  }

  type DividendIncomeGetPayload<S extends boolean | null | undefined | DividendIncomeDefaultArgs> = $Result.GetResult<Prisma.$DividendIncomePayload, S>

  type DividendIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DividendIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DividendIncomeCountAggregateInputType | true
    }

  export interface DividendIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DividendIncome'], meta: { name: 'DividendIncome' } }
    /**
     * Find zero or one DividendIncome that matches the filter.
     * @param {DividendIncomeFindUniqueArgs} args - Arguments to find a DividendIncome
     * @example
     * // Get one DividendIncome
     * const dividendIncome = await prisma.dividendIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DividendIncomeFindUniqueArgs>(args: SelectSubset<T, DividendIncomeFindUniqueArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DividendIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DividendIncomeFindUniqueOrThrowArgs} args - Arguments to find a DividendIncome
     * @example
     * // Get one DividendIncome
     * const dividendIncome = await prisma.dividendIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DividendIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, DividendIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DividendIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeFindFirstArgs} args - Arguments to find a DividendIncome
     * @example
     * // Get one DividendIncome
     * const dividendIncome = await prisma.dividendIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DividendIncomeFindFirstArgs>(args?: SelectSubset<T, DividendIncomeFindFirstArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DividendIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeFindFirstOrThrowArgs} args - Arguments to find a DividendIncome
     * @example
     * // Get one DividendIncome
     * const dividendIncome = await prisma.dividendIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DividendIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, DividendIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DividendIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DividendIncomes
     * const dividendIncomes = await prisma.dividendIncome.findMany()
     * 
     * // Get first 10 DividendIncomes
     * const dividendIncomes = await prisma.dividendIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dividendIncomeWithIdOnly = await prisma.dividendIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DividendIncomeFindManyArgs>(args?: SelectSubset<T, DividendIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DividendIncome.
     * @param {DividendIncomeCreateArgs} args - Arguments to create a DividendIncome.
     * @example
     * // Create one DividendIncome
     * const DividendIncome = await prisma.dividendIncome.create({
     *   data: {
     *     // ... data to create a DividendIncome
     *   }
     * })
     * 
     */
    create<T extends DividendIncomeCreateArgs>(args: SelectSubset<T, DividendIncomeCreateArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DividendIncomes.
     * @param {DividendIncomeCreateManyArgs} args - Arguments to create many DividendIncomes.
     * @example
     * // Create many DividendIncomes
     * const dividendIncome = await prisma.dividendIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DividendIncomeCreateManyArgs>(args?: SelectSubset<T, DividendIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DividendIncomes and returns the data saved in the database.
     * @param {DividendIncomeCreateManyAndReturnArgs} args - Arguments to create many DividendIncomes.
     * @example
     * // Create many DividendIncomes
     * const dividendIncome = await prisma.dividendIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DividendIncomes and only return the `id`
     * const dividendIncomeWithIdOnly = await prisma.dividendIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DividendIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, DividendIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DividendIncome.
     * @param {DividendIncomeDeleteArgs} args - Arguments to delete one DividendIncome.
     * @example
     * // Delete one DividendIncome
     * const DividendIncome = await prisma.dividendIncome.delete({
     *   where: {
     *     // ... filter to delete one DividendIncome
     *   }
     * })
     * 
     */
    delete<T extends DividendIncomeDeleteArgs>(args: SelectSubset<T, DividendIncomeDeleteArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DividendIncome.
     * @param {DividendIncomeUpdateArgs} args - Arguments to update one DividendIncome.
     * @example
     * // Update one DividendIncome
     * const dividendIncome = await prisma.dividendIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DividendIncomeUpdateArgs>(args: SelectSubset<T, DividendIncomeUpdateArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DividendIncomes.
     * @param {DividendIncomeDeleteManyArgs} args - Arguments to filter DividendIncomes to delete.
     * @example
     * // Delete a few DividendIncomes
     * const { count } = await prisma.dividendIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DividendIncomeDeleteManyArgs>(args?: SelectSubset<T, DividendIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DividendIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DividendIncomes
     * const dividendIncome = await prisma.dividendIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DividendIncomeUpdateManyArgs>(args: SelectSubset<T, DividendIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DividendIncomes and returns the data updated in the database.
     * @param {DividendIncomeUpdateManyAndReturnArgs} args - Arguments to update many DividendIncomes.
     * @example
     * // Update many DividendIncomes
     * const dividendIncome = await prisma.dividendIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DividendIncomes and only return the `id`
     * const dividendIncomeWithIdOnly = await prisma.dividendIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DividendIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, DividendIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DividendIncome.
     * @param {DividendIncomeUpsertArgs} args - Arguments to update or create a DividendIncome.
     * @example
     * // Update or create a DividendIncome
     * const dividendIncome = await prisma.dividendIncome.upsert({
     *   create: {
     *     // ... data to create a DividendIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DividendIncome we want to update
     *   }
     * })
     */
    upsert<T extends DividendIncomeUpsertArgs>(args: SelectSubset<T, DividendIncomeUpsertArgs<ExtArgs>>): Prisma__DividendIncomeClient<$Result.GetResult<Prisma.$DividendIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DividendIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeCountArgs} args - Arguments to filter DividendIncomes to count.
     * @example
     * // Count the number of DividendIncomes
     * const count = await prisma.dividendIncome.count({
     *   where: {
     *     // ... the filter for the DividendIncomes we want to count
     *   }
     * })
    **/
    count<T extends DividendIncomeCountArgs>(
      args?: Subset<T, DividendIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DividendIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DividendIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DividendIncomeAggregateArgs>(args: Subset<T, DividendIncomeAggregateArgs>): Prisma.PrismaPromise<GetDividendIncomeAggregateType<T>>

    /**
     * Group by DividendIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DividendIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DividendIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DividendIncomeGroupByArgs['orderBy'] }
        : { orderBy?: DividendIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DividendIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDividendIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DividendIncome model
   */
  readonly fields: DividendIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DividendIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DividendIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DividendIncome model
   */
  interface DividendIncomeFieldRefs {
    readonly id: FieldRef<"DividendIncome", 'String'>
    readonly userId: FieldRef<"DividendIncome", 'String'>
    readonly companyName: FieldRef<"DividendIncome", 'String'>
    readonly dividendAmount: FieldRef<"DividendIncome", 'Decimal'>
    readonly taxDeducted: FieldRef<"DividendIncome", 'Decimal'>
    readonly dateReceived: FieldRef<"DividendIncome", 'DateTime'>
    readonly shareQuantity: FieldRef<"DividendIncome", 'Int'>
    readonly createdAt: FieldRef<"DividendIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"DividendIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DividendIncome findUnique
   */
  export type DividendIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DividendIncome to fetch.
     */
    where: DividendIncomeWhereUniqueInput
  }

  /**
   * DividendIncome findUniqueOrThrow
   */
  export type DividendIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DividendIncome to fetch.
     */
    where: DividendIncomeWhereUniqueInput
  }

  /**
   * DividendIncome findFirst
   */
  export type DividendIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DividendIncome to fetch.
     */
    where?: DividendIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DividendIncomes to fetch.
     */
    orderBy?: DividendIncomeOrderByWithRelationInput | DividendIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DividendIncomes.
     */
    cursor?: DividendIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DividendIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DividendIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DividendIncomes.
     */
    distinct?: DividendIncomeScalarFieldEnum | DividendIncomeScalarFieldEnum[]
  }

  /**
   * DividendIncome findFirstOrThrow
   */
  export type DividendIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DividendIncome to fetch.
     */
    where?: DividendIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DividendIncomes to fetch.
     */
    orderBy?: DividendIncomeOrderByWithRelationInput | DividendIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DividendIncomes.
     */
    cursor?: DividendIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DividendIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DividendIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DividendIncomes.
     */
    distinct?: DividendIncomeScalarFieldEnum | DividendIncomeScalarFieldEnum[]
  }

  /**
   * DividendIncome findMany
   */
  export type DividendIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DividendIncomes to fetch.
     */
    where?: DividendIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DividendIncomes to fetch.
     */
    orderBy?: DividendIncomeOrderByWithRelationInput | DividendIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DividendIncomes.
     */
    cursor?: DividendIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DividendIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DividendIncomes.
     */
    skip?: number
    distinct?: DividendIncomeScalarFieldEnum | DividendIncomeScalarFieldEnum[]
  }

  /**
   * DividendIncome create
   */
  export type DividendIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a DividendIncome.
     */
    data: XOR<DividendIncomeCreateInput, DividendIncomeUncheckedCreateInput>
  }

  /**
   * DividendIncome createMany
   */
  export type DividendIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DividendIncomes.
     */
    data: DividendIncomeCreateManyInput | DividendIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DividendIncome createManyAndReturn
   */
  export type DividendIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many DividendIncomes.
     */
    data: DividendIncomeCreateManyInput | DividendIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DividendIncome update
   */
  export type DividendIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a DividendIncome.
     */
    data: XOR<DividendIncomeUpdateInput, DividendIncomeUncheckedUpdateInput>
    /**
     * Choose, which DividendIncome to update.
     */
    where: DividendIncomeWhereUniqueInput
  }

  /**
   * DividendIncome updateMany
   */
  export type DividendIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DividendIncomes.
     */
    data: XOR<DividendIncomeUpdateManyMutationInput, DividendIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DividendIncomes to update
     */
    where?: DividendIncomeWhereInput
    /**
     * Limit how many DividendIncomes to update.
     */
    limit?: number
  }

  /**
   * DividendIncome updateManyAndReturn
   */
  export type DividendIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * The data used to update DividendIncomes.
     */
    data: XOR<DividendIncomeUpdateManyMutationInput, DividendIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DividendIncomes to update
     */
    where?: DividendIncomeWhereInput
    /**
     * Limit how many DividendIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DividendIncome upsert
   */
  export type DividendIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the DividendIncome to update in case it exists.
     */
    where: DividendIncomeWhereUniqueInput
    /**
     * In case the DividendIncome found by the `where` argument doesn't exist, create a new DividendIncome with this data.
     */
    create: XOR<DividendIncomeCreateInput, DividendIncomeUncheckedCreateInput>
    /**
     * In case the DividendIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DividendIncomeUpdateInput, DividendIncomeUncheckedUpdateInput>
  }

  /**
   * DividendIncome delete
   */
  export type DividendIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
    /**
     * Filter which DividendIncome to delete.
     */
    where: DividendIncomeWhereUniqueInput
  }

  /**
   * DividendIncome deleteMany
   */
  export type DividendIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DividendIncomes to delete
     */
    where?: DividendIncomeWhereInput
    /**
     * Limit how many DividendIncomes to delete.
     */
    limit?: number
  }

  /**
   * DividendIncome without action
   */
  export type DividendIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DividendIncome
     */
    select?: DividendIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DividendIncome
     */
    omit?: DividendIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DividendIncomeInclude<ExtArgs> | null
  }


  /**
   * Model BusinessIncome
   */

  export type AggregateBusinessIncome = {
    _count: BusinessIncomeCountAggregateOutputType | null
    _avg: BusinessIncomeAvgAggregateOutputType | null
    _sum: BusinessIncomeSumAggregateOutputType | null
    _min: BusinessIncomeMinAggregateOutputType | null
    _max: BusinessIncomeMaxAggregateOutputType | null
  }

  export type BusinessIncomeAvgAggregateOutputType = {
    grossReceipts: Decimal | null
    totalIncome: Decimal | null
    businessExpenses: Decimal | null
    netProfit: Decimal | null
    depreciationClaimed: Decimal | null
    presumptiveIncome: Decimal | null
  }

  export type BusinessIncomeSumAggregateOutputType = {
    grossReceipts: Decimal | null
    totalIncome: Decimal | null
    businessExpenses: Decimal | null
    netProfit: Decimal | null
    depreciationClaimed: Decimal | null
    presumptiveIncome: Decimal | null
  }

  export type BusinessIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    businessType: string | null
    businessAddress: string | null
    grossReceipts: Decimal | null
    totalIncome: Decimal | null
    businessExpenses: Decimal | null
    netProfit: Decimal | null
    depreciationClaimed: Decimal | null
    presumptiveIncome: Decimal | null
    section44AD: boolean | null
    section44AE: boolean | null
    auditRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessName: string | null
    businessType: string | null
    businessAddress: string | null
    grossReceipts: Decimal | null
    totalIncome: Decimal | null
    businessExpenses: Decimal | null
    netProfit: Decimal | null
    depreciationClaimed: Decimal | null
    presumptiveIncome: Decimal | null
    section44AD: boolean | null
    section44AE: boolean | null
    auditRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessIncomeCountAggregateOutputType = {
    id: number
    userId: number
    businessName: number
    businessType: number
    businessAddress: number
    grossReceipts: number
    totalIncome: number
    businessExpenses: number
    netProfit: number
    depreciationClaimed: number
    presumptiveIncome: number
    section44AD: number
    section44AE: number
    auditRequired: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessIncomeAvgAggregateInputType = {
    grossReceipts?: true
    totalIncome?: true
    businessExpenses?: true
    netProfit?: true
    depreciationClaimed?: true
    presumptiveIncome?: true
  }

  export type BusinessIncomeSumAggregateInputType = {
    grossReceipts?: true
    totalIncome?: true
    businessExpenses?: true
    netProfit?: true
    depreciationClaimed?: true
    presumptiveIncome?: true
  }

  export type BusinessIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    businessType?: true
    businessAddress?: true
    grossReceipts?: true
    totalIncome?: true
    businessExpenses?: true
    netProfit?: true
    depreciationClaimed?: true
    presumptiveIncome?: true
    section44AD?: true
    section44AE?: true
    auditRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    businessType?: true
    businessAddress?: true
    grossReceipts?: true
    totalIncome?: true
    businessExpenses?: true
    netProfit?: true
    depreciationClaimed?: true
    presumptiveIncome?: true
    section44AD?: true
    section44AE?: true
    auditRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    businessName?: true
    businessType?: true
    businessAddress?: true
    grossReceipts?: true
    totalIncome?: true
    businessExpenses?: true
    netProfit?: true
    depreciationClaimed?: true
    presumptiveIncome?: true
    section44AD?: true
    section44AE?: true
    auditRequired?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessIncome to aggregate.
     */
    where?: BusinessIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessIncomes to fetch.
     */
    orderBy?: BusinessIncomeOrderByWithRelationInput | BusinessIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessIncomes
    **/
    _count?: true | BusinessIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessIncomeMaxAggregateInputType
  }

  export type GetBusinessIncomeAggregateType<T extends BusinessIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessIncome[P]>
      : GetScalarType<T[P], AggregateBusinessIncome[P]>
  }




  export type BusinessIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessIncomeWhereInput
    orderBy?: BusinessIncomeOrderByWithAggregationInput | BusinessIncomeOrderByWithAggregationInput[]
    by: BusinessIncomeScalarFieldEnum[] | BusinessIncomeScalarFieldEnum
    having?: BusinessIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessIncomeCountAggregateInputType | true
    _avg?: BusinessIncomeAvgAggregateInputType
    _sum?: BusinessIncomeSumAggregateInputType
    _min?: BusinessIncomeMinAggregateInputType
    _max?: BusinessIncomeMaxAggregateInputType
  }

  export type BusinessIncomeGroupByOutputType = {
    id: string
    userId: string
    businessName: string | null
    businessType: string | null
    businessAddress: string | null
    grossReceipts: Decimal | null
    totalIncome: Decimal | null
    businessExpenses: Decimal | null
    netProfit: Decimal | null
    depreciationClaimed: Decimal | null
    presumptiveIncome: Decimal | null
    section44AD: boolean
    section44AE: boolean
    auditRequired: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessIncomeCountAggregateOutputType | null
    _avg: BusinessIncomeAvgAggregateOutputType | null
    _sum: BusinessIncomeSumAggregateOutputType | null
    _min: BusinessIncomeMinAggregateOutputType | null
    _max: BusinessIncomeMaxAggregateOutputType | null
  }

  type GetBusinessIncomeGroupByPayload<T extends BusinessIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessIncomeGroupByOutputType[P]>
        }
      >
    >


  export type BusinessIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    businessType?: boolean
    businessAddress?: boolean
    grossReceipts?: boolean
    totalIncome?: boolean
    businessExpenses?: boolean
    netProfit?: boolean
    depreciationClaimed?: boolean
    presumptiveIncome?: boolean
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profitLoss?: boolean | BusinessIncome$profitLossArgs<ExtArgs>
    balanceSheet?: boolean | BusinessIncome$balanceSheetArgs<ExtArgs>
    depreciation?: boolean | BusinessIncome$depreciationArgs<ExtArgs>
    _count?: boolean | BusinessIncomeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessIncome"]>

  export type BusinessIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    businessType?: boolean
    businessAddress?: boolean
    grossReceipts?: boolean
    totalIncome?: boolean
    businessExpenses?: boolean
    netProfit?: boolean
    depreciationClaimed?: boolean
    presumptiveIncome?: boolean
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessIncome"]>

  export type BusinessIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessName?: boolean
    businessType?: boolean
    businessAddress?: boolean
    grossReceipts?: boolean
    totalIncome?: boolean
    businessExpenses?: boolean
    netProfit?: boolean
    depreciationClaimed?: boolean
    presumptiveIncome?: boolean
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessIncome"]>

  export type BusinessIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    businessName?: boolean
    businessType?: boolean
    businessAddress?: boolean
    grossReceipts?: boolean
    totalIncome?: boolean
    businessExpenses?: boolean
    netProfit?: boolean
    depreciationClaimed?: boolean
    presumptiveIncome?: boolean
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "businessName" | "businessType" | "businessAddress" | "grossReceipts" | "totalIncome" | "businessExpenses" | "netProfit" | "depreciationClaimed" | "presumptiveIncome" | "section44AD" | "section44AE" | "auditRequired" | "createdAt" | "updatedAt", ExtArgs["result"]["businessIncome"]>
  export type BusinessIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profitLoss?: boolean | BusinessIncome$profitLossArgs<ExtArgs>
    balanceSheet?: boolean | BusinessIncome$balanceSheetArgs<ExtArgs>
    depreciation?: boolean | BusinessIncome$depreciationArgs<ExtArgs>
    _count?: boolean | BusinessIncomeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BusinessIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BusinessIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profitLoss: Prisma.$ProfitLossPayload<ExtArgs>[]
      balanceSheet: Prisma.$BalanceSheetPayload<ExtArgs>[]
      depreciation: Prisma.$DepreciationEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessName: string | null
      businessType: string | null
      businessAddress: string | null
      grossReceipts: Prisma.Decimal | null
      totalIncome: Prisma.Decimal | null
      businessExpenses: Prisma.Decimal | null
      netProfit: Prisma.Decimal | null
      depreciationClaimed: Prisma.Decimal | null
      presumptiveIncome: Prisma.Decimal | null
      section44AD: boolean
      section44AE: boolean
      auditRequired: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessIncome"]>
    composites: {}
  }

  type BusinessIncomeGetPayload<S extends boolean | null | undefined | BusinessIncomeDefaultArgs> = $Result.GetResult<Prisma.$BusinessIncomePayload, S>

  type BusinessIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessIncomeCountAggregateInputType | true
    }

  export interface BusinessIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessIncome'], meta: { name: 'BusinessIncome' } }
    /**
     * Find zero or one BusinessIncome that matches the filter.
     * @param {BusinessIncomeFindUniqueArgs} args - Arguments to find a BusinessIncome
     * @example
     * // Get one BusinessIncome
     * const businessIncome = await prisma.businessIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessIncomeFindUniqueArgs>(args: SelectSubset<T, BusinessIncomeFindUniqueArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessIncomeFindUniqueOrThrowArgs} args - Arguments to find a BusinessIncome
     * @example
     * // Get one BusinessIncome
     * const businessIncome = await prisma.businessIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeFindFirstArgs} args - Arguments to find a BusinessIncome
     * @example
     * // Get one BusinessIncome
     * const businessIncome = await prisma.businessIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessIncomeFindFirstArgs>(args?: SelectSubset<T, BusinessIncomeFindFirstArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeFindFirstOrThrowArgs} args - Arguments to find a BusinessIncome
     * @example
     * // Get one BusinessIncome
     * const businessIncome = await prisma.businessIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessIncomes
     * const businessIncomes = await prisma.businessIncome.findMany()
     * 
     * // Get first 10 BusinessIncomes
     * const businessIncomes = await prisma.businessIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessIncomeWithIdOnly = await prisma.businessIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessIncomeFindManyArgs>(args?: SelectSubset<T, BusinessIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessIncome.
     * @param {BusinessIncomeCreateArgs} args - Arguments to create a BusinessIncome.
     * @example
     * // Create one BusinessIncome
     * const BusinessIncome = await prisma.businessIncome.create({
     *   data: {
     *     // ... data to create a BusinessIncome
     *   }
     * })
     * 
     */
    create<T extends BusinessIncomeCreateArgs>(args: SelectSubset<T, BusinessIncomeCreateArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessIncomes.
     * @param {BusinessIncomeCreateManyArgs} args - Arguments to create many BusinessIncomes.
     * @example
     * // Create many BusinessIncomes
     * const businessIncome = await prisma.businessIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessIncomeCreateManyArgs>(args?: SelectSubset<T, BusinessIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessIncomes and returns the data saved in the database.
     * @param {BusinessIncomeCreateManyAndReturnArgs} args - Arguments to create many BusinessIncomes.
     * @example
     * // Create many BusinessIncomes
     * const businessIncome = await prisma.businessIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessIncomes and only return the `id`
     * const businessIncomeWithIdOnly = await prisma.businessIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessIncome.
     * @param {BusinessIncomeDeleteArgs} args - Arguments to delete one BusinessIncome.
     * @example
     * // Delete one BusinessIncome
     * const BusinessIncome = await prisma.businessIncome.delete({
     *   where: {
     *     // ... filter to delete one BusinessIncome
     *   }
     * })
     * 
     */
    delete<T extends BusinessIncomeDeleteArgs>(args: SelectSubset<T, BusinessIncomeDeleteArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessIncome.
     * @param {BusinessIncomeUpdateArgs} args - Arguments to update one BusinessIncome.
     * @example
     * // Update one BusinessIncome
     * const businessIncome = await prisma.businessIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessIncomeUpdateArgs>(args: SelectSubset<T, BusinessIncomeUpdateArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessIncomes.
     * @param {BusinessIncomeDeleteManyArgs} args - Arguments to filter BusinessIncomes to delete.
     * @example
     * // Delete a few BusinessIncomes
     * const { count } = await prisma.businessIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessIncomeDeleteManyArgs>(args?: SelectSubset<T, BusinessIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessIncomes
     * const businessIncome = await prisma.businessIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessIncomeUpdateManyArgs>(args: SelectSubset<T, BusinessIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessIncomes and returns the data updated in the database.
     * @param {BusinessIncomeUpdateManyAndReturnArgs} args - Arguments to update many BusinessIncomes.
     * @example
     * // Update many BusinessIncomes
     * const businessIncome = await prisma.businessIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessIncomes and only return the `id`
     * const businessIncomeWithIdOnly = await prisma.businessIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessIncome.
     * @param {BusinessIncomeUpsertArgs} args - Arguments to update or create a BusinessIncome.
     * @example
     * // Update or create a BusinessIncome
     * const businessIncome = await prisma.businessIncome.upsert({
     *   create: {
     *     // ... data to create a BusinessIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessIncome we want to update
     *   }
     * })
     */
    upsert<T extends BusinessIncomeUpsertArgs>(args: SelectSubset<T, BusinessIncomeUpsertArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeCountArgs} args - Arguments to filter BusinessIncomes to count.
     * @example
     * // Count the number of BusinessIncomes
     * const count = await prisma.businessIncome.count({
     *   where: {
     *     // ... the filter for the BusinessIncomes we want to count
     *   }
     * })
    **/
    count<T extends BusinessIncomeCountArgs>(
      args?: Subset<T, BusinessIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessIncomeAggregateArgs>(args: Subset<T, BusinessIncomeAggregateArgs>): Prisma.PrismaPromise<GetBusinessIncomeAggregateType<T>>

    /**
     * Group by BusinessIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessIncomeGroupByArgs['orderBy'] }
        : { orderBy?: BusinessIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessIncome model
   */
  readonly fields: BusinessIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profitLoss<T extends BusinessIncome$profitLossArgs<ExtArgs> = {}>(args?: Subset<T, BusinessIncome$profitLossArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balanceSheet<T extends BusinessIncome$balanceSheetArgs<ExtArgs> = {}>(args?: Subset<T, BusinessIncome$balanceSheetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    depreciation<T extends BusinessIncome$depreciationArgs<ExtArgs> = {}>(args?: Subset<T, BusinessIncome$depreciationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessIncome model
   */
  interface BusinessIncomeFieldRefs {
    readonly id: FieldRef<"BusinessIncome", 'String'>
    readonly userId: FieldRef<"BusinessIncome", 'String'>
    readonly businessName: FieldRef<"BusinessIncome", 'String'>
    readonly businessType: FieldRef<"BusinessIncome", 'String'>
    readonly businessAddress: FieldRef<"BusinessIncome", 'String'>
    readonly grossReceipts: FieldRef<"BusinessIncome", 'Decimal'>
    readonly totalIncome: FieldRef<"BusinessIncome", 'Decimal'>
    readonly businessExpenses: FieldRef<"BusinessIncome", 'Decimal'>
    readonly netProfit: FieldRef<"BusinessIncome", 'Decimal'>
    readonly depreciationClaimed: FieldRef<"BusinessIncome", 'Decimal'>
    readonly presumptiveIncome: FieldRef<"BusinessIncome", 'Decimal'>
    readonly section44AD: FieldRef<"BusinessIncome", 'Boolean'>
    readonly section44AE: FieldRef<"BusinessIncome", 'Boolean'>
    readonly auditRequired: FieldRef<"BusinessIncome", 'Boolean'>
    readonly createdAt: FieldRef<"BusinessIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessIncome findUnique
   */
  export type BusinessIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessIncome to fetch.
     */
    where: BusinessIncomeWhereUniqueInput
  }

  /**
   * BusinessIncome findUniqueOrThrow
   */
  export type BusinessIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessIncome to fetch.
     */
    where: BusinessIncomeWhereUniqueInput
  }

  /**
   * BusinessIncome findFirst
   */
  export type BusinessIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessIncome to fetch.
     */
    where?: BusinessIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessIncomes to fetch.
     */
    orderBy?: BusinessIncomeOrderByWithRelationInput | BusinessIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessIncomes.
     */
    cursor?: BusinessIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessIncomes.
     */
    distinct?: BusinessIncomeScalarFieldEnum | BusinessIncomeScalarFieldEnum[]
  }

  /**
   * BusinessIncome findFirstOrThrow
   */
  export type BusinessIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessIncome to fetch.
     */
    where?: BusinessIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessIncomes to fetch.
     */
    orderBy?: BusinessIncomeOrderByWithRelationInput | BusinessIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessIncomes.
     */
    cursor?: BusinessIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessIncomes.
     */
    distinct?: BusinessIncomeScalarFieldEnum | BusinessIncomeScalarFieldEnum[]
  }

  /**
   * BusinessIncome findMany
   */
  export type BusinessIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessIncomes to fetch.
     */
    where?: BusinessIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessIncomes to fetch.
     */
    orderBy?: BusinessIncomeOrderByWithRelationInput | BusinessIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessIncomes.
     */
    cursor?: BusinessIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessIncomes.
     */
    skip?: number
    distinct?: BusinessIncomeScalarFieldEnum | BusinessIncomeScalarFieldEnum[]
  }

  /**
   * BusinessIncome create
   */
  export type BusinessIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessIncome.
     */
    data: XOR<BusinessIncomeCreateInput, BusinessIncomeUncheckedCreateInput>
  }

  /**
   * BusinessIncome createMany
   */
  export type BusinessIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessIncomes.
     */
    data: BusinessIncomeCreateManyInput | BusinessIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessIncome createManyAndReturn
   */
  export type BusinessIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessIncomes.
     */
    data: BusinessIncomeCreateManyInput | BusinessIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessIncome update
   */
  export type BusinessIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessIncome.
     */
    data: XOR<BusinessIncomeUpdateInput, BusinessIncomeUncheckedUpdateInput>
    /**
     * Choose, which BusinessIncome to update.
     */
    where: BusinessIncomeWhereUniqueInput
  }

  /**
   * BusinessIncome updateMany
   */
  export type BusinessIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessIncomes.
     */
    data: XOR<BusinessIncomeUpdateManyMutationInput, BusinessIncomeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessIncomes to update
     */
    where?: BusinessIncomeWhereInput
    /**
     * Limit how many BusinessIncomes to update.
     */
    limit?: number
  }

  /**
   * BusinessIncome updateManyAndReturn
   */
  export type BusinessIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * The data used to update BusinessIncomes.
     */
    data: XOR<BusinessIncomeUpdateManyMutationInput, BusinessIncomeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessIncomes to update
     */
    where?: BusinessIncomeWhereInput
    /**
     * Limit how many BusinessIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessIncome upsert
   */
  export type BusinessIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessIncome to update in case it exists.
     */
    where: BusinessIncomeWhereUniqueInput
    /**
     * In case the BusinessIncome found by the `where` argument doesn't exist, create a new BusinessIncome with this data.
     */
    create: XOR<BusinessIncomeCreateInput, BusinessIncomeUncheckedCreateInput>
    /**
     * In case the BusinessIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessIncomeUpdateInput, BusinessIncomeUncheckedUpdateInput>
  }

  /**
   * BusinessIncome delete
   */
  export type BusinessIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    /**
     * Filter which BusinessIncome to delete.
     */
    where: BusinessIncomeWhereUniqueInput
  }

  /**
   * BusinessIncome deleteMany
   */
  export type BusinessIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessIncomes to delete
     */
    where?: BusinessIncomeWhereInput
    /**
     * Limit how many BusinessIncomes to delete.
     */
    limit?: number
  }

  /**
   * BusinessIncome.profitLoss
   */
  export type BusinessIncome$profitLossArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    where?: ProfitLossWhereInput
    orderBy?: ProfitLossOrderByWithRelationInput | ProfitLossOrderByWithRelationInput[]
    cursor?: ProfitLossWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * BusinessIncome.balanceSheet
   */
  export type BusinessIncome$balanceSheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    where?: BalanceSheetWhereInput
    orderBy?: BalanceSheetOrderByWithRelationInput | BalanceSheetOrderByWithRelationInput[]
    cursor?: BalanceSheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalanceSheetScalarFieldEnum | BalanceSheetScalarFieldEnum[]
  }

  /**
   * BusinessIncome.depreciation
   */
  export type BusinessIncome$depreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    where?: DepreciationEntryWhereInput
    orderBy?: DepreciationEntryOrderByWithRelationInput | DepreciationEntryOrderByWithRelationInput[]
    cursor?: DepreciationEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepreciationEntryScalarFieldEnum | DepreciationEntryScalarFieldEnum[]
  }

  /**
   * BusinessIncome without action
   */
  export type BusinessIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
  }


  /**
   * Model ProfessionalIncome
   */

  export type AggregateProfessionalIncome = {
    _count: ProfessionalIncomeCountAggregateOutputType | null
    _avg: ProfessionalIncomeAvgAggregateOutputType | null
    _sum: ProfessionalIncomeSumAggregateOutputType | null
    _min: ProfessionalIncomeMinAggregateOutputType | null
    _max: ProfessionalIncomeMaxAggregateOutputType | null
  }

  export type ProfessionalIncomeAvgAggregateOutputType = {
    grossReceipts: Decimal | null
    totalExpenses: Decimal | null
    netProfit: Decimal | null
    presumptiveIncome: Decimal | null
  }

  export type ProfessionalIncomeSumAggregateOutputType = {
    grossReceipts: Decimal | null
    totalExpenses: Decimal | null
    netProfit: Decimal | null
    presumptiveIncome: Decimal | null
  }

  export type ProfessionalIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    professionType: string | null
    grossReceipts: Decimal | null
    totalExpenses: Decimal | null
    netProfit: Decimal | null
    section44ADA: boolean | null
    presumptiveIncome: Decimal | null
    auditRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfessionalIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    professionType: string | null
    grossReceipts: Decimal | null
    totalExpenses: Decimal | null
    netProfit: Decimal | null
    section44ADA: boolean | null
    presumptiveIncome: Decimal | null
    auditRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfessionalIncomeCountAggregateOutputType = {
    id: number
    userId: number
    professionType: number
    grossReceipts: number
    totalExpenses: number
    netProfit: number
    section44ADA: number
    presumptiveIncome: number
    auditRequired: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfessionalIncomeAvgAggregateInputType = {
    grossReceipts?: true
    totalExpenses?: true
    netProfit?: true
    presumptiveIncome?: true
  }

  export type ProfessionalIncomeSumAggregateInputType = {
    grossReceipts?: true
    totalExpenses?: true
    netProfit?: true
    presumptiveIncome?: true
  }

  export type ProfessionalIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    professionType?: true
    grossReceipts?: true
    totalExpenses?: true
    netProfit?: true
    section44ADA?: true
    presumptiveIncome?: true
    auditRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfessionalIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    professionType?: true
    grossReceipts?: true
    totalExpenses?: true
    netProfit?: true
    section44ADA?: true
    presumptiveIncome?: true
    auditRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfessionalIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    professionType?: true
    grossReceipts?: true
    totalExpenses?: true
    netProfit?: true
    section44ADA?: true
    presumptiveIncome?: true
    auditRequired?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfessionalIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfessionalIncome to aggregate.
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalIncomes to fetch.
     */
    orderBy?: ProfessionalIncomeOrderByWithRelationInput | ProfessionalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfessionalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfessionalIncomes
    **/
    _count?: true | ProfessionalIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfessionalIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfessionalIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfessionalIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfessionalIncomeMaxAggregateInputType
  }

  export type GetProfessionalIncomeAggregateType<T extends ProfessionalIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateProfessionalIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfessionalIncome[P]>
      : GetScalarType<T[P], AggregateProfessionalIncome[P]>
  }




  export type ProfessionalIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfessionalIncomeWhereInput
    orderBy?: ProfessionalIncomeOrderByWithAggregationInput | ProfessionalIncomeOrderByWithAggregationInput[]
    by: ProfessionalIncomeScalarFieldEnum[] | ProfessionalIncomeScalarFieldEnum
    having?: ProfessionalIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfessionalIncomeCountAggregateInputType | true
    _avg?: ProfessionalIncomeAvgAggregateInputType
    _sum?: ProfessionalIncomeSumAggregateInputType
    _min?: ProfessionalIncomeMinAggregateInputType
    _max?: ProfessionalIncomeMaxAggregateInputType
  }

  export type ProfessionalIncomeGroupByOutputType = {
    id: string
    userId: string
    professionType: string | null
    grossReceipts: Decimal | null
    totalExpenses: Decimal | null
    netProfit: Decimal | null
    section44ADA: boolean
    presumptiveIncome: Decimal | null
    auditRequired: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfessionalIncomeCountAggregateOutputType | null
    _avg: ProfessionalIncomeAvgAggregateOutputType | null
    _sum: ProfessionalIncomeSumAggregateOutputType | null
    _min: ProfessionalIncomeMinAggregateOutputType | null
    _max: ProfessionalIncomeMaxAggregateOutputType | null
  }

  type GetProfessionalIncomeGroupByPayload<T extends ProfessionalIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfessionalIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfessionalIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfessionalIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], ProfessionalIncomeGroupByOutputType[P]>
        }
      >
    >


  export type ProfessionalIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    professionType?: boolean
    grossReceipts?: boolean
    totalExpenses?: boolean
    netProfit?: boolean
    section44ADA?: boolean
    presumptiveIncome?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["professionalIncome"]>

  export type ProfessionalIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    professionType?: boolean
    grossReceipts?: boolean
    totalExpenses?: boolean
    netProfit?: boolean
    section44ADA?: boolean
    presumptiveIncome?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["professionalIncome"]>

  export type ProfessionalIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    professionType?: boolean
    grossReceipts?: boolean
    totalExpenses?: boolean
    netProfit?: boolean
    section44ADA?: boolean
    presumptiveIncome?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["professionalIncome"]>

  export type ProfessionalIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    professionType?: boolean
    grossReceipts?: boolean
    totalExpenses?: boolean
    netProfit?: boolean
    section44ADA?: boolean
    presumptiveIncome?: boolean
    auditRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfessionalIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "professionType" | "grossReceipts" | "totalExpenses" | "netProfit" | "section44ADA" | "presumptiveIncome" | "auditRequired" | "createdAt" | "updatedAt", ExtArgs["result"]["professionalIncome"]>
  export type ProfessionalIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfessionalIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfessionalIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfessionalIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfessionalIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      professionType: string | null
      grossReceipts: Prisma.Decimal | null
      totalExpenses: Prisma.Decimal | null
      netProfit: Prisma.Decimal | null
      section44ADA: boolean
      presumptiveIncome: Prisma.Decimal | null
      auditRequired: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["professionalIncome"]>
    composites: {}
  }

  type ProfessionalIncomeGetPayload<S extends boolean | null | undefined | ProfessionalIncomeDefaultArgs> = $Result.GetResult<Prisma.$ProfessionalIncomePayload, S>

  type ProfessionalIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfessionalIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfessionalIncomeCountAggregateInputType | true
    }

  export interface ProfessionalIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfessionalIncome'], meta: { name: 'ProfessionalIncome' } }
    /**
     * Find zero or one ProfessionalIncome that matches the filter.
     * @param {ProfessionalIncomeFindUniqueArgs} args - Arguments to find a ProfessionalIncome
     * @example
     * // Get one ProfessionalIncome
     * const professionalIncome = await prisma.professionalIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfessionalIncomeFindUniqueArgs>(args: SelectSubset<T, ProfessionalIncomeFindUniqueArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfessionalIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfessionalIncomeFindUniqueOrThrowArgs} args - Arguments to find a ProfessionalIncome
     * @example
     * // Get one ProfessionalIncome
     * const professionalIncome = await prisma.professionalIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfessionalIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfessionalIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfessionalIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeFindFirstArgs} args - Arguments to find a ProfessionalIncome
     * @example
     * // Get one ProfessionalIncome
     * const professionalIncome = await prisma.professionalIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfessionalIncomeFindFirstArgs>(args?: SelectSubset<T, ProfessionalIncomeFindFirstArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfessionalIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeFindFirstOrThrowArgs} args - Arguments to find a ProfessionalIncome
     * @example
     * // Get one ProfessionalIncome
     * const professionalIncome = await prisma.professionalIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfessionalIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfessionalIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfessionalIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfessionalIncomes
     * const professionalIncomes = await prisma.professionalIncome.findMany()
     * 
     * // Get first 10 ProfessionalIncomes
     * const professionalIncomes = await prisma.professionalIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const professionalIncomeWithIdOnly = await prisma.professionalIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfessionalIncomeFindManyArgs>(args?: SelectSubset<T, ProfessionalIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfessionalIncome.
     * @param {ProfessionalIncomeCreateArgs} args - Arguments to create a ProfessionalIncome.
     * @example
     * // Create one ProfessionalIncome
     * const ProfessionalIncome = await prisma.professionalIncome.create({
     *   data: {
     *     // ... data to create a ProfessionalIncome
     *   }
     * })
     * 
     */
    create<T extends ProfessionalIncomeCreateArgs>(args: SelectSubset<T, ProfessionalIncomeCreateArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfessionalIncomes.
     * @param {ProfessionalIncomeCreateManyArgs} args - Arguments to create many ProfessionalIncomes.
     * @example
     * // Create many ProfessionalIncomes
     * const professionalIncome = await prisma.professionalIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfessionalIncomeCreateManyArgs>(args?: SelectSubset<T, ProfessionalIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfessionalIncomes and returns the data saved in the database.
     * @param {ProfessionalIncomeCreateManyAndReturnArgs} args - Arguments to create many ProfessionalIncomes.
     * @example
     * // Create many ProfessionalIncomes
     * const professionalIncome = await prisma.professionalIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfessionalIncomes and only return the `id`
     * const professionalIncomeWithIdOnly = await prisma.professionalIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfessionalIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfessionalIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfessionalIncome.
     * @param {ProfessionalIncomeDeleteArgs} args - Arguments to delete one ProfessionalIncome.
     * @example
     * // Delete one ProfessionalIncome
     * const ProfessionalIncome = await prisma.professionalIncome.delete({
     *   where: {
     *     // ... filter to delete one ProfessionalIncome
     *   }
     * })
     * 
     */
    delete<T extends ProfessionalIncomeDeleteArgs>(args: SelectSubset<T, ProfessionalIncomeDeleteArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfessionalIncome.
     * @param {ProfessionalIncomeUpdateArgs} args - Arguments to update one ProfessionalIncome.
     * @example
     * // Update one ProfessionalIncome
     * const professionalIncome = await prisma.professionalIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfessionalIncomeUpdateArgs>(args: SelectSubset<T, ProfessionalIncomeUpdateArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfessionalIncomes.
     * @param {ProfessionalIncomeDeleteManyArgs} args - Arguments to filter ProfessionalIncomes to delete.
     * @example
     * // Delete a few ProfessionalIncomes
     * const { count } = await prisma.professionalIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfessionalIncomeDeleteManyArgs>(args?: SelectSubset<T, ProfessionalIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfessionalIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfessionalIncomes
     * const professionalIncome = await prisma.professionalIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfessionalIncomeUpdateManyArgs>(args: SelectSubset<T, ProfessionalIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfessionalIncomes and returns the data updated in the database.
     * @param {ProfessionalIncomeUpdateManyAndReturnArgs} args - Arguments to update many ProfessionalIncomes.
     * @example
     * // Update many ProfessionalIncomes
     * const professionalIncome = await prisma.professionalIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfessionalIncomes and only return the `id`
     * const professionalIncomeWithIdOnly = await prisma.professionalIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfessionalIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfessionalIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfessionalIncome.
     * @param {ProfessionalIncomeUpsertArgs} args - Arguments to update or create a ProfessionalIncome.
     * @example
     * // Update or create a ProfessionalIncome
     * const professionalIncome = await prisma.professionalIncome.upsert({
     *   create: {
     *     // ... data to create a ProfessionalIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfessionalIncome we want to update
     *   }
     * })
     */
    upsert<T extends ProfessionalIncomeUpsertArgs>(args: SelectSubset<T, ProfessionalIncomeUpsertArgs<ExtArgs>>): Prisma__ProfessionalIncomeClient<$Result.GetResult<Prisma.$ProfessionalIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfessionalIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeCountArgs} args - Arguments to filter ProfessionalIncomes to count.
     * @example
     * // Count the number of ProfessionalIncomes
     * const count = await prisma.professionalIncome.count({
     *   where: {
     *     // ... the filter for the ProfessionalIncomes we want to count
     *   }
     * })
    **/
    count<T extends ProfessionalIncomeCountArgs>(
      args?: Subset<T, ProfessionalIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfessionalIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfessionalIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfessionalIncomeAggregateArgs>(args: Subset<T, ProfessionalIncomeAggregateArgs>): Prisma.PrismaPromise<GetProfessionalIncomeAggregateType<T>>

    /**
     * Group by ProfessionalIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfessionalIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfessionalIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfessionalIncomeGroupByArgs['orderBy'] }
        : { orderBy?: ProfessionalIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfessionalIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfessionalIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfessionalIncome model
   */
  readonly fields: ProfessionalIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfessionalIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfessionalIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfessionalIncome model
   */
  interface ProfessionalIncomeFieldRefs {
    readonly id: FieldRef<"ProfessionalIncome", 'String'>
    readonly userId: FieldRef<"ProfessionalIncome", 'String'>
    readonly professionType: FieldRef<"ProfessionalIncome", 'String'>
    readonly grossReceipts: FieldRef<"ProfessionalIncome", 'Decimal'>
    readonly totalExpenses: FieldRef<"ProfessionalIncome", 'Decimal'>
    readonly netProfit: FieldRef<"ProfessionalIncome", 'Decimal'>
    readonly section44ADA: FieldRef<"ProfessionalIncome", 'Boolean'>
    readonly presumptiveIncome: FieldRef<"ProfessionalIncome", 'Decimal'>
    readonly auditRequired: FieldRef<"ProfessionalIncome", 'Boolean'>
    readonly createdAt: FieldRef<"ProfessionalIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfessionalIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfessionalIncome findUnique
   */
  export type ProfessionalIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalIncome to fetch.
     */
    where: ProfessionalIncomeWhereUniqueInput
  }

  /**
   * ProfessionalIncome findUniqueOrThrow
   */
  export type ProfessionalIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalIncome to fetch.
     */
    where: ProfessionalIncomeWhereUniqueInput
  }

  /**
   * ProfessionalIncome findFirst
   */
  export type ProfessionalIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalIncome to fetch.
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalIncomes to fetch.
     */
    orderBy?: ProfessionalIncomeOrderByWithRelationInput | ProfessionalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfessionalIncomes.
     */
    cursor?: ProfessionalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfessionalIncomes.
     */
    distinct?: ProfessionalIncomeScalarFieldEnum | ProfessionalIncomeScalarFieldEnum[]
  }

  /**
   * ProfessionalIncome findFirstOrThrow
   */
  export type ProfessionalIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalIncome to fetch.
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalIncomes to fetch.
     */
    orderBy?: ProfessionalIncomeOrderByWithRelationInput | ProfessionalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfessionalIncomes.
     */
    cursor?: ProfessionalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfessionalIncomes.
     */
    distinct?: ProfessionalIncomeScalarFieldEnum | ProfessionalIncomeScalarFieldEnum[]
  }

  /**
   * ProfessionalIncome findMany
   */
  export type ProfessionalIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ProfessionalIncomes to fetch.
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfessionalIncomes to fetch.
     */
    orderBy?: ProfessionalIncomeOrderByWithRelationInput | ProfessionalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfessionalIncomes.
     */
    cursor?: ProfessionalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfessionalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfessionalIncomes.
     */
    skip?: number
    distinct?: ProfessionalIncomeScalarFieldEnum | ProfessionalIncomeScalarFieldEnum[]
  }

  /**
   * ProfessionalIncome create
   */
  export type ProfessionalIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfessionalIncome.
     */
    data: XOR<ProfessionalIncomeCreateInput, ProfessionalIncomeUncheckedCreateInput>
  }

  /**
   * ProfessionalIncome createMany
   */
  export type ProfessionalIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfessionalIncomes.
     */
    data: ProfessionalIncomeCreateManyInput | ProfessionalIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfessionalIncome createManyAndReturn
   */
  export type ProfessionalIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many ProfessionalIncomes.
     */
    data: ProfessionalIncomeCreateManyInput | ProfessionalIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfessionalIncome update
   */
  export type ProfessionalIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfessionalIncome.
     */
    data: XOR<ProfessionalIncomeUpdateInput, ProfessionalIncomeUncheckedUpdateInput>
    /**
     * Choose, which ProfessionalIncome to update.
     */
    where: ProfessionalIncomeWhereUniqueInput
  }

  /**
   * ProfessionalIncome updateMany
   */
  export type ProfessionalIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfessionalIncomes.
     */
    data: XOR<ProfessionalIncomeUpdateManyMutationInput, ProfessionalIncomeUncheckedUpdateManyInput>
    /**
     * Filter which ProfessionalIncomes to update
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * Limit how many ProfessionalIncomes to update.
     */
    limit?: number
  }

  /**
   * ProfessionalIncome updateManyAndReturn
   */
  export type ProfessionalIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * The data used to update ProfessionalIncomes.
     */
    data: XOR<ProfessionalIncomeUpdateManyMutationInput, ProfessionalIncomeUncheckedUpdateManyInput>
    /**
     * Filter which ProfessionalIncomes to update
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * Limit how many ProfessionalIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfessionalIncome upsert
   */
  export type ProfessionalIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfessionalIncome to update in case it exists.
     */
    where: ProfessionalIncomeWhereUniqueInput
    /**
     * In case the ProfessionalIncome found by the `where` argument doesn't exist, create a new ProfessionalIncome with this data.
     */
    create: XOR<ProfessionalIncomeCreateInput, ProfessionalIncomeUncheckedCreateInput>
    /**
     * In case the ProfessionalIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfessionalIncomeUpdateInput, ProfessionalIncomeUncheckedUpdateInput>
  }

  /**
   * ProfessionalIncome delete
   */
  export type ProfessionalIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
    /**
     * Filter which ProfessionalIncome to delete.
     */
    where: ProfessionalIncomeWhereUniqueInput
  }

  /**
   * ProfessionalIncome deleteMany
   */
  export type ProfessionalIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfessionalIncomes to delete
     */
    where?: ProfessionalIncomeWhereInput
    /**
     * Limit how many ProfessionalIncomes to delete.
     */
    limit?: number
  }

  /**
   * ProfessionalIncome without action
   */
  export type ProfessionalIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfessionalIncome
     */
    select?: ProfessionalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfessionalIncome
     */
    omit?: ProfessionalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfessionalIncomeInclude<ExtArgs> | null
  }


  /**
   * Model ProfitLoss
   */

  export type AggregateProfitLoss = {
    _count: ProfitLossCountAggregateOutputType | null
    _avg: ProfitLossAvgAggregateOutputType | null
    _sum: ProfitLossSumAggregateOutputType | null
    _min: ProfitLossMinAggregateOutputType | null
    _max: ProfitLossMaxAggregateOutputType | null
  }

  export type ProfitLossAvgAggregateOutputType = {
    netProfit: Decimal | null
  }

  export type ProfitLossSumAggregateOutputType = {
    netProfit: Decimal | null
  }

  export type ProfitLossMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessIncomeId: string | null
    year: string | null
    netProfit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfitLossMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessIncomeId: string | null
    year: string | null
    netProfit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfitLossCountAggregateOutputType = {
    id: number
    userId: number
    businessIncomeId: number
    year: number
    income: number
    expenses: number
    netProfit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfitLossAvgAggregateInputType = {
    netProfit?: true
  }

  export type ProfitLossSumAggregateInputType = {
    netProfit?: true
  }

  export type ProfitLossMinAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    year?: true
    netProfit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfitLossMaxAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    year?: true
    netProfit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfitLossCountAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    year?: true
    income?: true
    expenses?: true
    netProfit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfitLossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfitLoss to aggregate.
     */
    where?: ProfitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfitLosses to fetch.
     */
    orderBy?: ProfitLossOrderByWithRelationInput | ProfitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfitLosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfitLosses
    **/
    _count?: true | ProfitLossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfitLossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfitLossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfitLossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfitLossMaxAggregateInputType
  }

  export type GetProfitLossAggregateType<T extends ProfitLossAggregateArgs> = {
        [P in keyof T & keyof AggregateProfitLoss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfitLoss[P]>
      : GetScalarType<T[P], AggregateProfitLoss[P]>
  }




  export type ProfitLossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfitLossWhereInput
    orderBy?: ProfitLossOrderByWithAggregationInput | ProfitLossOrderByWithAggregationInput[]
    by: ProfitLossScalarFieldEnum[] | ProfitLossScalarFieldEnum
    having?: ProfitLossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfitLossCountAggregateInputType | true
    _avg?: ProfitLossAvgAggregateInputType
    _sum?: ProfitLossSumAggregateInputType
    _min?: ProfitLossMinAggregateInputType
    _max?: ProfitLossMaxAggregateInputType
  }

  export type ProfitLossGroupByOutputType = {
    id: string
    userId: string
    businessIncomeId: string | null
    year: string | null
    income: JsonValue | null
    expenses: JsonValue | null
    netProfit: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ProfitLossCountAggregateOutputType | null
    _avg: ProfitLossAvgAggregateOutputType | null
    _sum: ProfitLossSumAggregateOutputType | null
    _min: ProfitLossMinAggregateOutputType | null
    _max: ProfitLossMaxAggregateOutputType | null
  }

  type GetProfitLossGroupByPayload<T extends ProfitLossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfitLossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfitLossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfitLossGroupByOutputType[P]>
            : GetScalarType<T[P], ProfitLossGroupByOutputType[P]>
        }
      >
    >


  export type ProfitLossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    income?: boolean
    expenses?: boolean
    netProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | ProfitLoss$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["profitLoss"]>

  export type ProfitLossSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    income?: boolean
    expenses?: boolean
    netProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | ProfitLoss$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["profitLoss"]>

  export type ProfitLossSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    income?: boolean
    expenses?: boolean
    netProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | ProfitLoss$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["profitLoss"]>

  export type ProfitLossSelectScalar = {
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    income?: boolean
    expenses?: boolean
    netProfit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfitLossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "businessIncomeId" | "year" | "income" | "expenses" | "netProfit" | "createdAt" | "updatedAt", ExtArgs["result"]["profitLoss"]>
  export type ProfitLossInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | ProfitLoss$businessIncomeArgs<ExtArgs>
  }
  export type ProfitLossIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | ProfitLoss$businessIncomeArgs<ExtArgs>
  }
  export type ProfitLossIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | ProfitLoss$businessIncomeArgs<ExtArgs>
  }

  export type $ProfitLossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfitLoss"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      businessIncome: Prisma.$BusinessIncomePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessIncomeId: string | null
      year: string | null
      income: Prisma.JsonValue | null
      expenses: Prisma.JsonValue | null
      netProfit: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profitLoss"]>
    composites: {}
  }

  type ProfitLossGetPayload<S extends boolean | null | undefined | ProfitLossDefaultArgs> = $Result.GetResult<Prisma.$ProfitLossPayload, S>

  type ProfitLossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfitLossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfitLossCountAggregateInputType | true
    }

  export interface ProfitLossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfitLoss'], meta: { name: 'ProfitLoss' } }
    /**
     * Find zero or one ProfitLoss that matches the filter.
     * @param {ProfitLossFindUniqueArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfitLossFindUniqueArgs>(args: SelectSubset<T, ProfitLossFindUniqueArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfitLoss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfitLossFindUniqueOrThrowArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfitLossFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfitLossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfitLoss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossFindFirstArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfitLossFindFirstArgs>(args?: SelectSubset<T, ProfitLossFindFirstArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfitLoss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossFindFirstOrThrowArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfitLossFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfitLossFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfitLosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfitLosses
     * const profitLosses = await prisma.profitLoss.findMany()
     * 
     * // Get first 10 ProfitLosses
     * const profitLosses = await prisma.profitLoss.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profitLossWithIdOnly = await prisma.profitLoss.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfitLossFindManyArgs>(args?: SelectSubset<T, ProfitLossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfitLoss.
     * @param {ProfitLossCreateArgs} args - Arguments to create a ProfitLoss.
     * @example
     * // Create one ProfitLoss
     * const ProfitLoss = await prisma.profitLoss.create({
     *   data: {
     *     // ... data to create a ProfitLoss
     *   }
     * })
     * 
     */
    create<T extends ProfitLossCreateArgs>(args: SelectSubset<T, ProfitLossCreateArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfitLosses.
     * @param {ProfitLossCreateManyArgs} args - Arguments to create many ProfitLosses.
     * @example
     * // Create many ProfitLosses
     * const profitLoss = await prisma.profitLoss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfitLossCreateManyArgs>(args?: SelectSubset<T, ProfitLossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfitLosses and returns the data saved in the database.
     * @param {ProfitLossCreateManyAndReturnArgs} args - Arguments to create many ProfitLosses.
     * @example
     * // Create many ProfitLosses
     * const profitLoss = await prisma.profitLoss.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfitLosses and only return the `id`
     * const profitLossWithIdOnly = await prisma.profitLoss.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfitLossCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfitLossCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfitLoss.
     * @param {ProfitLossDeleteArgs} args - Arguments to delete one ProfitLoss.
     * @example
     * // Delete one ProfitLoss
     * const ProfitLoss = await prisma.profitLoss.delete({
     *   where: {
     *     // ... filter to delete one ProfitLoss
     *   }
     * })
     * 
     */
    delete<T extends ProfitLossDeleteArgs>(args: SelectSubset<T, ProfitLossDeleteArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfitLoss.
     * @param {ProfitLossUpdateArgs} args - Arguments to update one ProfitLoss.
     * @example
     * // Update one ProfitLoss
     * const profitLoss = await prisma.profitLoss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfitLossUpdateArgs>(args: SelectSubset<T, ProfitLossUpdateArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfitLosses.
     * @param {ProfitLossDeleteManyArgs} args - Arguments to filter ProfitLosses to delete.
     * @example
     * // Delete a few ProfitLosses
     * const { count } = await prisma.profitLoss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfitLossDeleteManyArgs>(args?: SelectSubset<T, ProfitLossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfitLosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfitLosses
     * const profitLoss = await prisma.profitLoss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfitLossUpdateManyArgs>(args: SelectSubset<T, ProfitLossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfitLosses and returns the data updated in the database.
     * @param {ProfitLossUpdateManyAndReturnArgs} args - Arguments to update many ProfitLosses.
     * @example
     * // Update many ProfitLosses
     * const profitLoss = await prisma.profitLoss.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfitLosses and only return the `id`
     * const profitLossWithIdOnly = await prisma.profitLoss.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfitLossUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfitLossUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfitLoss.
     * @param {ProfitLossUpsertArgs} args - Arguments to update or create a ProfitLoss.
     * @example
     * // Update or create a ProfitLoss
     * const profitLoss = await prisma.profitLoss.upsert({
     *   create: {
     *     // ... data to create a ProfitLoss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfitLoss we want to update
     *   }
     * })
     */
    upsert<T extends ProfitLossUpsertArgs>(args: SelectSubset<T, ProfitLossUpsertArgs<ExtArgs>>): Prisma__ProfitLossClient<$Result.GetResult<Prisma.$ProfitLossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfitLosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossCountArgs} args - Arguments to filter ProfitLosses to count.
     * @example
     * // Count the number of ProfitLosses
     * const count = await prisma.profitLoss.count({
     *   where: {
     *     // ... the filter for the ProfitLosses we want to count
     *   }
     * })
    **/
    count<T extends ProfitLossCountArgs>(
      args?: Subset<T, ProfitLossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfitLossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfitLoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfitLossAggregateArgs>(args: Subset<T, ProfitLossAggregateArgs>): Prisma.PrismaPromise<GetProfitLossAggregateType<T>>

    /**
     * Group by ProfitLoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfitLossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfitLossGroupByArgs['orderBy'] }
        : { orderBy?: ProfitLossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfitLossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfitLossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfitLoss model
   */
  readonly fields: ProfitLossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfitLoss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfitLossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessIncome<T extends ProfitLoss$businessIncomeArgs<ExtArgs> = {}>(args?: Subset<T, ProfitLoss$businessIncomeArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfitLoss model
   */
  interface ProfitLossFieldRefs {
    readonly id: FieldRef<"ProfitLoss", 'String'>
    readonly userId: FieldRef<"ProfitLoss", 'String'>
    readonly businessIncomeId: FieldRef<"ProfitLoss", 'String'>
    readonly year: FieldRef<"ProfitLoss", 'String'>
    readonly income: FieldRef<"ProfitLoss", 'Json'>
    readonly expenses: FieldRef<"ProfitLoss", 'Json'>
    readonly netProfit: FieldRef<"ProfitLoss", 'Decimal'>
    readonly createdAt: FieldRef<"ProfitLoss", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfitLoss", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfitLoss findUnique
   */
  export type ProfitLossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * Filter, which ProfitLoss to fetch.
     */
    where: ProfitLossWhereUniqueInput
  }

  /**
   * ProfitLoss findUniqueOrThrow
   */
  export type ProfitLossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * Filter, which ProfitLoss to fetch.
     */
    where: ProfitLossWhereUniqueInput
  }

  /**
   * ProfitLoss findFirst
   */
  export type ProfitLossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * Filter, which ProfitLoss to fetch.
     */
    where?: ProfitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfitLosses to fetch.
     */
    orderBy?: ProfitLossOrderByWithRelationInput | ProfitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfitLosses.
     */
    cursor?: ProfitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfitLosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfitLosses.
     */
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * ProfitLoss findFirstOrThrow
   */
  export type ProfitLossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * Filter, which ProfitLoss to fetch.
     */
    where?: ProfitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfitLosses to fetch.
     */
    orderBy?: ProfitLossOrderByWithRelationInput | ProfitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfitLosses.
     */
    cursor?: ProfitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfitLosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfitLosses.
     */
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * ProfitLoss findMany
   */
  export type ProfitLossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * Filter, which ProfitLosses to fetch.
     */
    where?: ProfitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfitLosses to fetch.
     */
    orderBy?: ProfitLossOrderByWithRelationInput | ProfitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfitLosses.
     */
    cursor?: ProfitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfitLosses.
     */
    skip?: number
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * ProfitLoss create
   */
  export type ProfitLossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfitLoss.
     */
    data: XOR<ProfitLossCreateInput, ProfitLossUncheckedCreateInput>
  }

  /**
   * ProfitLoss createMany
   */
  export type ProfitLossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfitLosses.
     */
    data: ProfitLossCreateManyInput | ProfitLossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfitLoss createManyAndReturn
   */
  export type ProfitLossCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * The data used to create many ProfitLosses.
     */
    data: ProfitLossCreateManyInput | ProfitLossCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfitLoss update
   */
  export type ProfitLossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfitLoss.
     */
    data: XOR<ProfitLossUpdateInput, ProfitLossUncheckedUpdateInput>
    /**
     * Choose, which ProfitLoss to update.
     */
    where: ProfitLossWhereUniqueInput
  }

  /**
   * ProfitLoss updateMany
   */
  export type ProfitLossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfitLosses.
     */
    data: XOR<ProfitLossUpdateManyMutationInput, ProfitLossUncheckedUpdateManyInput>
    /**
     * Filter which ProfitLosses to update
     */
    where?: ProfitLossWhereInput
    /**
     * Limit how many ProfitLosses to update.
     */
    limit?: number
  }

  /**
   * ProfitLoss updateManyAndReturn
   */
  export type ProfitLossUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * The data used to update ProfitLosses.
     */
    data: XOR<ProfitLossUpdateManyMutationInput, ProfitLossUncheckedUpdateManyInput>
    /**
     * Filter which ProfitLosses to update
     */
    where?: ProfitLossWhereInput
    /**
     * Limit how many ProfitLosses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfitLoss upsert
   */
  export type ProfitLossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfitLoss to update in case it exists.
     */
    where: ProfitLossWhereUniqueInput
    /**
     * In case the ProfitLoss found by the `where` argument doesn't exist, create a new ProfitLoss with this data.
     */
    create: XOR<ProfitLossCreateInput, ProfitLossUncheckedCreateInput>
    /**
     * In case the ProfitLoss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfitLossUpdateInput, ProfitLossUncheckedUpdateInput>
  }

  /**
   * ProfitLoss delete
   */
  export type ProfitLossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
    /**
     * Filter which ProfitLoss to delete.
     */
    where: ProfitLossWhereUniqueInput
  }

  /**
   * ProfitLoss deleteMany
   */
  export type ProfitLossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfitLosses to delete
     */
    where?: ProfitLossWhereInput
    /**
     * Limit how many ProfitLosses to delete.
     */
    limit?: number
  }

  /**
   * ProfitLoss.businessIncome
   */
  export type ProfitLoss$businessIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    where?: BusinessIncomeWhereInput
  }

  /**
   * ProfitLoss without action
   */
  export type ProfitLossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfitLoss
     */
    select?: ProfitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfitLoss
     */
    omit?: ProfitLossOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfitLossInclude<ExtArgs> | null
  }


  /**
   * Model BalanceSheet
   */

  export type AggregateBalanceSheet = {
    _count: BalanceSheetCountAggregateOutputType | null
    _min: BalanceSheetMinAggregateOutputType | null
    _max: BalanceSheetMaxAggregateOutputType | null
  }

  export type BalanceSheetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessIncomeId: string | null
    year: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceSheetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessIncomeId: string | null
    year: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalanceSheetCountAggregateOutputType = {
    id: number
    userId: number
    businessIncomeId: number
    year: number
    assets: number
    liabilities: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BalanceSheetMinAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceSheetMaxAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalanceSheetCountAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    year?: true
    assets?: true
    liabilities?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BalanceSheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceSheet to aggregate.
     */
    where?: BalanceSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceSheets to fetch.
     */
    orderBy?: BalanceSheetOrderByWithRelationInput | BalanceSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BalanceSheets
    **/
    _count?: true | BalanceSheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceSheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceSheetMaxAggregateInputType
  }

  export type GetBalanceSheetAggregateType<T extends BalanceSheetAggregateArgs> = {
        [P in keyof T & keyof AggregateBalanceSheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalanceSheet[P]>
      : GetScalarType<T[P], AggregateBalanceSheet[P]>
  }




  export type BalanceSheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceSheetWhereInput
    orderBy?: BalanceSheetOrderByWithAggregationInput | BalanceSheetOrderByWithAggregationInput[]
    by: BalanceSheetScalarFieldEnum[] | BalanceSheetScalarFieldEnum
    having?: BalanceSheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceSheetCountAggregateInputType | true
    _min?: BalanceSheetMinAggregateInputType
    _max?: BalanceSheetMaxAggregateInputType
  }

  export type BalanceSheetGroupByOutputType = {
    id: string
    userId: string
    businessIncomeId: string | null
    year: string | null
    assets: JsonValue | null
    liabilities: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BalanceSheetCountAggregateOutputType | null
    _min: BalanceSheetMinAggregateOutputType | null
    _max: BalanceSheetMaxAggregateOutputType | null
  }

  type GetBalanceSheetGroupByPayload<T extends BalanceSheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceSheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceSheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceSheetGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceSheetGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    assets?: boolean
    liabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | BalanceSheet$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["balanceSheet"]>

  export type BalanceSheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    assets?: boolean
    liabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | BalanceSheet$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["balanceSheet"]>

  export type BalanceSheetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    assets?: boolean
    liabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | BalanceSheet$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["balanceSheet"]>

  export type BalanceSheetSelectScalar = {
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    year?: boolean
    assets?: boolean
    liabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BalanceSheetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "businessIncomeId" | "year" | "assets" | "liabilities" | "createdAt" | "updatedAt", ExtArgs["result"]["balanceSheet"]>
  export type BalanceSheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | BalanceSheet$businessIncomeArgs<ExtArgs>
  }
  export type BalanceSheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | BalanceSheet$businessIncomeArgs<ExtArgs>
  }
  export type BalanceSheetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | BalanceSheet$businessIncomeArgs<ExtArgs>
  }

  export type $BalanceSheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BalanceSheet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      businessIncome: Prisma.$BusinessIncomePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessIncomeId: string | null
      year: string | null
      assets: Prisma.JsonValue | null
      liabilities: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["balanceSheet"]>
    composites: {}
  }

  type BalanceSheetGetPayload<S extends boolean | null | undefined | BalanceSheetDefaultArgs> = $Result.GetResult<Prisma.$BalanceSheetPayload, S>

  type BalanceSheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceSheetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceSheetCountAggregateInputType | true
    }

  export interface BalanceSheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BalanceSheet'], meta: { name: 'BalanceSheet' } }
    /**
     * Find zero or one BalanceSheet that matches the filter.
     * @param {BalanceSheetFindUniqueArgs} args - Arguments to find a BalanceSheet
     * @example
     * // Get one BalanceSheet
     * const balanceSheet = await prisma.balanceSheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceSheetFindUniqueArgs>(args: SelectSubset<T, BalanceSheetFindUniqueArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BalanceSheet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceSheetFindUniqueOrThrowArgs} args - Arguments to find a BalanceSheet
     * @example
     * // Get one BalanceSheet
     * const balanceSheet = await prisma.balanceSheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceSheetFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceSheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BalanceSheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetFindFirstArgs} args - Arguments to find a BalanceSheet
     * @example
     * // Get one BalanceSheet
     * const balanceSheet = await prisma.balanceSheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceSheetFindFirstArgs>(args?: SelectSubset<T, BalanceSheetFindFirstArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BalanceSheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetFindFirstOrThrowArgs} args - Arguments to find a BalanceSheet
     * @example
     * // Get one BalanceSheet
     * const balanceSheet = await prisma.balanceSheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceSheetFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceSheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BalanceSheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BalanceSheets
     * const balanceSheets = await prisma.balanceSheet.findMany()
     * 
     * // Get first 10 BalanceSheets
     * const balanceSheets = await prisma.balanceSheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceSheetWithIdOnly = await prisma.balanceSheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceSheetFindManyArgs>(args?: SelectSubset<T, BalanceSheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BalanceSheet.
     * @param {BalanceSheetCreateArgs} args - Arguments to create a BalanceSheet.
     * @example
     * // Create one BalanceSheet
     * const BalanceSheet = await prisma.balanceSheet.create({
     *   data: {
     *     // ... data to create a BalanceSheet
     *   }
     * })
     * 
     */
    create<T extends BalanceSheetCreateArgs>(args: SelectSubset<T, BalanceSheetCreateArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BalanceSheets.
     * @param {BalanceSheetCreateManyArgs} args - Arguments to create many BalanceSheets.
     * @example
     * // Create many BalanceSheets
     * const balanceSheet = await prisma.balanceSheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceSheetCreateManyArgs>(args?: SelectSubset<T, BalanceSheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BalanceSheets and returns the data saved in the database.
     * @param {BalanceSheetCreateManyAndReturnArgs} args - Arguments to create many BalanceSheets.
     * @example
     * // Create many BalanceSheets
     * const balanceSheet = await prisma.balanceSheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BalanceSheets and only return the `id`
     * const balanceSheetWithIdOnly = await prisma.balanceSheet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceSheetCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceSheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BalanceSheet.
     * @param {BalanceSheetDeleteArgs} args - Arguments to delete one BalanceSheet.
     * @example
     * // Delete one BalanceSheet
     * const BalanceSheet = await prisma.balanceSheet.delete({
     *   where: {
     *     // ... filter to delete one BalanceSheet
     *   }
     * })
     * 
     */
    delete<T extends BalanceSheetDeleteArgs>(args: SelectSubset<T, BalanceSheetDeleteArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BalanceSheet.
     * @param {BalanceSheetUpdateArgs} args - Arguments to update one BalanceSheet.
     * @example
     * // Update one BalanceSheet
     * const balanceSheet = await prisma.balanceSheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceSheetUpdateArgs>(args: SelectSubset<T, BalanceSheetUpdateArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BalanceSheets.
     * @param {BalanceSheetDeleteManyArgs} args - Arguments to filter BalanceSheets to delete.
     * @example
     * // Delete a few BalanceSheets
     * const { count } = await prisma.balanceSheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceSheetDeleteManyArgs>(args?: SelectSubset<T, BalanceSheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BalanceSheets
     * const balanceSheet = await prisma.balanceSheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceSheetUpdateManyArgs>(args: SelectSubset<T, BalanceSheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BalanceSheets and returns the data updated in the database.
     * @param {BalanceSheetUpdateManyAndReturnArgs} args - Arguments to update many BalanceSheets.
     * @example
     * // Update many BalanceSheets
     * const balanceSheet = await prisma.balanceSheet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BalanceSheets and only return the `id`
     * const balanceSheetWithIdOnly = await prisma.balanceSheet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceSheetUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceSheetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BalanceSheet.
     * @param {BalanceSheetUpsertArgs} args - Arguments to update or create a BalanceSheet.
     * @example
     * // Update or create a BalanceSheet
     * const balanceSheet = await prisma.balanceSheet.upsert({
     *   create: {
     *     // ... data to create a BalanceSheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BalanceSheet we want to update
     *   }
     * })
     */
    upsert<T extends BalanceSheetUpsertArgs>(args: SelectSubset<T, BalanceSheetUpsertArgs<ExtArgs>>): Prisma__BalanceSheetClient<$Result.GetResult<Prisma.$BalanceSheetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BalanceSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetCountArgs} args - Arguments to filter BalanceSheets to count.
     * @example
     * // Count the number of BalanceSheets
     * const count = await prisma.balanceSheet.count({
     *   where: {
     *     // ... the filter for the BalanceSheets we want to count
     *   }
     * })
    **/
    count<T extends BalanceSheetCountArgs>(
      args?: Subset<T, BalanceSheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceSheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BalanceSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceSheetAggregateArgs>(args: Subset<T, BalanceSheetAggregateArgs>): Prisma.PrismaPromise<GetBalanceSheetAggregateType<T>>

    /**
     * Group by BalanceSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceSheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceSheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceSheetGroupByArgs['orderBy'] }
        : { orderBy?: BalanceSheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceSheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceSheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BalanceSheet model
   */
  readonly fields: BalanceSheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BalanceSheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceSheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessIncome<T extends BalanceSheet$businessIncomeArgs<ExtArgs> = {}>(args?: Subset<T, BalanceSheet$businessIncomeArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BalanceSheet model
   */
  interface BalanceSheetFieldRefs {
    readonly id: FieldRef<"BalanceSheet", 'String'>
    readonly userId: FieldRef<"BalanceSheet", 'String'>
    readonly businessIncomeId: FieldRef<"BalanceSheet", 'String'>
    readonly year: FieldRef<"BalanceSheet", 'String'>
    readonly assets: FieldRef<"BalanceSheet", 'Json'>
    readonly liabilities: FieldRef<"BalanceSheet", 'Json'>
    readonly createdAt: FieldRef<"BalanceSheet", 'DateTime'>
    readonly updatedAt: FieldRef<"BalanceSheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BalanceSheet findUnique
   */
  export type BalanceSheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * Filter, which BalanceSheet to fetch.
     */
    where: BalanceSheetWhereUniqueInput
  }

  /**
   * BalanceSheet findUniqueOrThrow
   */
  export type BalanceSheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * Filter, which BalanceSheet to fetch.
     */
    where: BalanceSheetWhereUniqueInput
  }

  /**
   * BalanceSheet findFirst
   */
  export type BalanceSheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * Filter, which BalanceSheet to fetch.
     */
    where?: BalanceSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceSheets to fetch.
     */
    orderBy?: BalanceSheetOrderByWithRelationInput | BalanceSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceSheets.
     */
    cursor?: BalanceSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceSheets.
     */
    distinct?: BalanceSheetScalarFieldEnum | BalanceSheetScalarFieldEnum[]
  }

  /**
   * BalanceSheet findFirstOrThrow
   */
  export type BalanceSheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * Filter, which BalanceSheet to fetch.
     */
    where?: BalanceSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceSheets to fetch.
     */
    orderBy?: BalanceSheetOrderByWithRelationInput | BalanceSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BalanceSheets.
     */
    cursor?: BalanceSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BalanceSheets.
     */
    distinct?: BalanceSheetScalarFieldEnum | BalanceSheetScalarFieldEnum[]
  }

  /**
   * BalanceSheet findMany
   */
  export type BalanceSheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * Filter, which BalanceSheets to fetch.
     */
    where?: BalanceSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BalanceSheets to fetch.
     */
    orderBy?: BalanceSheetOrderByWithRelationInput | BalanceSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BalanceSheets.
     */
    cursor?: BalanceSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BalanceSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BalanceSheets.
     */
    skip?: number
    distinct?: BalanceSheetScalarFieldEnum | BalanceSheetScalarFieldEnum[]
  }

  /**
   * BalanceSheet create
   */
  export type BalanceSheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * The data needed to create a BalanceSheet.
     */
    data: XOR<BalanceSheetCreateInput, BalanceSheetUncheckedCreateInput>
  }

  /**
   * BalanceSheet createMany
   */
  export type BalanceSheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BalanceSheets.
     */
    data: BalanceSheetCreateManyInput | BalanceSheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BalanceSheet createManyAndReturn
   */
  export type BalanceSheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * The data used to create many BalanceSheets.
     */
    data: BalanceSheetCreateManyInput | BalanceSheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BalanceSheet update
   */
  export type BalanceSheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * The data needed to update a BalanceSheet.
     */
    data: XOR<BalanceSheetUpdateInput, BalanceSheetUncheckedUpdateInput>
    /**
     * Choose, which BalanceSheet to update.
     */
    where: BalanceSheetWhereUniqueInput
  }

  /**
   * BalanceSheet updateMany
   */
  export type BalanceSheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BalanceSheets.
     */
    data: XOR<BalanceSheetUpdateManyMutationInput, BalanceSheetUncheckedUpdateManyInput>
    /**
     * Filter which BalanceSheets to update
     */
    where?: BalanceSheetWhereInput
    /**
     * Limit how many BalanceSheets to update.
     */
    limit?: number
  }

  /**
   * BalanceSheet updateManyAndReturn
   */
  export type BalanceSheetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * The data used to update BalanceSheets.
     */
    data: XOR<BalanceSheetUpdateManyMutationInput, BalanceSheetUncheckedUpdateManyInput>
    /**
     * Filter which BalanceSheets to update
     */
    where?: BalanceSheetWhereInput
    /**
     * Limit how many BalanceSheets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BalanceSheet upsert
   */
  export type BalanceSheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * The filter to search for the BalanceSheet to update in case it exists.
     */
    where: BalanceSheetWhereUniqueInput
    /**
     * In case the BalanceSheet found by the `where` argument doesn't exist, create a new BalanceSheet with this data.
     */
    create: XOR<BalanceSheetCreateInput, BalanceSheetUncheckedCreateInput>
    /**
     * In case the BalanceSheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceSheetUpdateInput, BalanceSheetUncheckedUpdateInput>
  }

  /**
   * BalanceSheet delete
   */
  export type BalanceSheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
    /**
     * Filter which BalanceSheet to delete.
     */
    where: BalanceSheetWhereUniqueInput
  }

  /**
   * BalanceSheet deleteMany
   */
  export type BalanceSheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BalanceSheets to delete
     */
    where?: BalanceSheetWhereInput
    /**
     * Limit how many BalanceSheets to delete.
     */
    limit?: number
  }

  /**
   * BalanceSheet.businessIncome
   */
  export type BalanceSheet$businessIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    where?: BusinessIncomeWhereInput
  }

  /**
   * BalanceSheet without action
   */
  export type BalanceSheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BalanceSheet
     */
    select?: BalanceSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BalanceSheet
     */
    omit?: BalanceSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceSheetInclude<ExtArgs> | null
  }


  /**
   * Model DepreciationEntry
   */

  export type AggregateDepreciationEntry = {
    _count: DepreciationEntryCountAggregateOutputType | null
    _avg: DepreciationEntryAvgAggregateOutputType | null
    _sum: DepreciationEntrySumAggregateOutputType | null
    _min: DepreciationEntryMinAggregateOutputType | null
    _max: DepreciationEntryMaxAggregateOutputType | null
  }

  export type DepreciationEntryAvgAggregateOutputType = {
    purchaseCost: Decimal | null
    depreciationRate: Decimal | null
    accumulatedDepreciation: Decimal | null
    writtenDownValue: Decimal | null
  }

  export type DepreciationEntrySumAggregateOutputType = {
    purchaseCost: Decimal | null
    depreciationRate: Decimal | null
    accumulatedDepreciation: Decimal | null
    writtenDownValue: Decimal | null
  }

  export type DepreciationEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    businessIncomeId: string | null
    assetName: string | null
    assetCategory: string | null
    purchaseDate: Date | null
    purchaseCost: Decimal | null
    depreciationRate: Decimal | null
    accumulatedDepreciation: Decimal | null
    writtenDownValue: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepreciationEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    businessIncomeId: string | null
    assetName: string | null
    assetCategory: string | null
    purchaseDate: Date | null
    purchaseCost: Decimal | null
    depreciationRate: Decimal | null
    accumulatedDepreciation: Decimal | null
    writtenDownValue: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepreciationEntryCountAggregateOutputType = {
    id: number
    userId: number
    businessIncomeId: number
    assetName: number
    assetCategory: number
    purchaseDate: number
    purchaseCost: number
    depreciationRate: number
    accumulatedDepreciation: number
    writtenDownValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepreciationEntryAvgAggregateInputType = {
    purchaseCost?: true
    depreciationRate?: true
    accumulatedDepreciation?: true
    writtenDownValue?: true
  }

  export type DepreciationEntrySumAggregateInputType = {
    purchaseCost?: true
    depreciationRate?: true
    accumulatedDepreciation?: true
    writtenDownValue?: true
  }

  export type DepreciationEntryMinAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    assetName?: true
    assetCategory?: true
    purchaseDate?: true
    purchaseCost?: true
    depreciationRate?: true
    accumulatedDepreciation?: true
    writtenDownValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepreciationEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    assetName?: true
    assetCategory?: true
    purchaseDate?: true
    purchaseCost?: true
    depreciationRate?: true
    accumulatedDepreciation?: true
    writtenDownValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepreciationEntryCountAggregateInputType = {
    id?: true
    userId?: true
    businessIncomeId?: true
    assetName?: true
    assetCategory?: true
    purchaseDate?: true
    purchaseCost?: true
    depreciationRate?: true
    accumulatedDepreciation?: true
    writtenDownValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepreciationEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepreciationEntry to aggregate.
     */
    where?: DepreciationEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationEntries to fetch.
     */
    orderBy?: DepreciationEntryOrderByWithRelationInput | DepreciationEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepreciationEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepreciationEntries
    **/
    _count?: true | DepreciationEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepreciationEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepreciationEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepreciationEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepreciationEntryMaxAggregateInputType
  }

  export type GetDepreciationEntryAggregateType<T extends DepreciationEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateDepreciationEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepreciationEntry[P]>
      : GetScalarType<T[P], AggregateDepreciationEntry[P]>
  }




  export type DepreciationEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepreciationEntryWhereInput
    orderBy?: DepreciationEntryOrderByWithAggregationInput | DepreciationEntryOrderByWithAggregationInput[]
    by: DepreciationEntryScalarFieldEnum[] | DepreciationEntryScalarFieldEnum
    having?: DepreciationEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepreciationEntryCountAggregateInputType | true
    _avg?: DepreciationEntryAvgAggregateInputType
    _sum?: DepreciationEntrySumAggregateInputType
    _min?: DepreciationEntryMinAggregateInputType
    _max?: DepreciationEntryMaxAggregateInputType
  }

  export type DepreciationEntryGroupByOutputType = {
    id: string
    userId: string
    businessIncomeId: string | null
    assetName: string | null
    assetCategory: string | null
    purchaseDate: Date | null
    purchaseCost: Decimal | null
    depreciationRate: Decimal | null
    accumulatedDepreciation: Decimal | null
    writtenDownValue: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: DepreciationEntryCountAggregateOutputType | null
    _avg: DepreciationEntryAvgAggregateOutputType | null
    _sum: DepreciationEntrySumAggregateOutputType | null
    _min: DepreciationEntryMinAggregateOutputType | null
    _max: DepreciationEntryMaxAggregateOutputType | null
  }

  type GetDepreciationEntryGroupByPayload<T extends DepreciationEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepreciationEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepreciationEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepreciationEntryGroupByOutputType[P]>
            : GetScalarType<T[P], DepreciationEntryGroupByOutputType[P]>
        }
      >
    >


  export type DepreciationEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    assetName?: boolean
    assetCategory?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    depreciationRate?: boolean
    accumulatedDepreciation?: boolean
    writtenDownValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | DepreciationEntry$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["depreciationEntry"]>

  export type DepreciationEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    assetName?: boolean
    assetCategory?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    depreciationRate?: boolean
    accumulatedDepreciation?: boolean
    writtenDownValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | DepreciationEntry$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["depreciationEntry"]>

  export type DepreciationEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    assetName?: boolean
    assetCategory?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    depreciationRate?: boolean
    accumulatedDepreciation?: boolean
    writtenDownValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | DepreciationEntry$businessIncomeArgs<ExtArgs>
  }, ExtArgs["result"]["depreciationEntry"]>

  export type DepreciationEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    businessIncomeId?: boolean
    assetName?: boolean
    assetCategory?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    depreciationRate?: boolean
    accumulatedDepreciation?: boolean
    writtenDownValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepreciationEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "businessIncomeId" | "assetName" | "assetCategory" | "purchaseDate" | "purchaseCost" | "depreciationRate" | "accumulatedDepreciation" | "writtenDownValue" | "createdAt" | "updatedAt", ExtArgs["result"]["depreciationEntry"]>
  export type DepreciationEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | DepreciationEntry$businessIncomeArgs<ExtArgs>
  }
  export type DepreciationEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | DepreciationEntry$businessIncomeArgs<ExtArgs>
  }
  export type DepreciationEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    businessIncome?: boolean | DepreciationEntry$businessIncomeArgs<ExtArgs>
  }

  export type $DepreciationEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepreciationEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      businessIncome: Prisma.$BusinessIncomePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      businessIncomeId: string | null
      assetName: string | null
      assetCategory: string | null
      purchaseDate: Date | null
      purchaseCost: Prisma.Decimal | null
      depreciationRate: Prisma.Decimal | null
      accumulatedDepreciation: Prisma.Decimal | null
      writtenDownValue: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["depreciationEntry"]>
    composites: {}
  }

  type DepreciationEntryGetPayload<S extends boolean | null | undefined | DepreciationEntryDefaultArgs> = $Result.GetResult<Prisma.$DepreciationEntryPayload, S>

  type DepreciationEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepreciationEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepreciationEntryCountAggregateInputType | true
    }

  export interface DepreciationEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepreciationEntry'], meta: { name: 'DepreciationEntry' } }
    /**
     * Find zero or one DepreciationEntry that matches the filter.
     * @param {DepreciationEntryFindUniqueArgs} args - Arguments to find a DepreciationEntry
     * @example
     * // Get one DepreciationEntry
     * const depreciationEntry = await prisma.depreciationEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepreciationEntryFindUniqueArgs>(args: SelectSubset<T, DepreciationEntryFindUniqueArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepreciationEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepreciationEntryFindUniqueOrThrowArgs} args - Arguments to find a DepreciationEntry
     * @example
     * // Get one DepreciationEntry
     * const depreciationEntry = await prisma.depreciationEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepreciationEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, DepreciationEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepreciationEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryFindFirstArgs} args - Arguments to find a DepreciationEntry
     * @example
     * // Get one DepreciationEntry
     * const depreciationEntry = await prisma.depreciationEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepreciationEntryFindFirstArgs>(args?: SelectSubset<T, DepreciationEntryFindFirstArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepreciationEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryFindFirstOrThrowArgs} args - Arguments to find a DepreciationEntry
     * @example
     * // Get one DepreciationEntry
     * const depreciationEntry = await prisma.depreciationEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepreciationEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, DepreciationEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepreciationEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepreciationEntries
     * const depreciationEntries = await prisma.depreciationEntry.findMany()
     * 
     * // Get first 10 DepreciationEntries
     * const depreciationEntries = await prisma.depreciationEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depreciationEntryWithIdOnly = await prisma.depreciationEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepreciationEntryFindManyArgs>(args?: SelectSubset<T, DepreciationEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepreciationEntry.
     * @param {DepreciationEntryCreateArgs} args - Arguments to create a DepreciationEntry.
     * @example
     * // Create one DepreciationEntry
     * const DepreciationEntry = await prisma.depreciationEntry.create({
     *   data: {
     *     // ... data to create a DepreciationEntry
     *   }
     * })
     * 
     */
    create<T extends DepreciationEntryCreateArgs>(args: SelectSubset<T, DepreciationEntryCreateArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepreciationEntries.
     * @param {DepreciationEntryCreateManyArgs} args - Arguments to create many DepreciationEntries.
     * @example
     * // Create many DepreciationEntries
     * const depreciationEntry = await prisma.depreciationEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepreciationEntryCreateManyArgs>(args?: SelectSubset<T, DepreciationEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepreciationEntries and returns the data saved in the database.
     * @param {DepreciationEntryCreateManyAndReturnArgs} args - Arguments to create many DepreciationEntries.
     * @example
     * // Create many DepreciationEntries
     * const depreciationEntry = await prisma.depreciationEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepreciationEntries and only return the `id`
     * const depreciationEntryWithIdOnly = await prisma.depreciationEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepreciationEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, DepreciationEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepreciationEntry.
     * @param {DepreciationEntryDeleteArgs} args - Arguments to delete one DepreciationEntry.
     * @example
     * // Delete one DepreciationEntry
     * const DepreciationEntry = await prisma.depreciationEntry.delete({
     *   where: {
     *     // ... filter to delete one DepreciationEntry
     *   }
     * })
     * 
     */
    delete<T extends DepreciationEntryDeleteArgs>(args: SelectSubset<T, DepreciationEntryDeleteArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepreciationEntry.
     * @param {DepreciationEntryUpdateArgs} args - Arguments to update one DepreciationEntry.
     * @example
     * // Update one DepreciationEntry
     * const depreciationEntry = await prisma.depreciationEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepreciationEntryUpdateArgs>(args: SelectSubset<T, DepreciationEntryUpdateArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepreciationEntries.
     * @param {DepreciationEntryDeleteManyArgs} args - Arguments to filter DepreciationEntries to delete.
     * @example
     * // Delete a few DepreciationEntries
     * const { count } = await prisma.depreciationEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepreciationEntryDeleteManyArgs>(args?: SelectSubset<T, DepreciationEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepreciationEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepreciationEntries
     * const depreciationEntry = await prisma.depreciationEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepreciationEntryUpdateManyArgs>(args: SelectSubset<T, DepreciationEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepreciationEntries and returns the data updated in the database.
     * @param {DepreciationEntryUpdateManyAndReturnArgs} args - Arguments to update many DepreciationEntries.
     * @example
     * // Update many DepreciationEntries
     * const depreciationEntry = await prisma.depreciationEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepreciationEntries and only return the `id`
     * const depreciationEntryWithIdOnly = await prisma.depreciationEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepreciationEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, DepreciationEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepreciationEntry.
     * @param {DepreciationEntryUpsertArgs} args - Arguments to update or create a DepreciationEntry.
     * @example
     * // Update or create a DepreciationEntry
     * const depreciationEntry = await prisma.depreciationEntry.upsert({
     *   create: {
     *     // ... data to create a DepreciationEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepreciationEntry we want to update
     *   }
     * })
     */
    upsert<T extends DepreciationEntryUpsertArgs>(args: SelectSubset<T, DepreciationEntryUpsertArgs<ExtArgs>>): Prisma__DepreciationEntryClient<$Result.GetResult<Prisma.$DepreciationEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepreciationEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryCountArgs} args - Arguments to filter DepreciationEntries to count.
     * @example
     * // Count the number of DepreciationEntries
     * const count = await prisma.depreciationEntry.count({
     *   where: {
     *     // ... the filter for the DepreciationEntries we want to count
     *   }
     * })
    **/
    count<T extends DepreciationEntryCountArgs>(
      args?: Subset<T, DepreciationEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepreciationEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepreciationEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepreciationEntryAggregateArgs>(args: Subset<T, DepreciationEntryAggregateArgs>): Prisma.PrismaPromise<GetDepreciationEntryAggregateType<T>>

    /**
     * Group by DepreciationEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepreciationEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepreciationEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepreciationEntryGroupByArgs['orderBy'] }
        : { orderBy?: DepreciationEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepreciationEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepreciationEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepreciationEntry model
   */
  readonly fields: DepreciationEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepreciationEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepreciationEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessIncome<T extends DepreciationEntry$businessIncomeArgs<ExtArgs> = {}>(args?: Subset<T, DepreciationEntry$businessIncomeArgs<ExtArgs>>): Prisma__BusinessIncomeClient<$Result.GetResult<Prisma.$BusinessIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepreciationEntry model
   */
  interface DepreciationEntryFieldRefs {
    readonly id: FieldRef<"DepreciationEntry", 'String'>
    readonly userId: FieldRef<"DepreciationEntry", 'String'>
    readonly businessIncomeId: FieldRef<"DepreciationEntry", 'String'>
    readonly assetName: FieldRef<"DepreciationEntry", 'String'>
    readonly assetCategory: FieldRef<"DepreciationEntry", 'String'>
    readonly purchaseDate: FieldRef<"DepreciationEntry", 'DateTime'>
    readonly purchaseCost: FieldRef<"DepreciationEntry", 'Decimal'>
    readonly depreciationRate: FieldRef<"DepreciationEntry", 'Decimal'>
    readonly accumulatedDepreciation: FieldRef<"DepreciationEntry", 'Decimal'>
    readonly writtenDownValue: FieldRef<"DepreciationEntry", 'Decimal'>
    readonly createdAt: FieldRef<"DepreciationEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"DepreciationEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepreciationEntry findUnique
   */
  export type DepreciationEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationEntry to fetch.
     */
    where: DepreciationEntryWhereUniqueInput
  }

  /**
   * DepreciationEntry findUniqueOrThrow
   */
  export type DepreciationEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationEntry to fetch.
     */
    where: DepreciationEntryWhereUniqueInput
  }

  /**
   * DepreciationEntry findFirst
   */
  export type DepreciationEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationEntry to fetch.
     */
    where?: DepreciationEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationEntries to fetch.
     */
    orderBy?: DepreciationEntryOrderByWithRelationInput | DepreciationEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepreciationEntries.
     */
    cursor?: DepreciationEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepreciationEntries.
     */
    distinct?: DepreciationEntryScalarFieldEnum | DepreciationEntryScalarFieldEnum[]
  }

  /**
   * DepreciationEntry findFirstOrThrow
   */
  export type DepreciationEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationEntry to fetch.
     */
    where?: DepreciationEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationEntries to fetch.
     */
    orderBy?: DepreciationEntryOrderByWithRelationInput | DepreciationEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepreciationEntries.
     */
    cursor?: DepreciationEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepreciationEntries.
     */
    distinct?: DepreciationEntryScalarFieldEnum | DepreciationEntryScalarFieldEnum[]
  }

  /**
   * DepreciationEntry findMany
   */
  export type DepreciationEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * Filter, which DepreciationEntries to fetch.
     */
    where?: DepreciationEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepreciationEntries to fetch.
     */
    orderBy?: DepreciationEntryOrderByWithRelationInput | DepreciationEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepreciationEntries.
     */
    cursor?: DepreciationEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepreciationEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepreciationEntries.
     */
    skip?: number
    distinct?: DepreciationEntryScalarFieldEnum | DepreciationEntryScalarFieldEnum[]
  }

  /**
   * DepreciationEntry create
   */
  export type DepreciationEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a DepreciationEntry.
     */
    data: XOR<DepreciationEntryCreateInput, DepreciationEntryUncheckedCreateInput>
  }

  /**
   * DepreciationEntry createMany
   */
  export type DepreciationEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepreciationEntries.
     */
    data: DepreciationEntryCreateManyInput | DepreciationEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepreciationEntry createManyAndReturn
   */
  export type DepreciationEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * The data used to create many DepreciationEntries.
     */
    data: DepreciationEntryCreateManyInput | DepreciationEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepreciationEntry update
   */
  export type DepreciationEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a DepreciationEntry.
     */
    data: XOR<DepreciationEntryUpdateInput, DepreciationEntryUncheckedUpdateInput>
    /**
     * Choose, which DepreciationEntry to update.
     */
    where: DepreciationEntryWhereUniqueInput
  }

  /**
   * DepreciationEntry updateMany
   */
  export type DepreciationEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepreciationEntries.
     */
    data: XOR<DepreciationEntryUpdateManyMutationInput, DepreciationEntryUncheckedUpdateManyInput>
    /**
     * Filter which DepreciationEntries to update
     */
    where?: DepreciationEntryWhereInput
    /**
     * Limit how many DepreciationEntries to update.
     */
    limit?: number
  }

  /**
   * DepreciationEntry updateManyAndReturn
   */
  export type DepreciationEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * The data used to update DepreciationEntries.
     */
    data: XOR<DepreciationEntryUpdateManyMutationInput, DepreciationEntryUncheckedUpdateManyInput>
    /**
     * Filter which DepreciationEntries to update
     */
    where?: DepreciationEntryWhereInput
    /**
     * Limit how many DepreciationEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepreciationEntry upsert
   */
  export type DepreciationEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the DepreciationEntry to update in case it exists.
     */
    where: DepreciationEntryWhereUniqueInput
    /**
     * In case the DepreciationEntry found by the `where` argument doesn't exist, create a new DepreciationEntry with this data.
     */
    create: XOR<DepreciationEntryCreateInput, DepreciationEntryUncheckedCreateInput>
    /**
     * In case the DepreciationEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepreciationEntryUpdateInput, DepreciationEntryUncheckedUpdateInput>
  }

  /**
   * DepreciationEntry delete
   */
  export type DepreciationEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
    /**
     * Filter which DepreciationEntry to delete.
     */
    where: DepreciationEntryWhereUniqueInput
  }

  /**
   * DepreciationEntry deleteMany
   */
  export type DepreciationEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepreciationEntries to delete
     */
    where?: DepreciationEntryWhereInput
    /**
     * Limit how many DepreciationEntries to delete.
     */
    limit?: number
  }

  /**
   * DepreciationEntry.businessIncome
   */
  export type DepreciationEntry$businessIncomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessIncome
     */
    select?: BusinessIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessIncome
     */
    omit?: BusinessIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncomeInclude<ExtArgs> | null
    where?: BusinessIncomeWhereInput
  }

  /**
   * DepreciationEntry without action
   */
  export type DepreciationEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepreciationEntry
     */
    select?: DepreciationEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepreciationEntry
     */
    omit?: DepreciationEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepreciationEntryInclude<ExtArgs> | null
  }


  /**
   * Model CryptoIncome
   */

  export type AggregateCryptoIncome = {
    _count: CryptoIncomeCountAggregateOutputType | null
    _avg: CryptoIncomeAvgAggregateOutputType | null
    _sum: CryptoIncomeSumAggregateOutputType | null
    _min: CryptoIncomeMinAggregateOutputType | null
    _max: CryptoIncomeMaxAggregateOutputType | null
  }

  export type CryptoIncomeAvgAggregateOutputType = {
    purchasePrice: Decimal | null
    salePrice: Decimal | null
    quantity: Decimal | null
    profit: Decimal | null
  }

  export type CryptoIncomeSumAggregateOutputType = {
    purchasePrice: Decimal | null
    salePrice: Decimal | null
    quantity: Decimal | null
    profit: Decimal | null
  }

  export type CryptoIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assetType: string | null
    coinName: string | null
    purchaseDate: Date | null
    saleDate: Date | null
    purchasePrice: Decimal | null
    salePrice: Decimal | null
    quantity: Decimal | null
    exchangeName: string | null
    transactionHash: string | null
    profit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assetType: string | null
    coinName: string | null
    purchaseDate: Date | null
    saleDate: Date | null
    purchasePrice: Decimal | null
    salePrice: Decimal | null
    quantity: Decimal | null
    exchangeName: string | null
    transactionHash: string | null
    profit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoIncomeCountAggregateOutputType = {
    id: number
    userId: number
    assetType: number
    coinName: number
    purchaseDate: number
    saleDate: number
    purchasePrice: number
    salePrice: number
    quantity: number
    exchangeName: number
    transactionHash: number
    profit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoIncomeAvgAggregateInputType = {
    purchasePrice?: true
    salePrice?: true
    quantity?: true
    profit?: true
  }

  export type CryptoIncomeSumAggregateInputType = {
    purchasePrice?: true
    salePrice?: true
    quantity?: true
    profit?: true
  }

  export type CryptoIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    assetType?: true
    coinName?: true
    purchaseDate?: true
    saleDate?: true
    purchasePrice?: true
    salePrice?: true
    quantity?: true
    exchangeName?: true
    transactionHash?: true
    profit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    assetType?: true
    coinName?: true
    purchaseDate?: true
    saleDate?: true
    purchasePrice?: true
    salePrice?: true
    quantity?: true
    exchangeName?: true
    transactionHash?: true
    profit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    assetType?: true
    coinName?: true
    purchaseDate?: true
    saleDate?: true
    purchasePrice?: true
    salePrice?: true
    quantity?: true
    exchangeName?: true
    transactionHash?: true
    profit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoIncome to aggregate.
     */
    where?: CryptoIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoIncomes to fetch.
     */
    orderBy?: CryptoIncomeOrderByWithRelationInput | CryptoIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoIncomes
    **/
    _count?: true | CryptoIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoIncomeMaxAggregateInputType
  }

  export type GetCryptoIncomeAggregateType<T extends CryptoIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoIncome[P]>
      : GetScalarType<T[P], AggregateCryptoIncome[P]>
  }




  export type CryptoIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoIncomeWhereInput
    orderBy?: CryptoIncomeOrderByWithAggregationInput | CryptoIncomeOrderByWithAggregationInput[]
    by: CryptoIncomeScalarFieldEnum[] | CryptoIncomeScalarFieldEnum
    having?: CryptoIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoIncomeCountAggregateInputType | true
    _avg?: CryptoIncomeAvgAggregateInputType
    _sum?: CryptoIncomeSumAggregateInputType
    _min?: CryptoIncomeMinAggregateInputType
    _max?: CryptoIncomeMaxAggregateInputType
  }

  export type CryptoIncomeGroupByOutputType = {
    id: string
    userId: string
    assetType: string | null
    coinName: string | null
    purchaseDate: Date | null
    saleDate: Date | null
    purchasePrice: Decimal | null
    salePrice: Decimal | null
    quantity: Decimal | null
    exchangeName: string | null
    transactionHash: string | null
    profit: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: CryptoIncomeCountAggregateOutputType | null
    _avg: CryptoIncomeAvgAggregateOutputType | null
    _sum: CryptoIncomeSumAggregateOutputType | null
    _min: CryptoIncomeMinAggregateOutputType | null
    _max: CryptoIncomeMaxAggregateOutputType | null
  }

  type GetCryptoIncomeGroupByPayload<T extends CryptoIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoIncomeGroupByOutputType[P]>
        }
      >
    >


  export type CryptoIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assetType?: boolean
    coinName?: boolean
    purchaseDate?: boolean
    saleDate?: boolean
    purchasePrice?: boolean
    salePrice?: boolean
    quantity?: boolean
    exchangeName?: boolean
    transactionHash?: boolean
    profit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoIncome"]>

  export type CryptoIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assetType?: boolean
    coinName?: boolean
    purchaseDate?: boolean
    saleDate?: boolean
    purchasePrice?: boolean
    salePrice?: boolean
    quantity?: boolean
    exchangeName?: boolean
    transactionHash?: boolean
    profit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoIncome"]>

  export type CryptoIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assetType?: boolean
    coinName?: boolean
    purchaseDate?: boolean
    saleDate?: boolean
    purchasePrice?: boolean
    salePrice?: boolean
    quantity?: boolean
    exchangeName?: boolean
    transactionHash?: boolean
    profit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoIncome"]>

  export type CryptoIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    assetType?: boolean
    coinName?: boolean
    purchaseDate?: boolean
    saleDate?: boolean
    purchasePrice?: boolean
    salePrice?: boolean
    quantity?: boolean
    exchangeName?: boolean
    transactionHash?: boolean
    profit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assetType" | "coinName" | "purchaseDate" | "saleDate" | "purchasePrice" | "salePrice" | "quantity" | "exchangeName" | "transactionHash" | "profit" | "createdAt" | "updatedAt", ExtArgs["result"]["cryptoIncome"]>
  export type CryptoIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CryptoIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CryptoIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CryptoIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assetType: string | null
      coinName: string | null
      purchaseDate: Date | null
      saleDate: Date | null
      purchasePrice: Prisma.Decimal | null
      salePrice: Prisma.Decimal | null
      quantity: Prisma.Decimal | null
      exchangeName: string | null
      transactionHash: string | null
      profit: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoIncome"]>
    composites: {}
  }

  type CryptoIncomeGetPayload<S extends boolean | null | undefined | CryptoIncomeDefaultArgs> = $Result.GetResult<Prisma.$CryptoIncomePayload, S>

  type CryptoIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CryptoIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptoIncomeCountAggregateInputType | true
    }

  export interface CryptoIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoIncome'], meta: { name: 'CryptoIncome' } }
    /**
     * Find zero or one CryptoIncome that matches the filter.
     * @param {CryptoIncomeFindUniqueArgs} args - Arguments to find a CryptoIncome
     * @example
     * // Get one CryptoIncome
     * const cryptoIncome = await prisma.cryptoIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoIncomeFindUniqueArgs>(args: SelectSubset<T, CryptoIncomeFindUniqueArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CryptoIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CryptoIncomeFindUniqueOrThrowArgs} args - Arguments to find a CryptoIncome
     * @example
     * // Get one CryptoIncome
     * const cryptoIncome = await prisma.cryptoIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeFindFirstArgs} args - Arguments to find a CryptoIncome
     * @example
     * // Get one CryptoIncome
     * const cryptoIncome = await prisma.cryptoIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoIncomeFindFirstArgs>(args?: SelectSubset<T, CryptoIncomeFindFirstArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeFindFirstOrThrowArgs} args - Arguments to find a CryptoIncome
     * @example
     * // Get one CryptoIncome
     * const cryptoIncome = await prisma.cryptoIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CryptoIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoIncomes
     * const cryptoIncomes = await prisma.cryptoIncome.findMany()
     * 
     * // Get first 10 CryptoIncomes
     * const cryptoIncomes = await prisma.cryptoIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoIncomeWithIdOnly = await prisma.cryptoIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoIncomeFindManyArgs>(args?: SelectSubset<T, CryptoIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CryptoIncome.
     * @param {CryptoIncomeCreateArgs} args - Arguments to create a CryptoIncome.
     * @example
     * // Create one CryptoIncome
     * const CryptoIncome = await prisma.cryptoIncome.create({
     *   data: {
     *     // ... data to create a CryptoIncome
     *   }
     * })
     * 
     */
    create<T extends CryptoIncomeCreateArgs>(args: SelectSubset<T, CryptoIncomeCreateArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CryptoIncomes.
     * @param {CryptoIncomeCreateManyArgs} args - Arguments to create many CryptoIncomes.
     * @example
     * // Create many CryptoIncomes
     * const cryptoIncome = await prisma.cryptoIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoIncomeCreateManyArgs>(args?: SelectSubset<T, CryptoIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoIncomes and returns the data saved in the database.
     * @param {CryptoIncomeCreateManyAndReturnArgs} args - Arguments to create many CryptoIncomes.
     * @example
     * // Create many CryptoIncomes
     * const cryptoIncome = await prisma.cryptoIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoIncomes and only return the `id`
     * const cryptoIncomeWithIdOnly = await prisma.cryptoIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CryptoIncome.
     * @param {CryptoIncomeDeleteArgs} args - Arguments to delete one CryptoIncome.
     * @example
     * // Delete one CryptoIncome
     * const CryptoIncome = await prisma.cryptoIncome.delete({
     *   where: {
     *     // ... filter to delete one CryptoIncome
     *   }
     * })
     * 
     */
    delete<T extends CryptoIncomeDeleteArgs>(args: SelectSubset<T, CryptoIncomeDeleteArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CryptoIncome.
     * @param {CryptoIncomeUpdateArgs} args - Arguments to update one CryptoIncome.
     * @example
     * // Update one CryptoIncome
     * const cryptoIncome = await prisma.cryptoIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoIncomeUpdateArgs>(args: SelectSubset<T, CryptoIncomeUpdateArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CryptoIncomes.
     * @param {CryptoIncomeDeleteManyArgs} args - Arguments to filter CryptoIncomes to delete.
     * @example
     * // Delete a few CryptoIncomes
     * const { count } = await prisma.cryptoIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoIncomeDeleteManyArgs>(args?: SelectSubset<T, CryptoIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoIncomes
     * const cryptoIncome = await prisma.cryptoIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoIncomeUpdateManyArgs>(args: SelectSubset<T, CryptoIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoIncomes and returns the data updated in the database.
     * @param {CryptoIncomeUpdateManyAndReturnArgs} args - Arguments to update many CryptoIncomes.
     * @example
     * // Update many CryptoIncomes
     * const cryptoIncome = await prisma.cryptoIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CryptoIncomes and only return the `id`
     * const cryptoIncomeWithIdOnly = await prisma.cryptoIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CryptoIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, CryptoIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CryptoIncome.
     * @param {CryptoIncomeUpsertArgs} args - Arguments to update or create a CryptoIncome.
     * @example
     * // Update or create a CryptoIncome
     * const cryptoIncome = await prisma.cryptoIncome.upsert({
     *   create: {
     *     // ... data to create a CryptoIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoIncome we want to update
     *   }
     * })
     */
    upsert<T extends CryptoIncomeUpsertArgs>(args: SelectSubset<T, CryptoIncomeUpsertArgs<ExtArgs>>): Prisma__CryptoIncomeClient<$Result.GetResult<Prisma.$CryptoIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CryptoIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeCountArgs} args - Arguments to filter CryptoIncomes to count.
     * @example
     * // Count the number of CryptoIncomes
     * const count = await prisma.cryptoIncome.count({
     *   where: {
     *     // ... the filter for the CryptoIncomes we want to count
     *   }
     * })
    **/
    count<T extends CryptoIncomeCountArgs>(
      args?: Subset<T, CryptoIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoIncomeAggregateArgs>(args: Subset<T, CryptoIncomeAggregateArgs>): Prisma.PrismaPromise<GetCryptoIncomeAggregateType<T>>

    /**
     * Group by CryptoIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoIncomeGroupByArgs['orderBy'] }
        : { orderBy?: CryptoIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoIncome model
   */
  readonly fields: CryptoIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoIncome model
   */
  interface CryptoIncomeFieldRefs {
    readonly id: FieldRef<"CryptoIncome", 'String'>
    readonly userId: FieldRef<"CryptoIncome", 'String'>
    readonly assetType: FieldRef<"CryptoIncome", 'String'>
    readonly coinName: FieldRef<"CryptoIncome", 'String'>
    readonly purchaseDate: FieldRef<"CryptoIncome", 'DateTime'>
    readonly saleDate: FieldRef<"CryptoIncome", 'DateTime'>
    readonly purchasePrice: FieldRef<"CryptoIncome", 'Decimal'>
    readonly salePrice: FieldRef<"CryptoIncome", 'Decimal'>
    readonly quantity: FieldRef<"CryptoIncome", 'Decimal'>
    readonly exchangeName: FieldRef<"CryptoIncome", 'String'>
    readonly transactionHash: FieldRef<"CryptoIncome", 'String'>
    readonly profit: FieldRef<"CryptoIncome", 'Decimal'>
    readonly createdAt: FieldRef<"CryptoIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoIncome findUnique
   */
  export type CryptoIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * Filter, which CryptoIncome to fetch.
     */
    where: CryptoIncomeWhereUniqueInput
  }

  /**
   * CryptoIncome findUniqueOrThrow
   */
  export type CryptoIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * Filter, which CryptoIncome to fetch.
     */
    where: CryptoIncomeWhereUniqueInput
  }

  /**
   * CryptoIncome findFirst
   */
  export type CryptoIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * Filter, which CryptoIncome to fetch.
     */
    where?: CryptoIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoIncomes to fetch.
     */
    orderBy?: CryptoIncomeOrderByWithRelationInput | CryptoIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoIncomes.
     */
    cursor?: CryptoIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoIncomes.
     */
    distinct?: CryptoIncomeScalarFieldEnum | CryptoIncomeScalarFieldEnum[]
  }

  /**
   * CryptoIncome findFirstOrThrow
   */
  export type CryptoIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * Filter, which CryptoIncome to fetch.
     */
    where?: CryptoIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoIncomes to fetch.
     */
    orderBy?: CryptoIncomeOrderByWithRelationInput | CryptoIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoIncomes.
     */
    cursor?: CryptoIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoIncomes.
     */
    distinct?: CryptoIncomeScalarFieldEnum | CryptoIncomeScalarFieldEnum[]
  }

  /**
   * CryptoIncome findMany
   */
  export type CryptoIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * Filter, which CryptoIncomes to fetch.
     */
    where?: CryptoIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoIncomes to fetch.
     */
    orderBy?: CryptoIncomeOrderByWithRelationInput | CryptoIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoIncomes.
     */
    cursor?: CryptoIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoIncomes.
     */
    skip?: number
    distinct?: CryptoIncomeScalarFieldEnum | CryptoIncomeScalarFieldEnum[]
  }

  /**
   * CryptoIncome create
   */
  export type CryptoIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoIncome.
     */
    data: XOR<CryptoIncomeCreateInput, CryptoIncomeUncheckedCreateInput>
  }

  /**
   * CryptoIncome createMany
   */
  export type CryptoIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoIncomes.
     */
    data: CryptoIncomeCreateManyInput | CryptoIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoIncome createManyAndReturn
   */
  export type CryptoIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many CryptoIncomes.
     */
    data: CryptoIncomeCreateManyInput | CryptoIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoIncome update
   */
  export type CryptoIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoIncome.
     */
    data: XOR<CryptoIncomeUpdateInput, CryptoIncomeUncheckedUpdateInput>
    /**
     * Choose, which CryptoIncome to update.
     */
    where: CryptoIncomeWhereUniqueInput
  }

  /**
   * CryptoIncome updateMany
   */
  export type CryptoIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoIncomes.
     */
    data: XOR<CryptoIncomeUpdateManyMutationInput, CryptoIncomeUncheckedUpdateManyInput>
    /**
     * Filter which CryptoIncomes to update
     */
    where?: CryptoIncomeWhereInput
    /**
     * Limit how many CryptoIncomes to update.
     */
    limit?: number
  }

  /**
   * CryptoIncome updateManyAndReturn
   */
  export type CryptoIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * The data used to update CryptoIncomes.
     */
    data: XOR<CryptoIncomeUpdateManyMutationInput, CryptoIncomeUncheckedUpdateManyInput>
    /**
     * Filter which CryptoIncomes to update
     */
    where?: CryptoIncomeWhereInput
    /**
     * Limit how many CryptoIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoIncome upsert
   */
  export type CryptoIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoIncome to update in case it exists.
     */
    where: CryptoIncomeWhereUniqueInput
    /**
     * In case the CryptoIncome found by the `where` argument doesn't exist, create a new CryptoIncome with this data.
     */
    create: XOR<CryptoIncomeCreateInput, CryptoIncomeUncheckedCreateInput>
    /**
     * In case the CryptoIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoIncomeUpdateInput, CryptoIncomeUncheckedUpdateInput>
  }

  /**
   * CryptoIncome delete
   */
  export type CryptoIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
    /**
     * Filter which CryptoIncome to delete.
     */
    where: CryptoIncomeWhereUniqueInput
  }

  /**
   * CryptoIncome deleteMany
   */
  export type CryptoIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoIncomes to delete
     */
    where?: CryptoIncomeWhereInput
    /**
     * Limit how many CryptoIncomes to delete.
     */
    limit?: number
  }

  /**
   * CryptoIncome without action
   */
  export type CryptoIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoIncome
     */
    select?: CryptoIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoIncome
     */
    omit?: CryptoIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoIncomeInclude<ExtArgs> | null
  }


  /**
   * Model AgriculturalIncome
   */

  export type AggregateAgriculturalIncome = {
    _count: AgriculturalIncomeCountAggregateOutputType | null
    _avg: AgriculturalIncomeAvgAggregateOutputType | null
    _sum: AgriculturalIncomeSumAggregateOutputType | null
    _min: AgriculturalIncomeMinAggregateOutputType | null
    _max: AgriculturalIncomeMaxAggregateOutputType | null
  }

  export type AgriculturalIncomeAvgAggregateOutputType = {
    landArea: Decimal | null
    annualIncome: Decimal | null
    expenses: Decimal | null
    netIncome: Decimal | null
  }

  export type AgriculturalIncomeSumAggregateOutputType = {
    landArea: Decimal | null
    annualIncome: Decimal | null
    expenses: Decimal | null
    netIncome: Decimal | null
  }

  export type AgriculturalIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    landArea: Decimal | null
    location: string | null
    cropType: string | null
    annualIncome: Decimal | null
    expenses: Decimal | null
    netIncome: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgriculturalIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    landArea: Decimal | null
    location: string | null
    cropType: string | null
    annualIncome: Decimal | null
    expenses: Decimal | null
    netIncome: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgriculturalIncomeCountAggregateOutputType = {
    id: number
    userId: number
    landArea: number
    location: number
    cropType: number
    annualIncome: number
    expenses: number
    netIncome: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgriculturalIncomeAvgAggregateInputType = {
    landArea?: true
    annualIncome?: true
    expenses?: true
    netIncome?: true
  }

  export type AgriculturalIncomeSumAggregateInputType = {
    landArea?: true
    annualIncome?: true
    expenses?: true
    netIncome?: true
  }

  export type AgriculturalIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    landArea?: true
    location?: true
    cropType?: true
    annualIncome?: true
    expenses?: true
    netIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgriculturalIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    landArea?: true
    location?: true
    cropType?: true
    annualIncome?: true
    expenses?: true
    netIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgriculturalIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    landArea?: true
    location?: true
    cropType?: true
    annualIncome?: true
    expenses?: true
    netIncome?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgriculturalIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgriculturalIncome to aggregate.
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgriculturalIncomes to fetch.
     */
    orderBy?: AgriculturalIncomeOrderByWithRelationInput | AgriculturalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgriculturalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgriculturalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgriculturalIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgriculturalIncomes
    **/
    _count?: true | AgriculturalIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgriculturalIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgriculturalIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgriculturalIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgriculturalIncomeMaxAggregateInputType
  }

  export type GetAgriculturalIncomeAggregateType<T extends AgriculturalIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateAgriculturalIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgriculturalIncome[P]>
      : GetScalarType<T[P], AggregateAgriculturalIncome[P]>
  }




  export type AgriculturalIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgriculturalIncomeWhereInput
    orderBy?: AgriculturalIncomeOrderByWithAggregationInput | AgriculturalIncomeOrderByWithAggregationInput[]
    by: AgriculturalIncomeScalarFieldEnum[] | AgriculturalIncomeScalarFieldEnum
    having?: AgriculturalIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgriculturalIncomeCountAggregateInputType | true
    _avg?: AgriculturalIncomeAvgAggregateInputType
    _sum?: AgriculturalIncomeSumAggregateInputType
    _min?: AgriculturalIncomeMinAggregateInputType
    _max?: AgriculturalIncomeMaxAggregateInputType
  }

  export type AgriculturalIncomeGroupByOutputType = {
    id: string
    userId: string
    landArea: Decimal | null
    location: string | null
    cropType: string | null
    annualIncome: Decimal | null
    expenses: Decimal | null
    netIncome: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: AgriculturalIncomeCountAggregateOutputType | null
    _avg: AgriculturalIncomeAvgAggregateOutputType | null
    _sum: AgriculturalIncomeSumAggregateOutputType | null
    _min: AgriculturalIncomeMinAggregateOutputType | null
    _max: AgriculturalIncomeMaxAggregateOutputType | null
  }

  type GetAgriculturalIncomeGroupByPayload<T extends AgriculturalIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgriculturalIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgriculturalIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgriculturalIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], AgriculturalIncomeGroupByOutputType[P]>
        }
      >
    >


  export type AgriculturalIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    landArea?: boolean
    location?: boolean
    cropType?: boolean
    annualIncome?: boolean
    expenses?: boolean
    netIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agriculturalIncome"]>

  export type AgriculturalIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    landArea?: boolean
    location?: boolean
    cropType?: boolean
    annualIncome?: boolean
    expenses?: boolean
    netIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agriculturalIncome"]>

  export type AgriculturalIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    landArea?: boolean
    location?: boolean
    cropType?: boolean
    annualIncome?: boolean
    expenses?: boolean
    netIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agriculturalIncome"]>

  export type AgriculturalIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    landArea?: boolean
    location?: boolean
    cropType?: boolean
    annualIncome?: boolean
    expenses?: boolean
    netIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgriculturalIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "landArea" | "location" | "cropType" | "annualIncome" | "expenses" | "netIncome" | "createdAt" | "updatedAt", ExtArgs["result"]["agriculturalIncome"]>
  export type AgriculturalIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgriculturalIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgriculturalIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgriculturalIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgriculturalIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      landArea: Prisma.Decimal | null
      location: string | null
      cropType: string | null
      annualIncome: Prisma.Decimal | null
      expenses: Prisma.Decimal | null
      netIncome: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agriculturalIncome"]>
    composites: {}
  }

  type AgriculturalIncomeGetPayload<S extends boolean | null | undefined | AgriculturalIncomeDefaultArgs> = $Result.GetResult<Prisma.$AgriculturalIncomePayload, S>

  type AgriculturalIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgriculturalIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgriculturalIncomeCountAggregateInputType | true
    }

  export interface AgriculturalIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgriculturalIncome'], meta: { name: 'AgriculturalIncome' } }
    /**
     * Find zero or one AgriculturalIncome that matches the filter.
     * @param {AgriculturalIncomeFindUniqueArgs} args - Arguments to find a AgriculturalIncome
     * @example
     * // Get one AgriculturalIncome
     * const agriculturalIncome = await prisma.agriculturalIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgriculturalIncomeFindUniqueArgs>(args: SelectSubset<T, AgriculturalIncomeFindUniqueArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgriculturalIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgriculturalIncomeFindUniqueOrThrowArgs} args - Arguments to find a AgriculturalIncome
     * @example
     * // Get one AgriculturalIncome
     * const agriculturalIncome = await prisma.agriculturalIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgriculturalIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, AgriculturalIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgriculturalIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeFindFirstArgs} args - Arguments to find a AgriculturalIncome
     * @example
     * // Get one AgriculturalIncome
     * const agriculturalIncome = await prisma.agriculturalIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgriculturalIncomeFindFirstArgs>(args?: SelectSubset<T, AgriculturalIncomeFindFirstArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgriculturalIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeFindFirstOrThrowArgs} args - Arguments to find a AgriculturalIncome
     * @example
     * // Get one AgriculturalIncome
     * const agriculturalIncome = await prisma.agriculturalIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgriculturalIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, AgriculturalIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgriculturalIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgriculturalIncomes
     * const agriculturalIncomes = await prisma.agriculturalIncome.findMany()
     * 
     * // Get first 10 AgriculturalIncomes
     * const agriculturalIncomes = await prisma.agriculturalIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agriculturalIncomeWithIdOnly = await prisma.agriculturalIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgriculturalIncomeFindManyArgs>(args?: SelectSubset<T, AgriculturalIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgriculturalIncome.
     * @param {AgriculturalIncomeCreateArgs} args - Arguments to create a AgriculturalIncome.
     * @example
     * // Create one AgriculturalIncome
     * const AgriculturalIncome = await prisma.agriculturalIncome.create({
     *   data: {
     *     // ... data to create a AgriculturalIncome
     *   }
     * })
     * 
     */
    create<T extends AgriculturalIncomeCreateArgs>(args: SelectSubset<T, AgriculturalIncomeCreateArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgriculturalIncomes.
     * @param {AgriculturalIncomeCreateManyArgs} args - Arguments to create many AgriculturalIncomes.
     * @example
     * // Create many AgriculturalIncomes
     * const agriculturalIncome = await prisma.agriculturalIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgriculturalIncomeCreateManyArgs>(args?: SelectSubset<T, AgriculturalIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgriculturalIncomes and returns the data saved in the database.
     * @param {AgriculturalIncomeCreateManyAndReturnArgs} args - Arguments to create many AgriculturalIncomes.
     * @example
     * // Create many AgriculturalIncomes
     * const agriculturalIncome = await prisma.agriculturalIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgriculturalIncomes and only return the `id`
     * const agriculturalIncomeWithIdOnly = await prisma.agriculturalIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgriculturalIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, AgriculturalIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgriculturalIncome.
     * @param {AgriculturalIncomeDeleteArgs} args - Arguments to delete one AgriculturalIncome.
     * @example
     * // Delete one AgriculturalIncome
     * const AgriculturalIncome = await prisma.agriculturalIncome.delete({
     *   where: {
     *     // ... filter to delete one AgriculturalIncome
     *   }
     * })
     * 
     */
    delete<T extends AgriculturalIncomeDeleteArgs>(args: SelectSubset<T, AgriculturalIncomeDeleteArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgriculturalIncome.
     * @param {AgriculturalIncomeUpdateArgs} args - Arguments to update one AgriculturalIncome.
     * @example
     * // Update one AgriculturalIncome
     * const agriculturalIncome = await prisma.agriculturalIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgriculturalIncomeUpdateArgs>(args: SelectSubset<T, AgriculturalIncomeUpdateArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgriculturalIncomes.
     * @param {AgriculturalIncomeDeleteManyArgs} args - Arguments to filter AgriculturalIncomes to delete.
     * @example
     * // Delete a few AgriculturalIncomes
     * const { count } = await prisma.agriculturalIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgriculturalIncomeDeleteManyArgs>(args?: SelectSubset<T, AgriculturalIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgriculturalIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgriculturalIncomes
     * const agriculturalIncome = await prisma.agriculturalIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgriculturalIncomeUpdateManyArgs>(args: SelectSubset<T, AgriculturalIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgriculturalIncomes and returns the data updated in the database.
     * @param {AgriculturalIncomeUpdateManyAndReturnArgs} args - Arguments to update many AgriculturalIncomes.
     * @example
     * // Update many AgriculturalIncomes
     * const agriculturalIncome = await prisma.agriculturalIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgriculturalIncomes and only return the `id`
     * const agriculturalIncomeWithIdOnly = await prisma.agriculturalIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgriculturalIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, AgriculturalIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgriculturalIncome.
     * @param {AgriculturalIncomeUpsertArgs} args - Arguments to update or create a AgriculturalIncome.
     * @example
     * // Update or create a AgriculturalIncome
     * const agriculturalIncome = await prisma.agriculturalIncome.upsert({
     *   create: {
     *     // ... data to create a AgriculturalIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgriculturalIncome we want to update
     *   }
     * })
     */
    upsert<T extends AgriculturalIncomeUpsertArgs>(args: SelectSubset<T, AgriculturalIncomeUpsertArgs<ExtArgs>>): Prisma__AgriculturalIncomeClient<$Result.GetResult<Prisma.$AgriculturalIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgriculturalIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeCountArgs} args - Arguments to filter AgriculturalIncomes to count.
     * @example
     * // Count the number of AgriculturalIncomes
     * const count = await prisma.agriculturalIncome.count({
     *   where: {
     *     // ... the filter for the AgriculturalIncomes we want to count
     *   }
     * })
    **/
    count<T extends AgriculturalIncomeCountArgs>(
      args?: Subset<T, AgriculturalIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgriculturalIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgriculturalIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgriculturalIncomeAggregateArgs>(args: Subset<T, AgriculturalIncomeAggregateArgs>): Prisma.PrismaPromise<GetAgriculturalIncomeAggregateType<T>>

    /**
     * Group by AgriculturalIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgriculturalIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgriculturalIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgriculturalIncomeGroupByArgs['orderBy'] }
        : { orderBy?: AgriculturalIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgriculturalIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgriculturalIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgriculturalIncome model
   */
  readonly fields: AgriculturalIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgriculturalIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgriculturalIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgriculturalIncome model
   */
  interface AgriculturalIncomeFieldRefs {
    readonly id: FieldRef<"AgriculturalIncome", 'String'>
    readonly userId: FieldRef<"AgriculturalIncome", 'String'>
    readonly landArea: FieldRef<"AgriculturalIncome", 'Decimal'>
    readonly location: FieldRef<"AgriculturalIncome", 'String'>
    readonly cropType: FieldRef<"AgriculturalIncome", 'String'>
    readonly annualIncome: FieldRef<"AgriculturalIncome", 'Decimal'>
    readonly expenses: FieldRef<"AgriculturalIncome", 'Decimal'>
    readonly netIncome: FieldRef<"AgriculturalIncome", 'Decimal'>
    readonly createdAt: FieldRef<"AgriculturalIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"AgriculturalIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgriculturalIncome findUnique
   */
  export type AgriculturalIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which AgriculturalIncome to fetch.
     */
    where: AgriculturalIncomeWhereUniqueInput
  }

  /**
   * AgriculturalIncome findUniqueOrThrow
   */
  export type AgriculturalIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which AgriculturalIncome to fetch.
     */
    where: AgriculturalIncomeWhereUniqueInput
  }

  /**
   * AgriculturalIncome findFirst
   */
  export type AgriculturalIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which AgriculturalIncome to fetch.
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgriculturalIncomes to fetch.
     */
    orderBy?: AgriculturalIncomeOrderByWithRelationInput | AgriculturalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgriculturalIncomes.
     */
    cursor?: AgriculturalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgriculturalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgriculturalIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgriculturalIncomes.
     */
    distinct?: AgriculturalIncomeScalarFieldEnum | AgriculturalIncomeScalarFieldEnum[]
  }

  /**
   * AgriculturalIncome findFirstOrThrow
   */
  export type AgriculturalIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which AgriculturalIncome to fetch.
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgriculturalIncomes to fetch.
     */
    orderBy?: AgriculturalIncomeOrderByWithRelationInput | AgriculturalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgriculturalIncomes.
     */
    cursor?: AgriculturalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgriculturalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgriculturalIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgriculturalIncomes.
     */
    distinct?: AgriculturalIncomeScalarFieldEnum | AgriculturalIncomeScalarFieldEnum[]
  }

  /**
   * AgriculturalIncome findMany
   */
  export type AgriculturalIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * Filter, which AgriculturalIncomes to fetch.
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgriculturalIncomes to fetch.
     */
    orderBy?: AgriculturalIncomeOrderByWithRelationInput | AgriculturalIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgriculturalIncomes.
     */
    cursor?: AgriculturalIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgriculturalIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgriculturalIncomes.
     */
    skip?: number
    distinct?: AgriculturalIncomeScalarFieldEnum | AgriculturalIncomeScalarFieldEnum[]
  }

  /**
   * AgriculturalIncome create
   */
  export type AgriculturalIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a AgriculturalIncome.
     */
    data: XOR<AgriculturalIncomeCreateInput, AgriculturalIncomeUncheckedCreateInput>
  }

  /**
   * AgriculturalIncome createMany
   */
  export type AgriculturalIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgriculturalIncomes.
     */
    data: AgriculturalIncomeCreateManyInput | AgriculturalIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgriculturalIncome createManyAndReturn
   */
  export type AgriculturalIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many AgriculturalIncomes.
     */
    data: AgriculturalIncomeCreateManyInput | AgriculturalIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgriculturalIncome update
   */
  export type AgriculturalIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a AgriculturalIncome.
     */
    data: XOR<AgriculturalIncomeUpdateInput, AgriculturalIncomeUncheckedUpdateInput>
    /**
     * Choose, which AgriculturalIncome to update.
     */
    where: AgriculturalIncomeWhereUniqueInput
  }

  /**
   * AgriculturalIncome updateMany
   */
  export type AgriculturalIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgriculturalIncomes.
     */
    data: XOR<AgriculturalIncomeUpdateManyMutationInput, AgriculturalIncomeUncheckedUpdateManyInput>
    /**
     * Filter which AgriculturalIncomes to update
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * Limit how many AgriculturalIncomes to update.
     */
    limit?: number
  }

  /**
   * AgriculturalIncome updateManyAndReturn
   */
  export type AgriculturalIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * The data used to update AgriculturalIncomes.
     */
    data: XOR<AgriculturalIncomeUpdateManyMutationInput, AgriculturalIncomeUncheckedUpdateManyInput>
    /**
     * Filter which AgriculturalIncomes to update
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * Limit how many AgriculturalIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgriculturalIncome upsert
   */
  export type AgriculturalIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the AgriculturalIncome to update in case it exists.
     */
    where: AgriculturalIncomeWhereUniqueInput
    /**
     * In case the AgriculturalIncome found by the `where` argument doesn't exist, create a new AgriculturalIncome with this data.
     */
    create: XOR<AgriculturalIncomeCreateInput, AgriculturalIncomeUncheckedCreateInput>
    /**
     * In case the AgriculturalIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgriculturalIncomeUpdateInput, AgriculturalIncomeUncheckedUpdateInput>
  }

  /**
   * AgriculturalIncome delete
   */
  export type AgriculturalIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
    /**
     * Filter which AgriculturalIncome to delete.
     */
    where: AgriculturalIncomeWhereUniqueInput
  }

  /**
   * AgriculturalIncome deleteMany
   */
  export type AgriculturalIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgriculturalIncomes to delete
     */
    where?: AgriculturalIncomeWhereInput
    /**
     * Limit how many AgriculturalIncomes to delete.
     */
    limit?: number
  }

  /**
   * AgriculturalIncome without action
   */
  export type AgriculturalIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgriculturalIncome
     */
    select?: AgriculturalIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgriculturalIncome
     */
    omit?: AgriculturalIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgriculturalIncomeInclude<ExtArgs> | null
  }


  /**
   * Model ExemptIncome
   */

  export type AggregateExemptIncome = {
    _count: ExemptIncomeCountAggregateOutputType | null
    _avg: ExemptIncomeAvgAggregateOutputType | null
    _sum: ExemptIncomeSumAggregateOutputType | null
    _min: ExemptIncomeMinAggregateOutputType | null
    _max: ExemptIncomeMaxAggregateOutputType | null
  }

  export type ExemptIncomeAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExemptIncomeSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExemptIncomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    incomeType: string | null
    description: string | null
    amount: Decimal | null
    section: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExemptIncomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    incomeType: string | null
    description: string | null
    amount: Decimal | null
    section: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExemptIncomeCountAggregateOutputType = {
    id: number
    userId: number
    incomeType: number
    description: number
    amount: number
    section: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExemptIncomeAvgAggregateInputType = {
    amount?: true
  }

  export type ExemptIncomeSumAggregateInputType = {
    amount?: true
  }

  export type ExemptIncomeMinAggregateInputType = {
    id?: true
    userId?: true
    incomeType?: true
    description?: true
    amount?: true
    section?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExemptIncomeMaxAggregateInputType = {
    id?: true
    userId?: true
    incomeType?: true
    description?: true
    amount?: true
    section?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExemptIncomeCountAggregateInputType = {
    id?: true
    userId?: true
    incomeType?: true
    description?: true
    amount?: true
    section?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExemptIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExemptIncome to aggregate.
     */
    where?: ExemptIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExemptIncomes to fetch.
     */
    orderBy?: ExemptIncomeOrderByWithRelationInput | ExemptIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExemptIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExemptIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExemptIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExemptIncomes
    **/
    _count?: true | ExemptIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExemptIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExemptIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExemptIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExemptIncomeMaxAggregateInputType
  }

  export type GetExemptIncomeAggregateType<T extends ExemptIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateExemptIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExemptIncome[P]>
      : GetScalarType<T[P], AggregateExemptIncome[P]>
  }




  export type ExemptIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExemptIncomeWhereInput
    orderBy?: ExemptIncomeOrderByWithAggregationInput | ExemptIncomeOrderByWithAggregationInput[]
    by: ExemptIncomeScalarFieldEnum[] | ExemptIncomeScalarFieldEnum
    having?: ExemptIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExemptIncomeCountAggregateInputType | true
    _avg?: ExemptIncomeAvgAggregateInputType
    _sum?: ExemptIncomeSumAggregateInputType
    _min?: ExemptIncomeMinAggregateInputType
    _max?: ExemptIncomeMaxAggregateInputType
  }

  export type ExemptIncomeGroupByOutputType = {
    id: string
    userId: string
    incomeType: string | null
    description: string | null
    amount: Decimal | null
    section: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExemptIncomeCountAggregateOutputType | null
    _avg: ExemptIncomeAvgAggregateOutputType | null
    _sum: ExemptIncomeSumAggregateOutputType | null
    _min: ExemptIncomeMinAggregateOutputType | null
    _max: ExemptIncomeMaxAggregateOutputType | null
  }

  type GetExemptIncomeGroupByPayload<T extends ExemptIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExemptIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExemptIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExemptIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], ExemptIncomeGroupByOutputType[P]>
        }
      >
    >


  export type ExemptIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    incomeType?: boolean
    description?: boolean
    amount?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exemptIncome"]>

  export type ExemptIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    incomeType?: boolean
    description?: boolean
    amount?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exemptIncome"]>

  export type ExemptIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    incomeType?: boolean
    description?: boolean
    amount?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exemptIncome"]>

  export type ExemptIncomeSelectScalar = {
    id?: boolean
    userId?: boolean
    incomeType?: boolean
    description?: boolean
    amount?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExemptIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "incomeType" | "description" | "amount" | "section" | "createdAt" | "updatedAt", ExtArgs["result"]["exemptIncome"]>
  export type ExemptIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExemptIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExemptIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExemptIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExemptIncome"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      incomeType: string | null
      description: string | null
      amount: Prisma.Decimal | null
      section: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exemptIncome"]>
    composites: {}
  }

  type ExemptIncomeGetPayload<S extends boolean | null | undefined | ExemptIncomeDefaultArgs> = $Result.GetResult<Prisma.$ExemptIncomePayload, S>

  type ExemptIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExemptIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExemptIncomeCountAggregateInputType | true
    }

  export interface ExemptIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExemptIncome'], meta: { name: 'ExemptIncome' } }
    /**
     * Find zero or one ExemptIncome that matches the filter.
     * @param {ExemptIncomeFindUniqueArgs} args - Arguments to find a ExemptIncome
     * @example
     * // Get one ExemptIncome
     * const exemptIncome = await prisma.exemptIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExemptIncomeFindUniqueArgs>(args: SelectSubset<T, ExemptIncomeFindUniqueArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExemptIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExemptIncomeFindUniqueOrThrowArgs} args - Arguments to find a ExemptIncome
     * @example
     * // Get one ExemptIncome
     * const exemptIncome = await prisma.exemptIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExemptIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, ExemptIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExemptIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeFindFirstArgs} args - Arguments to find a ExemptIncome
     * @example
     * // Get one ExemptIncome
     * const exemptIncome = await prisma.exemptIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExemptIncomeFindFirstArgs>(args?: SelectSubset<T, ExemptIncomeFindFirstArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExemptIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeFindFirstOrThrowArgs} args - Arguments to find a ExemptIncome
     * @example
     * // Get one ExemptIncome
     * const exemptIncome = await prisma.exemptIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExemptIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, ExemptIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExemptIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExemptIncomes
     * const exemptIncomes = await prisma.exemptIncome.findMany()
     * 
     * // Get first 10 ExemptIncomes
     * const exemptIncomes = await prisma.exemptIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exemptIncomeWithIdOnly = await prisma.exemptIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExemptIncomeFindManyArgs>(args?: SelectSubset<T, ExemptIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExemptIncome.
     * @param {ExemptIncomeCreateArgs} args - Arguments to create a ExemptIncome.
     * @example
     * // Create one ExemptIncome
     * const ExemptIncome = await prisma.exemptIncome.create({
     *   data: {
     *     // ... data to create a ExemptIncome
     *   }
     * })
     * 
     */
    create<T extends ExemptIncomeCreateArgs>(args: SelectSubset<T, ExemptIncomeCreateArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExemptIncomes.
     * @param {ExemptIncomeCreateManyArgs} args - Arguments to create many ExemptIncomes.
     * @example
     * // Create many ExemptIncomes
     * const exemptIncome = await prisma.exemptIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExemptIncomeCreateManyArgs>(args?: SelectSubset<T, ExemptIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExemptIncomes and returns the data saved in the database.
     * @param {ExemptIncomeCreateManyAndReturnArgs} args - Arguments to create many ExemptIncomes.
     * @example
     * // Create many ExemptIncomes
     * const exemptIncome = await prisma.exemptIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExemptIncomes and only return the `id`
     * const exemptIncomeWithIdOnly = await prisma.exemptIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExemptIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, ExemptIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExemptIncome.
     * @param {ExemptIncomeDeleteArgs} args - Arguments to delete one ExemptIncome.
     * @example
     * // Delete one ExemptIncome
     * const ExemptIncome = await prisma.exemptIncome.delete({
     *   where: {
     *     // ... filter to delete one ExemptIncome
     *   }
     * })
     * 
     */
    delete<T extends ExemptIncomeDeleteArgs>(args: SelectSubset<T, ExemptIncomeDeleteArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExemptIncome.
     * @param {ExemptIncomeUpdateArgs} args - Arguments to update one ExemptIncome.
     * @example
     * // Update one ExemptIncome
     * const exemptIncome = await prisma.exemptIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExemptIncomeUpdateArgs>(args: SelectSubset<T, ExemptIncomeUpdateArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExemptIncomes.
     * @param {ExemptIncomeDeleteManyArgs} args - Arguments to filter ExemptIncomes to delete.
     * @example
     * // Delete a few ExemptIncomes
     * const { count } = await prisma.exemptIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExemptIncomeDeleteManyArgs>(args?: SelectSubset<T, ExemptIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExemptIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExemptIncomes
     * const exemptIncome = await prisma.exemptIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExemptIncomeUpdateManyArgs>(args: SelectSubset<T, ExemptIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExemptIncomes and returns the data updated in the database.
     * @param {ExemptIncomeUpdateManyAndReturnArgs} args - Arguments to update many ExemptIncomes.
     * @example
     * // Update many ExemptIncomes
     * const exemptIncome = await prisma.exemptIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExemptIncomes and only return the `id`
     * const exemptIncomeWithIdOnly = await prisma.exemptIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExemptIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, ExemptIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExemptIncome.
     * @param {ExemptIncomeUpsertArgs} args - Arguments to update or create a ExemptIncome.
     * @example
     * // Update or create a ExemptIncome
     * const exemptIncome = await prisma.exemptIncome.upsert({
     *   create: {
     *     // ... data to create a ExemptIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExemptIncome we want to update
     *   }
     * })
     */
    upsert<T extends ExemptIncomeUpsertArgs>(args: SelectSubset<T, ExemptIncomeUpsertArgs<ExtArgs>>): Prisma__ExemptIncomeClient<$Result.GetResult<Prisma.$ExemptIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExemptIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeCountArgs} args - Arguments to filter ExemptIncomes to count.
     * @example
     * // Count the number of ExemptIncomes
     * const count = await prisma.exemptIncome.count({
     *   where: {
     *     // ... the filter for the ExemptIncomes we want to count
     *   }
     * })
    **/
    count<T extends ExemptIncomeCountArgs>(
      args?: Subset<T, ExemptIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExemptIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExemptIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExemptIncomeAggregateArgs>(args: Subset<T, ExemptIncomeAggregateArgs>): Prisma.PrismaPromise<GetExemptIncomeAggregateType<T>>

    /**
     * Group by ExemptIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExemptIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExemptIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExemptIncomeGroupByArgs['orderBy'] }
        : { orderBy?: ExemptIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExemptIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExemptIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExemptIncome model
   */
  readonly fields: ExemptIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExemptIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExemptIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExemptIncome model
   */
  interface ExemptIncomeFieldRefs {
    readonly id: FieldRef<"ExemptIncome", 'String'>
    readonly userId: FieldRef<"ExemptIncome", 'String'>
    readonly incomeType: FieldRef<"ExemptIncome", 'String'>
    readonly description: FieldRef<"ExemptIncome", 'String'>
    readonly amount: FieldRef<"ExemptIncome", 'Decimal'>
    readonly section: FieldRef<"ExemptIncome", 'String'>
    readonly createdAt: FieldRef<"ExemptIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"ExemptIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExemptIncome findUnique
   */
  export type ExemptIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ExemptIncome to fetch.
     */
    where: ExemptIncomeWhereUniqueInput
  }

  /**
   * ExemptIncome findUniqueOrThrow
   */
  export type ExemptIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ExemptIncome to fetch.
     */
    where: ExemptIncomeWhereUniqueInput
  }

  /**
   * ExemptIncome findFirst
   */
  export type ExemptIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ExemptIncome to fetch.
     */
    where?: ExemptIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExemptIncomes to fetch.
     */
    orderBy?: ExemptIncomeOrderByWithRelationInput | ExemptIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExemptIncomes.
     */
    cursor?: ExemptIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExemptIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExemptIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExemptIncomes.
     */
    distinct?: ExemptIncomeScalarFieldEnum | ExemptIncomeScalarFieldEnum[]
  }

  /**
   * ExemptIncome findFirstOrThrow
   */
  export type ExemptIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ExemptIncome to fetch.
     */
    where?: ExemptIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExemptIncomes to fetch.
     */
    orderBy?: ExemptIncomeOrderByWithRelationInput | ExemptIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExemptIncomes.
     */
    cursor?: ExemptIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExemptIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExemptIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExemptIncomes.
     */
    distinct?: ExemptIncomeScalarFieldEnum | ExemptIncomeScalarFieldEnum[]
  }

  /**
   * ExemptIncome findMany
   */
  export type ExemptIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * Filter, which ExemptIncomes to fetch.
     */
    where?: ExemptIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExemptIncomes to fetch.
     */
    orderBy?: ExemptIncomeOrderByWithRelationInput | ExemptIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExemptIncomes.
     */
    cursor?: ExemptIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExemptIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExemptIncomes.
     */
    skip?: number
    distinct?: ExemptIncomeScalarFieldEnum | ExemptIncomeScalarFieldEnum[]
  }

  /**
   * ExemptIncome create
   */
  export type ExemptIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a ExemptIncome.
     */
    data: XOR<ExemptIncomeCreateInput, ExemptIncomeUncheckedCreateInput>
  }

  /**
   * ExemptIncome createMany
   */
  export type ExemptIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExemptIncomes.
     */
    data: ExemptIncomeCreateManyInput | ExemptIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExemptIncome createManyAndReturn
   */
  export type ExemptIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many ExemptIncomes.
     */
    data: ExemptIncomeCreateManyInput | ExemptIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExemptIncome update
   */
  export type ExemptIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a ExemptIncome.
     */
    data: XOR<ExemptIncomeUpdateInput, ExemptIncomeUncheckedUpdateInput>
    /**
     * Choose, which ExemptIncome to update.
     */
    where: ExemptIncomeWhereUniqueInput
  }

  /**
   * ExemptIncome updateMany
   */
  export type ExemptIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExemptIncomes.
     */
    data: XOR<ExemptIncomeUpdateManyMutationInput, ExemptIncomeUncheckedUpdateManyInput>
    /**
     * Filter which ExemptIncomes to update
     */
    where?: ExemptIncomeWhereInput
    /**
     * Limit how many ExemptIncomes to update.
     */
    limit?: number
  }

  /**
   * ExemptIncome updateManyAndReturn
   */
  export type ExemptIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * The data used to update ExemptIncomes.
     */
    data: XOR<ExemptIncomeUpdateManyMutationInput, ExemptIncomeUncheckedUpdateManyInput>
    /**
     * Filter which ExemptIncomes to update
     */
    where?: ExemptIncomeWhereInput
    /**
     * Limit how many ExemptIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExemptIncome upsert
   */
  export type ExemptIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the ExemptIncome to update in case it exists.
     */
    where: ExemptIncomeWhereUniqueInput
    /**
     * In case the ExemptIncome found by the `where` argument doesn't exist, create a new ExemptIncome with this data.
     */
    create: XOR<ExemptIncomeCreateInput, ExemptIncomeUncheckedCreateInput>
    /**
     * In case the ExemptIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExemptIncomeUpdateInput, ExemptIncomeUncheckedUpdateInput>
  }

  /**
   * ExemptIncome delete
   */
  export type ExemptIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
    /**
     * Filter which ExemptIncome to delete.
     */
    where: ExemptIncomeWhereUniqueInput
  }

  /**
   * ExemptIncome deleteMany
   */
  export type ExemptIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExemptIncomes to delete
     */
    where?: ExemptIncomeWhereInput
    /**
     * Limit how many ExemptIncomes to delete.
     */
    limit?: number
  }

  /**
   * ExemptIncome without action
   */
  export type ExemptIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExemptIncome
     */
    select?: ExemptIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExemptIncome
     */
    omit?: ExemptIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExemptIncomeInclude<ExtArgs> | null
  }


  /**
   * Model TaxSavingInvestment
   */

  export type AggregateTaxSavingInvestment = {
    _count: TaxSavingInvestmentCountAggregateOutputType | null
    _avg: TaxSavingInvestmentAvgAggregateOutputType | null
    _sum: TaxSavingInvestmentSumAggregateOutputType | null
    _min: TaxSavingInvestmentMinAggregateOutputType | null
    _max: TaxSavingInvestmentMaxAggregateOutputType | null
  }

  export type TaxSavingInvestmentAvgAggregateOutputType = {
    section80C: Decimal | null
    savingsInterest80TTA: Decimal | null
    pensionContribution80CCC: Decimal | null
    npsEmployeeContribution: Decimal | null
    npsEmployerContribution: Decimal | null
  }

  export type TaxSavingInvestmentSumAggregateOutputType = {
    section80C: Decimal | null
    savingsInterest80TTA: Decimal | null
    pensionContribution80CCC: Decimal | null
    npsEmployeeContribution: Decimal | null
    npsEmployerContribution: Decimal | null
  }

  export type TaxSavingInvestmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    section80C: Decimal | null
    savingsInterest80TTA: Decimal | null
    pensionContribution80CCC: Decimal | null
    npsEmployeeContribution: Decimal | null
    npsEmployerContribution: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxSavingInvestmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    section80C: Decimal | null
    savingsInterest80TTA: Decimal | null
    pensionContribution80CCC: Decimal | null
    npsEmployeeContribution: Decimal | null
    npsEmployerContribution: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxSavingInvestmentCountAggregateOutputType = {
    id: number
    userId: number
    section80C: number
    savingsInterest80TTA: number
    pensionContribution80CCC: number
    npsEmployeeContribution: number
    npsEmployerContribution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxSavingInvestmentAvgAggregateInputType = {
    section80C?: true
    savingsInterest80TTA?: true
    pensionContribution80CCC?: true
    npsEmployeeContribution?: true
    npsEmployerContribution?: true
  }

  export type TaxSavingInvestmentSumAggregateInputType = {
    section80C?: true
    savingsInterest80TTA?: true
    pensionContribution80CCC?: true
    npsEmployeeContribution?: true
    npsEmployerContribution?: true
  }

  export type TaxSavingInvestmentMinAggregateInputType = {
    id?: true
    userId?: true
    section80C?: true
    savingsInterest80TTA?: true
    pensionContribution80CCC?: true
    npsEmployeeContribution?: true
    npsEmployerContribution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxSavingInvestmentMaxAggregateInputType = {
    id?: true
    userId?: true
    section80C?: true
    savingsInterest80TTA?: true
    pensionContribution80CCC?: true
    npsEmployeeContribution?: true
    npsEmployerContribution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxSavingInvestmentCountAggregateInputType = {
    id?: true
    userId?: true
    section80C?: true
    savingsInterest80TTA?: true
    pensionContribution80CCC?: true
    npsEmployeeContribution?: true
    npsEmployerContribution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxSavingInvestmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSavingInvestment to aggregate.
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSavingInvestments to fetch.
     */
    orderBy?: TaxSavingInvestmentOrderByWithRelationInput | TaxSavingInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxSavingInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSavingInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSavingInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxSavingInvestments
    **/
    _count?: true | TaxSavingInvestmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxSavingInvestmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxSavingInvestmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxSavingInvestmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxSavingInvestmentMaxAggregateInputType
  }

  export type GetTaxSavingInvestmentAggregateType<T extends TaxSavingInvestmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxSavingInvestment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxSavingInvestment[P]>
      : GetScalarType<T[P], AggregateTaxSavingInvestment[P]>
  }




  export type TaxSavingInvestmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxSavingInvestmentWhereInput
    orderBy?: TaxSavingInvestmentOrderByWithAggregationInput | TaxSavingInvestmentOrderByWithAggregationInput[]
    by: TaxSavingInvestmentScalarFieldEnum[] | TaxSavingInvestmentScalarFieldEnum
    having?: TaxSavingInvestmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxSavingInvestmentCountAggregateInputType | true
    _avg?: TaxSavingInvestmentAvgAggregateInputType
    _sum?: TaxSavingInvestmentSumAggregateInputType
    _min?: TaxSavingInvestmentMinAggregateInputType
    _max?: TaxSavingInvestmentMaxAggregateInputType
  }

  export type TaxSavingInvestmentGroupByOutputType = {
    id: string
    userId: string
    section80C: Decimal
    savingsInterest80TTA: Decimal
    pensionContribution80CCC: Decimal
    npsEmployeeContribution: Decimal
    npsEmployerContribution: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TaxSavingInvestmentCountAggregateOutputType | null
    _avg: TaxSavingInvestmentAvgAggregateOutputType | null
    _sum: TaxSavingInvestmentSumAggregateOutputType | null
    _min: TaxSavingInvestmentMinAggregateOutputType | null
    _max: TaxSavingInvestmentMaxAggregateOutputType | null
  }

  type GetTaxSavingInvestmentGroupByPayload<T extends TaxSavingInvestmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxSavingInvestmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxSavingInvestmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxSavingInvestmentGroupByOutputType[P]>
            : GetScalarType<T[P], TaxSavingInvestmentGroupByOutputType[P]>
        }
      >
    >


  export type TaxSavingInvestmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    section80C?: boolean
    savingsInterest80TTA?: boolean
    pensionContribution80CCC?: boolean
    npsEmployeeContribution?: boolean
    npsEmployerContribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSavingInvestment"]>

  export type TaxSavingInvestmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    section80C?: boolean
    savingsInterest80TTA?: boolean
    pensionContribution80CCC?: boolean
    npsEmployeeContribution?: boolean
    npsEmployerContribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSavingInvestment"]>

  export type TaxSavingInvestmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    section80C?: boolean
    savingsInterest80TTA?: boolean
    pensionContribution80CCC?: boolean
    npsEmployeeContribution?: boolean
    npsEmployerContribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSavingInvestment"]>

  export type TaxSavingInvestmentSelectScalar = {
    id?: boolean
    userId?: boolean
    section80C?: boolean
    savingsInterest80TTA?: boolean
    pensionContribution80CCC?: boolean
    npsEmployeeContribution?: boolean
    npsEmployerContribution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxSavingInvestmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "section80C" | "savingsInterest80TTA" | "pensionContribution80CCC" | "npsEmployeeContribution" | "npsEmployerContribution" | "createdAt" | "updatedAt", ExtArgs["result"]["taxSavingInvestment"]>
  export type TaxSavingInvestmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxSavingInvestmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxSavingInvestmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaxSavingInvestmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxSavingInvestment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      section80C: Prisma.Decimal
      savingsInterest80TTA: Prisma.Decimal
      pensionContribution80CCC: Prisma.Decimal
      npsEmployeeContribution: Prisma.Decimal
      npsEmployerContribution: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxSavingInvestment"]>
    composites: {}
  }

  type TaxSavingInvestmentGetPayload<S extends boolean | null | undefined | TaxSavingInvestmentDefaultArgs> = $Result.GetResult<Prisma.$TaxSavingInvestmentPayload, S>

  type TaxSavingInvestmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxSavingInvestmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxSavingInvestmentCountAggregateInputType | true
    }

  export interface TaxSavingInvestmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxSavingInvestment'], meta: { name: 'TaxSavingInvestment' } }
    /**
     * Find zero or one TaxSavingInvestment that matches the filter.
     * @param {TaxSavingInvestmentFindUniqueArgs} args - Arguments to find a TaxSavingInvestment
     * @example
     * // Get one TaxSavingInvestment
     * const taxSavingInvestment = await prisma.taxSavingInvestment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxSavingInvestmentFindUniqueArgs>(args: SelectSubset<T, TaxSavingInvestmentFindUniqueArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxSavingInvestment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxSavingInvestmentFindUniqueOrThrowArgs} args - Arguments to find a TaxSavingInvestment
     * @example
     * // Get one TaxSavingInvestment
     * const taxSavingInvestment = await prisma.taxSavingInvestment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxSavingInvestmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxSavingInvestmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxSavingInvestment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentFindFirstArgs} args - Arguments to find a TaxSavingInvestment
     * @example
     * // Get one TaxSavingInvestment
     * const taxSavingInvestment = await prisma.taxSavingInvestment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxSavingInvestmentFindFirstArgs>(args?: SelectSubset<T, TaxSavingInvestmentFindFirstArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxSavingInvestment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentFindFirstOrThrowArgs} args - Arguments to find a TaxSavingInvestment
     * @example
     * // Get one TaxSavingInvestment
     * const taxSavingInvestment = await prisma.taxSavingInvestment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxSavingInvestmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxSavingInvestmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxSavingInvestments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxSavingInvestments
     * const taxSavingInvestments = await prisma.taxSavingInvestment.findMany()
     * 
     * // Get first 10 TaxSavingInvestments
     * const taxSavingInvestments = await prisma.taxSavingInvestment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxSavingInvestmentWithIdOnly = await prisma.taxSavingInvestment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxSavingInvestmentFindManyArgs>(args?: SelectSubset<T, TaxSavingInvestmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxSavingInvestment.
     * @param {TaxSavingInvestmentCreateArgs} args - Arguments to create a TaxSavingInvestment.
     * @example
     * // Create one TaxSavingInvestment
     * const TaxSavingInvestment = await prisma.taxSavingInvestment.create({
     *   data: {
     *     // ... data to create a TaxSavingInvestment
     *   }
     * })
     * 
     */
    create<T extends TaxSavingInvestmentCreateArgs>(args: SelectSubset<T, TaxSavingInvestmentCreateArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxSavingInvestments.
     * @param {TaxSavingInvestmentCreateManyArgs} args - Arguments to create many TaxSavingInvestments.
     * @example
     * // Create many TaxSavingInvestments
     * const taxSavingInvestment = await prisma.taxSavingInvestment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxSavingInvestmentCreateManyArgs>(args?: SelectSubset<T, TaxSavingInvestmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxSavingInvestments and returns the data saved in the database.
     * @param {TaxSavingInvestmentCreateManyAndReturnArgs} args - Arguments to create many TaxSavingInvestments.
     * @example
     * // Create many TaxSavingInvestments
     * const taxSavingInvestment = await prisma.taxSavingInvestment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxSavingInvestments and only return the `id`
     * const taxSavingInvestmentWithIdOnly = await prisma.taxSavingInvestment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxSavingInvestmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxSavingInvestmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxSavingInvestment.
     * @param {TaxSavingInvestmentDeleteArgs} args - Arguments to delete one TaxSavingInvestment.
     * @example
     * // Delete one TaxSavingInvestment
     * const TaxSavingInvestment = await prisma.taxSavingInvestment.delete({
     *   where: {
     *     // ... filter to delete one TaxSavingInvestment
     *   }
     * })
     * 
     */
    delete<T extends TaxSavingInvestmentDeleteArgs>(args: SelectSubset<T, TaxSavingInvestmentDeleteArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxSavingInvestment.
     * @param {TaxSavingInvestmentUpdateArgs} args - Arguments to update one TaxSavingInvestment.
     * @example
     * // Update one TaxSavingInvestment
     * const taxSavingInvestment = await prisma.taxSavingInvestment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxSavingInvestmentUpdateArgs>(args: SelectSubset<T, TaxSavingInvestmentUpdateArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxSavingInvestments.
     * @param {TaxSavingInvestmentDeleteManyArgs} args - Arguments to filter TaxSavingInvestments to delete.
     * @example
     * // Delete a few TaxSavingInvestments
     * const { count } = await prisma.taxSavingInvestment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxSavingInvestmentDeleteManyArgs>(args?: SelectSubset<T, TaxSavingInvestmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSavingInvestments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxSavingInvestments
     * const taxSavingInvestment = await prisma.taxSavingInvestment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxSavingInvestmentUpdateManyArgs>(args: SelectSubset<T, TaxSavingInvestmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSavingInvestments and returns the data updated in the database.
     * @param {TaxSavingInvestmentUpdateManyAndReturnArgs} args - Arguments to update many TaxSavingInvestments.
     * @example
     * // Update many TaxSavingInvestments
     * const taxSavingInvestment = await prisma.taxSavingInvestment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxSavingInvestments and only return the `id`
     * const taxSavingInvestmentWithIdOnly = await prisma.taxSavingInvestment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxSavingInvestmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxSavingInvestmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxSavingInvestment.
     * @param {TaxSavingInvestmentUpsertArgs} args - Arguments to update or create a TaxSavingInvestment.
     * @example
     * // Update or create a TaxSavingInvestment
     * const taxSavingInvestment = await prisma.taxSavingInvestment.upsert({
     *   create: {
     *     // ... data to create a TaxSavingInvestment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxSavingInvestment we want to update
     *   }
     * })
     */
    upsert<T extends TaxSavingInvestmentUpsertArgs>(args: SelectSubset<T, TaxSavingInvestmentUpsertArgs<ExtArgs>>): Prisma__TaxSavingInvestmentClient<$Result.GetResult<Prisma.$TaxSavingInvestmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxSavingInvestments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentCountArgs} args - Arguments to filter TaxSavingInvestments to count.
     * @example
     * // Count the number of TaxSavingInvestments
     * const count = await prisma.taxSavingInvestment.count({
     *   where: {
     *     // ... the filter for the TaxSavingInvestments we want to count
     *   }
     * })
    **/
    count<T extends TaxSavingInvestmentCountArgs>(
      args?: Subset<T, TaxSavingInvestmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxSavingInvestmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxSavingInvestment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxSavingInvestmentAggregateArgs>(args: Subset<T, TaxSavingInvestmentAggregateArgs>): Prisma.PrismaPromise<GetTaxSavingInvestmentAggregateType<T>>

    /**
     * Group by TaxSavingInvestment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSavingInvestmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxSavingInvestmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxSavingInvestmentGroupByArgs['orderBy'] }
        : { orderBy?: TaxSavingInvestmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxSavingInvestmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxSavingInvestmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxSavingInvestment model
   */
  readonly fields: TaxSavingInvestmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxSavingInvestment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxSavingInvestmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxSavingInvestment model
   */
  interface TaxSavingInvestmentFieldRefs {
    readonly id: FieldRef<"TaxSavingInvestment", 'String'>
    readonly userId: FieldRef<"TaxSavingInvestment", 'String'>
    readonly section80C: FieldRef<"TaxSavingInvestment", 'Decimal'>
    readonly savingsInterest80TTA: FieldRef<"TaxSavingInvestment", 'Decimal'>
    readonly pensionContribution80CCC: FieldRef<"TaxSavingInvestment", 'Decimal'>
    readonly npsEmployeeContribution: FieldRef<"TaxSavingInvestment", 'Decimal'>
    readonly npsEmployerContribution: FieldRef<"TaxSavingInvestment", 'Decimal'>
    readonly createdAt: FieldRef<"TaxSavingInvestment", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxSavingInvestment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxSavingInvestment findUnique
   */
  export type TaxSavingInvestmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which TaxSavingInvestment to fetch.
     */
    where: TaxSavingInvestmentWhereUniqueInput
  }

  /**
   * TaxSavingInvestment findUniqueOrThrow
   */
  export type TaxSavingInvestmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which TaxSavingInvestment to fetch.
     */
    where: TaxSavingInvestmentWhereUniqueInput
  }

  /**
   * TaxSavingInvestment findFirst
   */
  export type TaxSavingInvestmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which TaxSavingInvestment to fetch.
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSavingInvestments to fetch.
     */
    orderBy?: TaxSavingInvestmentOrderByWithRelationInput | TaxSavingInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSavingInvestments.
     */
    cursor?: TaxSavingInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSavingInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSavingInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSavingInvestments.
     */
    distinct?: TaxSavingInvestmentScalarFieldEnum | TaxSavingInvestmentScalarFieldEnum[]
  }

  /**
   * TaxSavingInvestment findFirstOrThrow
   */
  export type TaxSavingInvestmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which TaxSavingInvestment to fetch.
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSavingInvestments to fetch.
     */
    orderBy?: TaxSavingInvestmentOrderByWithRelationInput | TaxSavingInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSavingInvestments.
     */
    cursor?: TaxSavingInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSavingInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSavingInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSavingInvestments.
     */
    distinct?: TaxSavingInvestmentScalarFieldEnum | TaxSavingInvestmentScalarFieldEnum[]
  }

  /**
   * TaxSavingInvestment findMany
   */
  export type TaxSavingInvestmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which TaxSavingInvestments to fetch.
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSavingInvestments to fetch.
     */
    orderBy?: TaxSavingInvestmentOrderByWithRelationInput | TaxSavingInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxSavingInvestments.
     */
    cursor?: TaxSavingInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSavingInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSavingInvestments.
     */
    skip?: number
    distinct?: TaxSavingInvestmentScalarFieldEnum | TaxSavingInvestmentScalarFieldEnum[]
  }

  /**
   * TaxSavingInvestment create
   */
  export type TaxSavingInvestmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxSavingInvestment.
     */
    data: XOR<TaxSavingInvestmentCreateInput, TaxSavingInvestmentUncheckedCreateInput>
  }

  /**
   * TaxSavingInvestment createMany
   */
  export type TaxSavingInvestmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxSavingInvestments.
     */
    data: TaxSavingInvestmentCreateManyInput | TaxSavingInvestmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxSavingInvestment createManyAndReturn
   */
  export type TaxSavingInvestmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * The data used to create many TaxSavingInvestments.
     */
    data: TaxSavingInvestmentCreateManyInput | TaxSavingInvestmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxSavingInvestment update
   */
  export type TaxSavingInvestmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxSavingInvestment.
     */
    data: XOR<TaxSavingInvestmentUpdateInput, TaxSavingInvestmentUncheckedUpdateInput>
    /**
     * Choose, which TaxSavingInvestment to update.
     */
    where: TaxSavingInvestmentWhereUniqueInput
  }

  /**
   * TaxSavingInvestment updateMany
   */
  export type TaxSavingInvestmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxSavingInvestments.
     */
    data: XOR<TaxSavingInvestmentUpdateManyMutationInput, TaxSavingInvestmentUncheckedUpdateManyInput>
    /**
     * Filter which TaxSavingInvestments to update
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * Limit how many TaxSavingInvestments to update.
     */
    limit?: number
  }

  /**
   * TaxSavingInvestment updateManyAndReturn
   */
  export type TaxSavingInvestmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * The data used to update TaxSavingInvestments.
     */
    data: XOR<TaxSavingInvestmentUpdateManyMutationInput, TaxSavingInvestmentUncheckedUpdateManyInput>
    /**
     * Filter which TaxSavingInvestments to update
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * Limit how many TaxSavingInvestments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxSavingInvestment upsert
   */
  export type TaxSavingInvestmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxSavingInvestment to update in case it exists.
     */
    where: TaxSavingInvestmentWhereUniqueInput
    /**
     * In case the TaxSavingInvestment found by the `where` argument doesn't exist, create a new TaxSavingInvestment with this data.
     */
    create: XOR<TaxSavingInvestmentCreateInput, TaxSavingInvestmentUncheckedCreateInput>
    /**
     * In case the TaxSavingInvestment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxSavingInvestmentUpdateInput, TaxSavingInvestmentUncheckedUpdateInput>
  }

  /**
   * TaxSavingInvestment delete
   */
  export type TaxSavingInvestmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
    /**
     * Filter which TaxSavingInvestment to delete.
     */
    where: TaxSavingInvestmentWhereUniqueInput
  }

  /**
   * TaxSavingInvestment deleteMany
   */
  export type TaxSavingInvestmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSavingInvestments to delete
     */
    where?: TaxSavingInvestmentWhereInput
    /**
     * Limit how many TaxSavingInvestments to delete.
     */
    limit?: number
  }

  /**
   * TaxSavingInvestment without action
   */
  export type TaxSavingInvestmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSavingInvestment
     */
    select?: TaxSavingInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSavingInvestment
     */
    omit?: TaxSavingInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSavingInvestmentInclude<ExtArgs> | null
  }


  /**
   * Model Donation
   */

  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    amount: Decimal | null
    eligibleAmount: Decimal | null
    deductionPercentage: Decimal | null
  }

  export type DonationSumAggregateOutputType = {
    amount: Decimal | null
    eligibleAmount: Decimal | null
    deductionPercentage: Decimal | null
  }

  export type DonationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationName: string | null
    donationType: string | null
    amount: Decimal | null
    date: Date | null
    receiptNumber: string | null
    eligibleAmount: Decimal | null
    deductionPercentage: Decimal | null
    section: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationName: string | null
    donationType: string | null
    amount: Decimal | null
    date: Date | null
    receiptNumber: string | null
    eligibleAmount: Decimal | null
    deductionPercentage: Decimal | null
    section: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    userId: number
    organizationName: number
    donationType: number
    amount: number
    date: number
    receiptNumber: number
    eligibleAmount: number
    deductionPercentage: number
    section: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    amount?: true
    eligibleAmount?: true
    deductionPercentage?: true
  }

  export type DonationSumAggregateInputType = {
    amount?: true
    eligibleAmount?: true
    deductionPercentage?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    userId?: true
    organizationName?: true
    donationType?: true
    amount?: true
    date?: true
    receiptNumber?: true
    eligibleAmount?: true
    deductionPercentage?: true
    section?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationName?: true
    donationType?: true
    amount?: true
    date?: true
    receiptNumber?: true
    eligibleAmount?: true
    deductionPercentage?: true
    section?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    userId?: true
    organizationName?: true
    donationType?: true
    amount?: true
    date?: true
    receiptNumber?: true
    eligibleAmount?: true
    deductionPercentage?: true
    section?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DonationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donation to aggregate.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithAggregationInput | DonationOrderByWithAggregationInput[]
    by: DonationScalarFieldEnum[] | DonationScalarFieldEnum
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }

  export type DonationGroupByOutputType = {
    id: string
    userId: string
    organizationName: string | null
    donationType: string | null
    amount: Decimal | null
    date: Date | null
    receiptNumber: string | null
    eligibleAmount: Decimal | null
    deductionPercentage: Decimal | null
    section: string | null
    createdAt: Date
    updatedAt: Date
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationName?: boolean
    donationType?: boolean
    amount?: boolean
    date?: boolean
    receiptNumber?: boolean
    eligibleAmount?: boolean
    deductionPercentage?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationName?: boolean
    donationType?: boolean
    amount?: boolean
    date?: boolean
    receiptNumber?: boolean
    eligibleAmount?: boolean
    deductionPercentage?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationName?: boolean
    donationType?: boolean
    amount?: boolean
    date?: boolean
    receiptNumber?: boolean
    eligibleAmount?: boolean
    deductionPercentage?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationName?: boolean
    donationType?: boolean
    amount?: boolean
    date?: boolean
    receiptNumber?: boolean
    eligibleAmount?: boolean
    deductionPercentage?: boolean
    section?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DonationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "organizationName" | "donationType" | "amount" | "date" | "receiptNumber" | "eligibleAmount" | "deductionPercentage" | "section" | "createdAt" | "updatedAt", ExtArgs["result"]["donation"]>
  export type DonationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DonationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DonationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DonationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationName: string | null
      donationType: string | null
      amount: Prisma.Decimal | null
      date: Date | null
      receiptNumber: string | null
      eligibleAmount: Prisma.Decimal | null
      deductionPercentage: Prisma.Decimal | null
      section: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["donation"]>
    composites: {}
  }

  type DonationGetPayload<S extends boolean | null | undefined | DonationDefaultArgs> = $Result.GetResult<Prisma.$DonationPayload, S>

  type DonationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonationCountAggregateInputType | true
    }

  export interface DonationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donation'], meta: { name: 'Donation' } }
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonationFindUniqueArgs>(args: SelectSubset<T, DonationFindUniqueArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonationFindUniqueOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonationFindUniqueOrThrowArgs>(args: SelectSubset<T, DonationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonationFindFirstArgs>(args?: SelectSubset<T, DonationFindFirstArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonationFindFirstOrThrowArgs>(args?: SelectSubset<T, DonationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonationFindManyArgs>(args?: SelectSubset<T, DonationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     * 
     */
    create<T extends DonationCreateArgs>(args: SelectSubset<T, DonationCreateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donations.
     * @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donation = await prisma.donation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonationCreateManyArgs>(args?: SelectSubset<T, DonationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Donations and returns the data saved in the database.
     * @param {DonationCreateManyAndReturnArgs} args - Arguments to create many Donations.
     * @example
     * // Create many Donations
     * const donation = await prisma.donation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Donations and only return the `id`
     * const donationWithIdOnly = await prisma.donation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DonationCreateManyAndReturnArgs>(args?: SelectSubset<T, DonationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     * 
     */
    delete<T extends DonationDeleteArgs>(args: SelectSubset<T, DonationDeleteArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonationUpdateArgs>(args: SelectSubset<T, DonationUpdateArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonationDeleteManyArgs>(args?: SelectSubset<T, DonationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonationUpdateManyArgs>(args: SelectSubset<T, DonationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations and returns the data updated in the database.
     * @param {DonationUpdateManyAndReturnArgs} args - Arguments to update many Donations.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Donations and only return the `id`
     * const donationWithIdOnly = await prisma.donation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DonationUpdateManyAndReturnArgs>(args: SelectSubset<T, DonationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
     */
    upsert<T extends DonationUpsertArgs>(args: SelectSubset<T, DonationUpsertArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): Prisma.PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donation model
   */
  readonly fields: DonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donation model
   */
  interface DonationFieldRefs {
    readonly id: FieldRef<"Donation", 'String'>
    readonly userId: FieldRef<"Donation", 'String'>
    readonly organizationName: FieldRef<"Donation", 'String'>
    readonly donationType: FieldRef<"Donation", 'String'>
    readonly amount: FieldRef<"Donation", 'Decimal'>
    readonly date: FieldRef<"Donation", 'DateTime'>
    readonly receiptNumber: FieldRef<"Donation", 'String'>
    readonly eligibleAmount: FieldRef<"Donation", 'Decimal'>
    readonly deductionPercentage: FieldRef<"Donation", 'Decimal'>
    readonly section: FieldRef<"Donation", 'String'>
    readonly createdAt: FieldRef<"Donation", 'DateTime'>
    readonly updatedAt: FieldRef<"Donation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findUniqueOrThrow
   */
  export type DonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findFirstOrThrow
   */
  export type DonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation findMany
   */
  export type DonationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donations to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }

  /**
   * Donation create
   */
  export type DonationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to create a Donation.
     */
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }

  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donation createManyAndReturn
   */
  export type DonationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donation update
   */
  export type DonationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to update a Donation.
     */
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to update.
     */
    limit?: number
  }

  /**
   * Donation updateManyAndReturn
   */
  export type DonationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donation upsert
   */
  export type DonationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The filter to search for the Donation to update in case it exists.
     */
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     */
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }

  /**
   * Donation delete
   */
  export type DonationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter which Donation to delete.
     */
    where: DonationWhereUniqueInput
  }

  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donations to delete
     */
    where?: DonationWhereInput
    /**
     * Limit how many Donations to delete.
     */
    limit?: number
  }

  /**
   * Donation without action
   */
  export type DonationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donation
     */
    omit?: DonationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonationInclude<ExtArgs> | null
  }


  /**
   * Model MedicalInsurance
   */

  export type AggregateMedicalInsurance = {
    _count: MedicalInsuranceCountAggregateOutputType | null
    _avg: MedicalInsuranceAvgAggregateOutputType | null
    _sum: MedicalInsuranceSumAggregateOutputType | null
    _min: MedicalInsuranceMinAggregateOutputType | null
    _max: MedicalInsuranceMaxAggregateOutputType | null
  }

  export type MedicalInsuranceAvgAggregateOutputType = {
    premiumPaid: Decimal | null
    eligibleAmount: Decimal | null
  }

  export type MedicalInsuranceSumAggregateOutputType = {
    premiumPaid: Decimal | null
    eligibleAmount: Decimal | null
  }

  export type MedicalInsuranceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    policyType: string | null
    insuredPersons: string | null
    premiumPaid: Decimal | null
    eligibleAmount: Decimal | null
    policyNumber: string | null
    insuranceCompany: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalInsuranceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    policyType: string | null
    insuredPersons: string | null
    premiumPaid: Decimal | null
    eligibleAmount: Decimal | null
    policyNumber: string | null
    insuranceCompany: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalInsuranceCountAggregateOutputType = {
    id: number
    userId: number
    policyType: number
    insuredPersons: number
    premiumPaid: number
    eligibleAmount: number
    policyNumber: number
    insuranceCompany: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalInsuranceAvgAggregateInputType = {
    premiumPaid?: true
    eligibleAmount?: true
  }

  export type MedicalInsuranceSumAggregateInputType = {
    premiumPaid?: true
    eligibleAmount?: true
  }

  export type MedicalInsuranceMinAggregateInputType = {
    id?: true
    userId?: true
    policyType?: true
    insuredPersons?: true
    premiumPaid?: true
    eligibleAmount?: true
    policyNumber?: true
    insuranceCompany?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalInsuranceMaxAggregateInputType = {
    id?: true
    userId?: true
    policyType?: true
    insuredPersons?: true
    premiumPaid?: true
    eligibleAmount?: true
    policyNumber?: true
    insuranceCompany?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalInsuranceCountAggregateInputType = {
    id?: true
    userId?: true
    policyType?: true
    insuredPersons?: true
    premiumPaid?: true
    eligibleAmount?: true
    policyNumber?: true
    insuranceCompany?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalInsuranceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalInsurance to aggregate.
     */
    where?: MedicalInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInsurances to fetch.
     */
    orderBy?: MedicalInsuranceOrderByWithRelationInput | MedicalInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInsurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalInsurances
    **/
    _count?: true | MedicalInsuranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalInsuranceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalInsuranceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalInsuranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalInsuranceMaxAggregateInputType
  }

  export type GetMedicalInsuranceAggregateType<T extends MedicalInsuranceAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalInsurance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalInsurance[P]>
      : GetScalarType<T[P], AggregateMedicalInsurance[P]>
  }




  export type MedicalInsuranceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalInsuranceWhereInput
    orderBy?: MedicalInsuranceOrderByWithAggregationInput | MedicalInsuranceOrderByWithAggregationInput[]
    by: MedicalInsuranceScalarFieldEnum[] | MedicalInsuranceScalarFieldEnum
    having?: MedicalInsuranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalInsuranceCountAggregateInputType | true
    _avg?: MedicalInsuranceAvgAggregateInputType
    _sum?: MedicalInsuranceSumAggregateInputType
    _min?: MedicalInsuranceMinAggregateInputType
    _max?: MedicalInsuranceMaxAggregateInputType
  }

  export type MedicalInsuranceGroupByOutputType = {
    id: string
    userId: string
    policyType: string | null
    insuredPersons: string | null
    premiumPaid: Decimal | null
    eligibleAmount: Decimal | null
    policyNumber: string | null
    insuranceCompany: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalInsuranceCountAggregateOutputType | null
    _avg: MedicalInsuranceAvgAggregateOutputType | null
    _sum: MedicalInsuranceSumAggregateOutputType | null
    _min: MedicalInsuranceMinAggregateOutputType | null
    _max: MedicalInsuranceMaxAggregateOutputType | null
  }

  type GetMedicalInsuranceGroupByPayload<T extends MedicalInsuranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalInsuranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalInsuranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalInsuranceGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalInsuranceGroupByOutputType[P]>
        }
      >
    >


  export type MedicalInsuranceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    policyType?: boolean
    insuredPersons?: boolean
    premiumPaid?: boolean
    eligibleAmount?: boolean
    policyNumber?: boolean
    insuranceCompany?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInsurance"]>

  export type MedicalInsuranceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    policyType?: boolean
    insuredPersons?: boolean
    premiumPaid?: boolean
    eligibleAmount?: boolean
    policyNumber?: boolean
    insuranceCompany?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInsurance"]>

  export type MedicalInsuranceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    policyType?: boolean
    insuredPersons?: boolean
    premiumPaid?: boolean
    eligibleAmount?: boolean
    policyNumber?: boolean
    insuranceCompany?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalInsurance"]>

  export type MedicalInsuranceSelectScalar = {
    id?: boolean
    userId?: boolean
    policyType?: boolean
    insuredPersons?: boolean
    premiumPaid?: boolean
    eligibleAmount?: boolean
    policyNumber?: boolean
    insuranceCompany?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalInsuranceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "policyType" | "insuredPersons" | "premiumPaid" | "eligibleAmount" | "policyNumber" | "insuranceCompany" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalInsurance"]>
  export type MedicalInsuranceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MedicalInsuranceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MedicalInsuranceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MedicalInsurancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalInsurance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      policyType: string | null
      insuredPersons: string | null
      premiumPaid: Prisma.Decimal | null
      eligibleAmount: Prisma.Decimal | null
      policyNumber: string | null
      insuranceCompany: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalInsurance"]>
    composites: {}
  }

  type MedicalInsuranceGetPayload<S extends boolean | null | undefined | MedicalInsuranceDefaultArgs> = $Result.GetResult<Prisma.$MedicalInsurancePayload, S>

  type MedicalInsuranceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalInsuranceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalInsuranceCountAggregateInputType | true
    }

  export interface MedicalInsuranceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalInsurance'], meta: { name: 'MedicalInsurance' } }
    /**
     * Find zero or one MedicalInsurance that matches the filter.
     * @param {MedicalInsuranceFindUniqueArgs} args - Arguments to find a MedicalInsurance
     * @example
     * // Get one MedicalInsurance
     * const medicalInsurance = await prisma.medicalInsurance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalInsuranceFindUniqueArgs>(args: SelectSubset<T, MedicalInsuranceFindUniqueArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalInsurance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalInsuranceFindUniqueOrThrowArgs} args - Arguments to find a MedicalInsurance
     * @example
     * // Get one MedicalInsurance
     * const medicalInsurance = await prisma.medicalInsurance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalInsuranceFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalInsuranceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalInsurance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceFindFirstArgs} args - Arguments to find a MedicalInsurance
     * @example
     * // Get one MedicalInsurance
     * const medicalInsurance = await prisma.medicalInsurance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalInsuranceFindFirstArgs>(args?: SelectSubset<T, MedicalInsuranceFindFirstArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalInsurance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceFindFirstOrThrowArgs} args - Arguments to find a MedicalInsurance
     * @example
     * // Get one MedicalInsurance
     * const medicalInsurance = await prisma.medicalInsurance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalInsuranceFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalInsuranceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalInsurances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalInsurances
     * const medicalInsurances = await prisma.medicalInsurance.findMany()
     * 
     * // Get first 10 MedicalInsurances
     * const medicalInsurances = await prisma.medicalInsurance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalInsuranceWithIdOnly = await prisma.medicalInsurance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalInsuranceFindManyArgs>(args?: SelectSubset<T, MedicalInsuranceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalInsurance.
     * @param {MedicalInsuranceCreateArgs} args - Arguments to create a MedicalInsurance.
     * @example
     * // Create one MedicalInsurance
     * const MedicalInsurance = await prisma.medicalInsurance.create({
     *   data: {
     *     // ... data to create a MedicalInsurance
     *   }
     * })
     * 
     */
    create<T extends MedicalInsuranceCreateArgs>(args: SelectSubset<T, MedicalInsuranceCreateArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalInsurances.
     * @param {MedicalInsuranceCreateManyArgs} args - Arguments to create many MedicalInsurances.
     * @example
     * // Create many MedicalInsurances
     * const medicalInsurance = await prisma.medicalInsurance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalInsuranceCreateManyArgs>(args?: SelectSubset<T, MedicalInsuranceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalInsurances and returns the data saved in the database.
     * @param {MedicalInsuranceCreateManyAndReturnArgs} args - Arguments to create many MedicalInsurances.
     * @example
     * // Create many MedicalInsurances
     * const medicalInsurance = await prisma.medicalInsurance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalInsurances and only return the `id`
     * const medicalInsuranceWithIdOnly = await prisma.medicalInsurance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalInsuranceCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalInsuranceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalInsurance.
     * @param {MedicalInsuranceDeleteArgs} args - Arguments to delete one MedicalInsurance.
     * @example
     * // Delete one MedicalInsurance
     * const MedicalInsurance = await prisma.medicalInsurance.delete({
     *   where: {
     *     // ... filter to delete one MedicalInsurance
     *   }
     * })
     * 
     */
    delete<T extends MedicalInsuranceDeleteArgs>(args: SelectSubset<T, MedicalInsuranceDeleteArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalInsurance.
     * @param {MedicalInsuranceUpdateArgs} args - Arguments to update one MedicalInsurance.
     * @example
     * // Update one MedicalInsurance
     * const medicalInsurance = await prisma.medicalInsurance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalInsuranceUpdateArgs>(args: SelectSubset<T, MedicalInsuranceUpdateArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalInsurances.
     * @param {MedicalInsuranceDeleteManyArgs} args - Arguments to filter MedicalInsurances to delete.
     * @example
     * // Delete a few MedicalInsurances
     * const { count } = await prisma.medicalInsurance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalInsuranceDeleteManyArgs>(args?: SelectSubset<T, MedicalInsuranceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalInsurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalInsurances
     * const medicalInsurance = await prisma.medicalInsurance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalInsuranceUpdateManyArgs>(args: SelectSubset<T, MedicalInsuranceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalInsurances and returns the data updated in the database.
     * @param {MedicalInsuranceUpdateManyAndReturnArgs} args - Arguments to update many MedicalInsurances.
     * @example
     * // Update many MedicalInsurances
     * const medicalInsurance = await prisma.medicalInsurance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalInsurances and only return the `id`
     * const medicalInsuranceWithIdOnly = await prisma.medicalInsurance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalInsuranceUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalInsuranceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalInsurance.
     * @param {MedicalInsuranceUpsertArgs} args - Arguments to update or create a MedicalInsurance.
     * @example
     * // Update or create a MedicalInsurance
     * const medicalInsurance = await prisma.medicalInsurance.upsert({
     *   create: {
     *     // ... data to create a MedicalInsurance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalInsurance we want to update
     *   }
     * })
     */
    upsert<T extends MedicalInsuranceUpsertArgs>(args: SelectSubset<T, MedicalInsuranceUpsertArgs<ExtArgs>>): Prisma__MedicalInsuranceClient<$Result.GetResult<Prisma.$MedicalInsurancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalInsurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceCountArgs} args - Arguments to filter MedicalInsurances to count.
     * @example
     * // Count the number of MedicalInsurances
     * const count = await prisma.medicalInsurance.count({
     *   where: {
     *     // ... the filter for the MedicalInsurances we want to count
     *   }
     * })
    **/
    count<T extends MedicalInsuranceCountArgs>(
      args?: Subset<T, MedicalInsuranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalInsuranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalInsurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalInsuranceAggregateArgs>(args: Subset<T, MedicalInsuranceAggregateArgs>): Prisma.PrismaPromise<GetMedicalInsuranceAggregateType<T>>

    /**
     * Group by MedicalInsurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalInsuranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalInsuranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalInsuranceGroupByArgs['orderBy'] }
        : { orderBy?: MedicalInsuranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalInsuranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalInsuranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalInsurance model
   */
  readonly fields: MedicalInsuranceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalInsurance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalInsuranceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalInsurance model
   */
  interface MedicalInsuranceFieldRefs {
    readonly id: FieldRef<"MedicalInsurance", 'String'>
    readonly userId: FieldRef<"MedicalInsurance", 'String'>
    readonly policyType: FieldRef<"MedicalInsurance", 'String'>
    readonly insuredPersons: FieldRef<"MedicalInsurance", 'String'>
    readonly premiumPaid: FieldRef<"MedicalInsurance", 'Decimal'>
    readonly eligibleAmount: FieldRef<"MedicalInsurance", 'Decimal'>
    readonly policyNumber: FieldRef<"MedicalInsurance", 'String'>
    readonly insuranceCompany: FieldRef<"MedicalInsurance", 'String'>
    readonly createdAt: FieldRef<"MedicalInsurance", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalInsurance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalInsurance findUnique
   */
  export type MedicalInsuranceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInsurance to fetch.
     */
    where: MedicalInsuranceWhereUniqueInput
  }

  /**
   * MedicalInsurance findUniqueOrThrow
   */
  export type MedicalInsuranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInsurance to fetch.
     */
    where: MedicalInsuranceWhereUniqueInput
  }

  /**
   * MedicalInsurance findFirst
   */
  export type MedicalInsuranceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInsurance to fetch.
     */
    where?: MedicalInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInsurances to fetch.
     */
    orderBy?: MedicalInsuranceOrderByWithRelationInput | MedicalInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalInsurances.
     */
    cursor?: MedicalInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInsurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalInsurances.
     */
    distinct?: MedicalInsuranceScalarFieldEnum | MedicalInsuranceScalarFieldEnum[]
  }

  /**
   * MedicalInsurance findFirstOrThrow
   */
  export type MedicalInsuranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInsurance to fetch.
     */
    where?: MedicalInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInsurances to fetch.
     */
    orderBy?: MedicalInsuranceOrderByWithRelationInput | MedicalInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalInsurances.
     */
    cursor?: MedicalInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInsurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalInsurances.
     */
    distinct?: MedicalInsuranceScalarFieldEnum | MedicalInsuranceScalarFieldEnum[]
  }

  /**
   * MedicalInsurance findMany
   */
  export type MedicalInsuranceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * Filter, which MedicalInsurances to fetch.
     */
    where?: MedicalInsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalInsurances to fetch.
     */
    orderBy?: MedicalInsuranceOrderByWithRelationInput | MedicalInsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalInsurances.
     */
    cursor?: MedicalInsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalInsurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalInsurances.
     */
    skip?: number
    distinct?: MedicalInsuranceScalarFieldEnum | MedicalInsuranceScalarFieldEnum[]
  }

  /**
   * MedicalInsurance create
   */
  export type MedicalInsuranceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalInsurance.
     */
    data: XOR<MedicalInsuranceCreateInput, MedicalInsuranceUncheckedCreateInput>
  }

  /**
   * MedicalInsurance createMany
   */
  export type MedicalInsuranceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalInsurances.
     */
    data: MedicalInsuranceCreateManyInput | MedicalInsuranceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalInsurance createManyAndReturn
   */
  export type MedicalInsuranceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalInsurances.
     */
    data: MedicalInsuranceCreateManyInput | MedicalInsuranceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalInsurance update
   */
  export type MedicalInsuranceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalInsurance.
     */
    data: XOR<MedicalInsuranceUpdateInput, MedicalInsuranceUncheckedUpdateInput>
    /**
     * Choose, which MedicalInsurance to update.
     */
    where: MedicalInsuranceWhereUniqueInput
  }

  /**
   * MedicalInsurance updateMany
   */
  export type MedicalInsuranceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalInsurances.
     */
    data: XOR<MedicalInsuranceUpdateManyMutationInput, MedicalInsuranceUncheckedUpdateManyInput>
    /**
     * Filter which MedicalInsurances to update
     */
    where?: MedicalInsuranceWhereInput
    /**
     * Limit how many MedicalInsurances to update.
     */
    limit?: number
  }

  /**
   * MedicalInsurance updateManyAndReturn
   */
  export type MedicalInsuranceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * The data used to update MedicalInsurances.
     */
    data: XOR<MedicalInsuranceUpdateManyMutationInput, MedicalInsuranceUncheckedUpdateManyInput>
    /**
     * Filter which MedicalInsurances to update
     */
    where?: MedicalInsuranceWhereInput
    /**
     * Limit how many MedicalInsurances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalInsurance upsert
   */
  export type MedicalInsuranceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalInsurance to update in case it exists.
     */
    where: MedicalInsuranceWhereUniqueInput
    /**
     * In case the MedicalInsurance found by the `where` argument doesn't exist, create a new MedicalInsurance with this data.
     */
    create: XOR<MedicalInsuranceCreateInput, MedicalInsuranceUncheckedCreateInput>
    /**
     * In case the MedicalInsurance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalInsuranceUpdateInput, MedicalInsuranceUncheckedUpdateInput>
  }

  /**
   * MedicalInsurance delete
   */
  export type MedicalInsuranceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
    /**
     * Filter which MedicalInsurance to delete.
     */
    where: MedicalInsuranceWhereUniqueInput
  }

  /**
   * MedicalInsurance deleteMany
   */
  export type MedicalInsuranceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalInsurances to delete
     */
    where?: MedicalInsuranceWhereInput
    /**
     * Limit how many MedicalInsurances to delete.
     */
    limit?: number
  }

  /**
   * MedicalInsurance without action
   */
  export type MedicalInsuranceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalInsurance
     */
    select?: MedicalInsuranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalInsurance
     */
    omit?: MedicalInsuranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalInsuranceInclude<ExtArgs> | null
  }


  /**
   * Model TaxPaid
   */

  export type AggregateTaxPaid = {
    _count: TaxPaidCountAggregateOutputType | null
    _avg: TaxPaidAvgAggregateOutputType | null
    _sum: TaxPaidSumAggregateOutputType | null
    _min: TaxPaidMinAggregateOutputType | null
    _max: TaxPaidMaxAggregateOutputType | null
  }

  export type TaxPaidAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TaxPaidSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TaxPaidMinAggregateOutputType = {
    id: string | null
    userId: string | null
    taxType: string | null
    amount: Decimal | null
    date: Date | null
    challanNumber: string | null
    bankName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxPaidMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    taxType: string | null
    amount: Decimal | null
    date: Date | null
    challanNumber: string | null
    bankName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxPaidCountAggregateOutputType = {
    id: number
    userId: number
    taxType: number
    amount: number
    date: number
    challanNumber: number
    bankName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxPaidAvgAggregateInputType = {
    amount?: true
  }

  export type TaxPaidSumAggregateInputType = {
    amount?: true
  }

  export type TaxPaidMinAggregateInputType = {
    id?: true
    userId?: true
    taxType?: true
    amount?: true
    date?: true
    challanNumber?: true
    bankName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxPaidMaxAggregateInputType = {
    id?: true
    userId?: true
    taxType?: true
    amount?: true
    date?: true
    challanNumber?: true
    bankName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxPaidCountAggregateInputType = {
    id?: true
    userId?: true
    taxType?: true
    amount?: true
    date?: true
    challanNumber?: true
    bankName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxPaidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPaid to aggregate.
     */
    where?: TaxPaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPaids to fetch.
     */
    orderBy?: TaxPaidOrderByWithRelationInput | TaxPaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxPaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPaids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPaids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxPaids
    **/
    _count?: true | TaxPaidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxPaidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxPaidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxPaidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxPaidMaxAggregateInputType
  }

  export type GetTaxPaidAggregateType<T extends TaxPaidAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxPaid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxPaid[P]>
      : GetScalarType<T[P], AggregateTaxPaid[P]>
  }




  export type TaxPaidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxPaidWhereInput
    orderBy?: TaxPaidOrderByWithAggregationInput | TaxPaidOrderByWithAggregationInput[]
    by: TaxPaidScalarFieldEnum[] | TaxPaidScalarFieldEnum
    having?: TaxPaidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxPaidCountAggregateInputType | true
    _avg?: TaxPaidAvgAggregateInputType
    _sum?: TaxPaidSumAggregateInputType
    _min?: TaxPaidMinAggregateInputType
    _max?: TaxPaidMaxAggregateInputType
  }

  export type TaxPaidGroupByOutputType = {
    id: string
    userId: string
    taxType: string | null
    amount: Decimal | null
    date: Date | null
    challanNumber: string | null
    bankName: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaxPaidCountAggregateOutputType | null
    _avg: TaxPaidAvgAggregateOutputType | null
    _sum: TaxPaidSumAggregateOutputType | null
    _min: TaxPaidMinAggregateOutputType | null
    _max: TaxPaidMaxAggregateOutputType | null
  }

  type GetTaxPaidGroupByPayload<T extends TaxPaidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxPaidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxPaidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxPaidGroupByOutputType[P]>
            : GetScalarType<T[P], TaxPaidGroupByOutputType[P]>
        }
      >
    >


  export type TaxPaidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taxType?: boolean
    amount?: boolean
    date?: boolean
    challanNumber?: boolean
    bankName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxPaid"]>

  export type TaxPaidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taxType?: boolean
    amount?: boolean
    date?: boolean
    challanNumber?: boolean
    bankName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxPaid"]>

  export type TaxPaidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taxType?: boolean
    amount?: boolean
    date?: boolean
    challanNumber?: boolean
    bankName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxPaid"]>

  export type TaxPaidSelectScalar = {
    id?: boolean
    userId?: boolean
    taxType?: boolean
    amount?: boolean
    date?: boolean
    challanNumber?: boolean
    bankName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxPaidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taxType" | "amount" | "date" | "challanNumber" | "bankName" | "createdAt" | "updatedAt", ExtArgs["result"]["taxPaid"]>
  export type TaxPaidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxPaidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxPaidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaxPaidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxPaid"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      taxType: string | null
      amount: Prisma.Decimal | null
      date: Date | null
      challanNumber: string | null
      bankName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxPaid"]>
    composites: {}
  }

  type TaxPaidGetPayload<S extends boolean | null | undefined | TaxPaidDefaultArgs> = $Result.GetResult<Prisma.$TaxPaidPayload, S>

  type TaxPaidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxPaidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxPaidCountAggregateInputType | true
    }

  export interface TaxPaidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxPaid'], meta: { name: 'TaxPaid' } }
    /**
     * Find zero or one TaxPaid that matches the filter.
     * @param {TaxPaidFindUniqueArgs} args - Arguments to find a TaxPaid
     * @example
     * // Get one TaxPaid
     * const taxPaid = await prisma.taxPaid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxPaidFindUniqueArgs>(args: SelectSubset<T, TaxPaidFindUniqueArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxPaid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxPaidFindUniqueOrThrowArgs} args - Arguments to find a TaxPaid
     * @example
     * // Get one TaxPaid
     * const taxPaid = await prisma.taxPaid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxPaidFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxPaidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxPaid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidFindFirstArgs} args - Arguments to find a TaxPaid
     * @example
     * // Get one TaxPaid
     * const taxPaid = await prisma.taxPaid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxPaidFindFirstArgs>(args?: SelectSubset<T, TaxPaidFindFirstArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxPaid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidFindFirstOrThrowArgs} args - Arguments to find a TaxPaid
     * @example
     * // Get one TaxPaid
     * const taxPaid = await prisma.taxPaid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxPaidFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxPaidFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxPaids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxPaids
     * const taxPaids = await prisma.taxPaid.findMany()
     * 
     * // Get first 10 TaxPaids
     * const taxPaids = await prisma.taxPaid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxPaidWithIdOnly = await prisma.taxPaid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxPaidFindManyArgs>(args?: SelectSubset<T, TaxPaidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxPaid.
     * @param {TaxPaidCreateArgs} args - Arguments to create a TaxPaid.
     * @example
     * // Create one TaxPaid
     * const TaxPaid = await prisma.taxPaid.create({
     *   data: {
     *     // ... data to create a TaxPaid
     *   }
     * })
     * 
     */
    create<T extends TaxPaidCreateArgs>(args: SelectSubset<T, TaxPaidCreateArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxPaids.
     * @param {TaxPaidCreateManyArgs} args - Arguments to create many TaxPaids.
     * @example
     * // Create many TaxPaids
     * const taxPaid = await prisma.taxPaid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxPaidCreateManyArgs>(args?: SelectSubset<T, TaxPaidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxPaids and returns the data saved in the database.
     * @param {TaxPaidCreateManyAndReturnArgs} args - Arguments to create many TaxPaids.
     * @example
     * // Create many TaxPaids
     * const taxPaid = await prisma.taxPaid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxPaids and only return the `id`
     * const taxPaidWithIdOnly = await prisma.taxPaid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxPaidCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxPaidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxPaid.
     * @param {TaxPaidDeleteArgs} args - Arguments to delete one TaxPaid.
     * @example
     * // Delete one TaxPaid
     * const TaxPaid = await prisma.taxPaid.delete({
     *   where: {
     *     // ... filter to delete one TaxPaid
     *   }
     * })
     * 
     */
    delete<T extends TaxPaidDeleteArgs>(args: SelectSubset<T, TaxPaidDeleteArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxPaid.
     * @param {TaxPaidUpdateArgs} args - Arguments to update one TaxPaid.
     * @example
     * // Update one TaxPaid
     * const taxPaid = await prisma.taxPaid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxPaidUpdateArgs>(args: SelectSubset<T, TaxPaidUpdateArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxPaids.
     * @param {TaxPaidDeleteManyArgs} args - Arguments to filter TaxPaids to delete.
     * @example
     * // Delete a few TaxPaids
     * const { count } = await prisma.taxPaid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxPaidDeleteManyArgs>(args?: SelectSubset<T, TaxPaidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPaids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxPaids
     * const taxPaid = await prisma.taxPaid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxPaidUpdateManyArgs>(args: SelectSubset<T, TaxPaidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPaids and returns the data updated in the database.
     * @param {TaxPaidUpdateManyAndReturnArgs} args - Arguments to update many TaxPaids.
     * @example
     * // Update many TaxPaids
     * const taxPaid = await prisma.taxPaid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxPaids and only return the `id`
     * const taxPaidWithIdOnly = await prisma.taxPaid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxPaidUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxPaidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxPaid.
     * @param {TaxPaidUpsertArgs} args - Arguments to update or create a TaxPaid.
     * @example
     * // Update or create a TaxPaid
     * const taxPaid = await prisma.taxPaid.upsert({
     *   create: {
     *     // ... data to create a TaxPaid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxPaid we want to update
     *   }
     * })
     */
    upsert<T extends TaxPaidUpsertArgs>(args: SelectSubset<T, TaxPaidUpsertArgs<ExtArgs>>): Prisma__TaxPaidClient<$Result.GetResult<Prisma.$TaxPaidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxPaids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidCountArgs} args - Arguments to filter TaxPaids to count.
     * @example
     * // Count the number of TaxPaids
     * const count = await prisma.taxPaid.count({
     *   where: {
     *     // ... the filter for the TaxPaids we want to count
     *   }
     * })
    **/
    count<T extends TaxPaidCountArgs>(
      args?: Subset<T, TaxPaidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxPaidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxPaid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxPaidAggregateArgs>(args: Subset<T, TaxPaidAggregateArgs>): Prisma.PrismaPromise<GetTaxPaidAggregateType<T>>

    /**
     * Group by TaxPaid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPaidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxPaidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxPaidGroupByArgs['orderBy'] }
        : { orderBy?: TaxPaidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxPaidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxPaidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxPaid model
   */
  readonly fields: TaxPaidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxPaid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxPaidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxPaid model
   */
  interface TaxPaidFieldRefs {
    readonly id: FieldRef<"TaxPaid", 'String'>
    readonly userId: FieldRef<"TaxPaid", 'String'>
    readonly taxType: FieldRef<"TaxPaid", 'String'>
    readonly amount: FieldRef<"TaxPaid", 'Decimal'>
    readonly date: FieldRef<"TaxPaid", 'DateTime'>
    readonly challanNumber: FieldRef<"TaxPaid", 'String'>
    readonly bankName: FieldRef<"TaxPaid", 'String'>
    readonly createdAt: FieldRef<"TaxPaid", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxPaid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxPaid findUnique
   */
  export type TaxPaidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * Filter, which TaxPaid to fetch.
     */
    where: TaxPaidWhereUniqueInput
  }

  /**
   * TaxPaid findUniqueOrThrow
   */
  export type TaxPaidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * Filter, which TaxPaid to fetch.
     */
    where: TaxPaidWhereUniqueInput
  }

  /**
   * TaxPaid findFirst
   */
  export type TaxPaidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * Filter, which TaxPaid to fetch.
     */
    where?: TaxPaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPaids to fetch.
     */
    orderBy?: TaxPaidOrderByWithRelationInput | TaxPaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPaids.
     */
    cursor?: TaxPaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPaids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPaids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPaids.
     */
    distinct?: TaxPaidScalarFieldEnum | TaxPaidScalarFieldEnum[]
  }

  /**
   * TaxPaid findFirstOrThrow
   */
  export type TaxPaidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * Filter, which TaxPaid to fetch.
     */
    where?: TaxPaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPaids to fetch.
     */
    orderBy?: TaxPaidOrderByWithRelationInput | TaxPaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxPaids.
     */
    cursor?: TaxPaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPaids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPaids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxPaids.
     */
    distinct?: TaxPaidScalarFieldEnum | TaxPaidScalarFieldEnum[]
  }

  /**
   * TaxPaid findMany
   */
  export type TaxPaidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * Filter, which TaxPaids to fetch.
     */
    where?: TaxPaidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxPaids to fetch.
     */
    orderBy?: TaxPaidOrderByWithRelationInput | TaxPaidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxPaids.
     */
    cursor?: TaxPaidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxPaids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxPaids.
     */
    skip?: number
    distinct?: TaxPaidScalarFieldEnum | TaxPaidScalarFieldEnum[]
  }

  /**
   * TaxPaid create
   */
  export type TaxPaidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxPaid.
     */
    data: XOR<TaxPaidCreateInput, TaxPaidUncheckedCreateInput>
  }

  /**
   * TaxPaid createMany
   */
  export type TaxPaidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxPaids.
     */
    data: TaxPaidCreateManyInput | TaxPaidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxPaid createManyAndReturn
   */
  export type TaxPaidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * The data used to create many TaxPaids.
     */
    data: TaxPaidCreateManyInput | TaxPaidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxPaid update
   */
  export type TaxPaidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxPaid.
     */
    data: XOR<TaxPaidUpdateInput, TaxPaidUncheckedUpdateInput>
    /**
     * Choose, which TaxPaid to update.
     */
    where: TaxPaidWhereUniqueInput
  }

  /**
   * TaxPaid updateMany
   */
  export type TaxPaidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxPaids.
     */
    data: XOR<TaxPaidUpdateManyMutationInput, TaxPaidUncheckedUpdateManyInput>
    /**
     * Filter which TaxPaids to update
     */
    where?: TaxPaidWhereInput
    /**
     * Limit how many TaxPaids to update.
     */
    limit?: number
  }

  /**
   * TaxPaid updateManyAndReturn
   */
  export type TaxPaidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * The data used to update TaxPaids.
     */
    data: XOR<TaxPaidUpdateManyMutationInput, TaxPaidUncheckedUpdateManyInput>
    /**
     * Filter which TaxPaids to update
     */
    where?: TaxPaidWhereInput
    /**
     * Limit how many TaxPaids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxPaid upsert
   */
  export type TaxPaidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxPaid to update in case it exists.
     */
    where: TaxPaidWhereUniqueInput
    /**
     * In case the TaxPaid found by the `where` argument doesn't exist, create a new TaxPaid with this data.
     */
    create: XOR<TaxPaidCreateInput, TaxPaidUncheckedCreateInput>
    /**
     * In case the TaxPaid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxPaidUpdateInput, TaxPaidUncheckedUpdateInput>
  }

  /**
   * TaxPaid delete
   */
  export type TaxPaidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
    /**
     * Filter which TaxPaid to delete.
     */
    where: TaxPaidWhereUniqueInput
  }

  /**
   * TaxPaid deleteMany
   */
  export type TaxPaidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxPaids to delete
     */
    where?: TaxPaidWhereInput
    /**
     * Limit how many TaxPaids to delete.
     */
    limit?: number
  }

  /**
   * TaxPaid without action
   */
  export type TaxPaidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPaid
     */
    select?: TaxPaidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxPaid
     */
    omit?: TaxPaidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxPaidInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    balance: Decimal
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      transactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      balance: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Wallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Decimal'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet.transactions
   */
  export type Wallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    transactionType: $Enums.TransactionType | null
    amount: Decimal | null
    description: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
    status: $Enums.TransactionStatus | null
    timestamp: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    transactionType: $Enums.TransactionType | null
    amount: Decimal | null
    description: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
    status: $Enums.TransactionStatus | null
    timestamp: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    walletId: number
    transactionType: number
    amount: number
    description: number
    razorpayPaymentId: number
    razorpayOrderId: number
    status: number
    timestamp: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amount?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    transactionType?: true
    amount?: true
    description?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    status?: true
    timestamp?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    transactionType?: true
    amount?: true
    description?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    status?: true
    timestamp?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    transactionType?: true
    amount?: true
    description?: true
    razorpayPaymentId?: true
    razorpayOrderId?: true
    status?: true
    timestamp?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    walletId: string
    transactionType: $Enums.TransactionType
    amount: Decimal
    description: string | null
    razorpayPaymentId: string | null
    razorpayOrderId: string | null
    status: $Enums.TransactionStatus
    timestamp: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    status?: boolean
    timestamp?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    status?: boolean
    timestamp?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    status?: boolean
    timestamp?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    razorpayPaymentId?: boolean
    razorpayOrderId?: boolean
    status?: boolean
    timestamp?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "transactionType" | "amount" | "description" | "razorpayPaymentId" | "razorpayOrderId" | "status" | "timestamp", ExtArgs["result"]["walletTransaction"]>
  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type WalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type WalletTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      transactionType: $Enums.TransactionType
      amount: Prisma.Decimal
      description: string | null
      razorpayPaymentId: string | null
      razorpayOrderId: string | null
      status: $Enums.TransactionStatus
      timestamp: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions and returns the data updated in the database.
     * @param {WalletTransactionUpdateManyAndReturnArgs} args - Arguments to update many WalletTransactions.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly walletId: FieldRef<"WalletTransaction", 'String'>
    readonly transactionType: FieldRef<"WalletTransaction", 'TransactionType'>
    readonly amount: FieldRef<"WalletTransaction", 'Decimal'>
    readonly description: FieldRef<"WalletTransaction", 'String'>
    readonly razorpayPaymentId: FieldRef<"WalletTransaction", 'String'>
    readonly razorpayOrderId: FieldRef<"WalletTransaction", 'String'>
    readonly status: FieldRef<"WalletTransaction", 'TransactionStatus'>
    readonly timestamp: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction updateManyAndReturn
   */
  export type WalletTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model ITRGeneration
   */

  export type AggregateITRGeneration = {
    _count: ITRGenerationCountAggregateOutputType | null
    _min: ITRGenerationMinAggregateOutputType | null
    _max: ITRGenerationMaxAggregateOutputType | null
  }

  export type ITRGenerationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    itrType: $Enums.ITRType | null
    assessmentYear: string | null
    fileName: string | null
    checksum: string | null
    status: $Enums.ITRStatus | null
    generatedAt: Date | null
    downloadedAt: Date | null
  }

  export type ITRGenerationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    itrType: $Enums.ITRType | null
    assessmentYear: string | null
    fileName: string | null
    checksum: string | null
    status: $Enums.ITRStatus | null
    generatedAt: Date | null
    downloadedAt: Date | null
  }

  export type ITRGenerationCountAggregateOutputType = {
    id: number
    userId: number
    itrType: number
    assessmentYear: number
    fileName: number
    checksum: number
    jsonData: number
    status: number
    generatedAt: number
    downloadedAt: number
    _all: number
  }


  export type ITRGenerationMinAggregateInputType = {
    id?: true
    userId?: true
    itrType?: true
    assessmentYear?: true
    fileName?: true
    checksum?: true
    status?: true
    generatedAt?: true
    downloadedAt?: true
  }

  export type ITRGenerationMaxAggregateInputType = {
    id?: true
    userId?: true
    itrType?: true
    assessmentYear?: true
    fileName?: true
    checksum?: true
    status?: true
    generatedAt?: true
    downloadedAt?: true
  }

  export type ITRGenerationCountAggregateInputType = {
    id?: true
    userId?: true
    itrType?: true
    assessmentYear?: true
    fileName?: true
    checksum?: true
    jsonData?: true
    status?: true
    generatedAt?: true
    downloadedAt?: true
    _all?: true
  }

  export type ITRGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ITRGeneration to aggregate.
     */
    where?: ITRGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ITRGenerations to fetch.
     */
    orderBy?: ITRGenerationOrderByWithRelationInput | ITRGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ITRGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ITRGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ITRGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ITRGenerations
    **/
    _count?: true | ITRGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ITRGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ITRGenerationMaxAggregateInputType
  }

  export type GetITRGenerationAggregateType<T extends ITRGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateITRGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateITRGeneration[P]>
      : GetScalarType<T[P], AggregateITRGeneration[P]>
  }




  export type ITRGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ITRGenerationWhereInput
    orderBy?: ITRGenerationOrderByWithAggregationInput | ITRGenerationOrderByWithAggregationInput[]
    by: ITRGenerationScalarFieldEnum[] | ITRGenerationScalarFieldEnum
    having?: ITRGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ITRGenerationCountAggregateInputType | true
    _min?: ITRGenerationMinAggregateInputType
    _max?: ITRGenerationMaxAggregateInputType
  }

  export type ITRGenerationGroupByOutputType = {
    id: string
    userId: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonValue
    status: $Enums.ITRStatus
    generatedAt: Date
    downloadedAt: Date | null
    _count: ITRGenerationCountAggregateOutputType | null
    _min: ITRGenerationMinAggregateOutputType | null
    _max: ITRGenerationMaxAggregateOutputType | null
  }

  type GetITRGenerationGroupByPayload<T extends ITRGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ITRGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ITRGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ITRGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], ITRGenerationGroupByOutputType[P]>
        }
      >
    >


  export type ITRGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itrType?: boolean
    assessmentYear?: boolean
    fileName?: boolean
    checksum?: boolean
    jsonData?: boolean
    status?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iTRGeneration"]>

  export type ITRGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itrType?: boolean
    assessmentYear?: boolean
    fileName?: boolean
    checksum?: boolean
    jsonData?: boolean
    status?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iTRGeneration"]>

  export type ITRGenerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    itrType?: boolean
    assessmentYear?: boolean
    fileName?: boolean
    checksum?: boolean
    jsonData?: boolean
    status?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iTRGeneration"]>

  export type ITRGenerationSelectScalar = {
    id?: boolean
    userId?: boolean
    itrType?: boolean
    assessmentYear?: boolean
    fileName?: boolean
    checksum?: boolean
    jsonData?: boolean
    status?: boolean
    generatedAt?: boolean
    downloadedAt?: boolean
  }

  export type ITRGenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "itrType" | "assessmentYear" | "fileName" | "checksum" | "jsonData" | "status" | "generatedAt" | "downloadedAt", ExtArgs["result"]["iTRGeneration"]>
  export type ITRGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ITRGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ITRGenerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ITRGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ITRGeneration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      itrType: $Enums.ITRType
      assessmentYear: string
      fileName: string
      checksum: string
      jsonData: Prisma.JsonValue
      status: $Enums.ITRStatus
      generatedAt: Date
      downloadedAt: Date | null
    }, ExtArgs["result"]["iTRGeneration"]>
    composites: {}
  }

  type ITRGenerationGetPayload<S extends boolean | null | undefined | ITRGenerationDefaultArgs> = $Result.GetResult<Prisma.$ITRGenerationPayload, S>

  type ITRGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ITRGenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ITRGenerationCountAggregateInputType | true
    }

  export interface ITRGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ITRGeneration'], meta: { name: 'ITRGeneration' } }
    /**
     * Find zero or one ITRGeneration that matches the filter.
     * @param {ITRGenerationFindUniqueArgs} args - Arguments to find a ITRGeneration
     * @example
     * // Get one ITRGeneration
     * const iTRGeneration = await prisma.iTRGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ITRGenerationFindUniqueArgs>(args: SelectSubset<T, ITRGenerationFindUniqueArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ITRGeneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ITRGenerationFindUniqueOrThrowArgs} args - Arguments to find a ITRGeneration
     * @example
     * // Get one ITRGeneration
     * const iTRGeneration = await prisma.iTRGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ITRGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, ITRGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ITRGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationFindFirstArgs} args - Arguments to find a ITRGeneration
     * @example
     * // Get one ITRGeneration
     * const iTRGeneration = await prisma.iTRGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ITRGenerationFindFirstArgs>(args?: SelectSubset<T, ITRGenerationFindFirstArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ITRGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationFindFirstOrThrowArgs} args - Arguments to find a ITRGeneration
     * @example
     * // Get one ITRGeneration
     * const iTRGeneration = await prisma.iTRGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ITRGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, ITRGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ITRGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ITRGenerations
     * const iTRGenerations = await prisma.iTRGeneration.findMany()
     * 
     * // Get first 10 ITRGenerations
     * const iTRGenerations = await prisma.iTRGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iTRGenerationWithIdOnly = await prisma.iTRGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ITRGenerationFindManyArgs>(args?: SelectSubset<T, ITRGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ITRGeneration.
     * @param {ITRGenerationCreateArgs} args - Arguments to create a ITRGeneration.
     * @example
     * // Create one ITRGeneration
     * const ITRGeneration = await prisma.iTRGeneration.create({
     *   data: {
     *     // ... data to create a ITRGeneration
     *   }
     * })
     * 
     */
    create<T extends ITRGenerationCreateArgs>(args: SelectSubset<T, ITRGenerationCreateArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ITRGenerations.
     * @param {ITRGenerationCreateManyArgs} args - Arguments to create many ITRGenerations.
     * @example
     * // Create many ITRGenerations
     * const iTRGeneration = await prisma.iTRGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ITRGenerationCreateManyArgs>(args?: SelectSubset<T, ITRGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ITRGenerations and returns the data saved in the database.
     * @param {ITRGenerationCreateManyAndReturnArgs} args - Arguments to create many ITRGenerations.
     * @example
     * // Create many ITRGenerations
     * const iTRGeneration = await prisma.iTRGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ITRGenerations and only return the `id`
     * const iTRGenerationWithIdOnly = await prisma.iTRGeneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ITRGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, ITRGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ITRGeneration.
     * @param {ITRGenerationDeleteArgs} args - Arguments to delete one ITRGeneration.
     * @example
     * // Delete one ITRGeneration
     * const ITRGeneration = await prisma.iTRGeneration.delete({
     *   where: {
     *     // ... filter to delete one ITRGeneration
     *   }
     * })
     * 
     */
    delete<T extends ITRGenerationDeleteArgs>(args: SelectSubset<T, ITRGenerationDeleteArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ITRGeneration.
     * @param {ITRGenerationUpdateArgs} args - Arguments to update one ITRGeneration.
     * @example
     * // Update one ITRGeneration
     * const iTRGeneration = await prisma.iTRGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ITRGenerationUpdateArgs>(args: SelectSubset<T, ITRGenerationUpdateArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ITRGenerations.
     * @param {ITRGenerationDeleteManyArgs} args - Arguments to filter ITRGenerations to delete.
     * @example
     * // Delete a few ITRGenerations
     * const { count } = await prisma.iTRGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ITRGenerationDeleteManyArgs>(args?: SelectSubset<T, ITRGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ITRGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ITRGenerations
     * const iTRGeneration = await prisma.iTRGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ITRGenerationUpdateManyArgs>(args: SelectSubset<T, ITRGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ITRGenerations and returns the data updated in the database.
     * @param {ITRGenerationUpdateManyAndReturnArgs} args - Arguments to update many ITRGenerations.
     * @example
     * // Update many ITRGenerations
     * const iTRGeneration = await prisma.iTRGeneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ITRGenerations and only return the `id`
     * const iTRGenerationWithIdOnly = await prisma.iTRGeneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ITRGenerationUpdateManyAndReturnArgs>(args: SelectSubset<T, ITRGenerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ITRGeneration.
     * @param {ITRGenerationUpsertArgs} args - Arguments to update or create a ITRGeneration.
     * @example
     * // Update or create a ITRGeneration
     * const iTRGeneration = await prisma.iTRGeneration.upsert({
     *   create: {
     *     // ... data to create a ITRGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ITRGeneration we want to update
     *   }
     * })
     */
    upsert<T extends ITRGenerationUpsertArgs>(args: SelectSubset<T, ITRGenerationUpsertArgs<ExtArgs>>): Prisma__ITRGenerationClient<$Result.GetResult<Prisma.$ITRGenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ITRGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationCountArgs} args - Arguments to filter ITRGenerations to count.
     * @example
     * // Count the number of ITRGenerations
     * const count = await prisma.iTRGeneration.count({
     *   where: {
     *     // ... the filter for the ITRGenerations we want to count
     *   }
     * })
    **/
    count<T extends ITRGenerationCountArgs>(
      args?: Subset<T, ITRGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ITRGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ITRGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ITRGenerationAggregateArgs>(args: Subset<T, ITRGenerationAggregateArgs>): Prisma.PrismaPromise<GetITRGenerationAggregateType<T>>

    /**
     * Group by ITRGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ITRGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ITRGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ITRGenerationGroupByArgs['orderBy'] }
        : { orderBy?: ITRGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ITRGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetITRGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ITRGeneration model
   */
  readonly fields: ITRGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ITRGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ITRGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ITRGeneration model
   */
  interface ITRGenerationFieldRefs {
    readonly id: FieldRef<"ITRGeneration", 'String'>
    readonly userId: FieldRef<"ITRGeneration", 'String'>
    readonly itrType: FieldRef<"ITRGeneration", 'ITRType'>
    readonly assessmentYear: FieldRef<"ITRGeneration", 'String'>
    readonly fileName: FieldRef<"ITRGeneration", 'String'>
    readonly checksum: FieldRef<"ITRGeneration", 'String'>
    readonly jsonData: FieldRef<"ITRGeneration", 'Json'>
    readonly status: FieldRef<"ITRGeneration", 'ITRStatus'>
    readonly generatedAt: FieldRef<"ITRGeneration", 'DateTime'>
    readonly downloadedAt: FieldRef<"ITRGeneration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ITRGeneration findUnique
   */
  export type ITRGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * Filter, which ITRGeneration to fetch.
     */
    where: ITRGenerationWhereUniqueInput
  }

  /**
   * ITRGeneration findUniqueOrThrow
   */
  export type ITRGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * Filter, which ITRGeneration to fetch.
     */
    where: ITRGenerationWhereUniqueInput
  }

  /**
   * ITRGeneration findFirst
   */
  export type ITRGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * Filter, which ITRGeneration to fetch.
     */
    where?: ITRGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ITRGenerations to fetch.
     */
    orderBy?: ITRGenerationOrderByWithRelationInput | ITRGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ITRGenerations.
     */
    cursor?: ITRGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ITRGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ITRGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ITRGenerations.
     */
    distinct?: ITRGenerationScalarFieldEnum | ITRGenerationScalarFieldEnum[]
  }

  /**
   * ITRGeneration findFirstOrThrow
   */
  export type ITRGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * Filter, which ITRGeneration to fetch.
     */
    where?: ITRGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ITRGenerations to fetch.
     */
    orderBy?: ITRGenerationOrderByWithRelationInput | ITRGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ITRGenerations.
     */
    cursor?: ITRGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ITRGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ITRGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ITRGenerations.
     */
    distinct?: ITRGenerationScalarFieldEnum | ITRGenerationScalarFieldEnum[]
  }

  /**
   * ITRGeneration findMany
   */
  export type ITRGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * Filter, which ITRGenerations to fetch.
     */
    where?: ITRGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ITRGenerations to fetch.
     */
    orderBy?: ITRGenerationOrderByWithRelationInput | ITRGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ITRGenerations.
     */
    cursor?: ITRGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ITRGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ITRGenerations.
     */
    skip?: number
    distinct?: ITRGenerationScalarFieldEnum | ITRGenerationScalarFieldEnum[]
  }

  /**
   * ITRGeneration create
   */
  export type ITRGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a ITRGeneration.
     */
    data: XOR<ITRGenerationCreateInput, ITRGenerationUncheckedCreateInput>
  }

  /**
   * ITRGeneration createMany
   */
  export type ITRGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ITRGenerations.
     */
    data: ITRGenerationCreateManyInput | ITRGenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ITRGeneration createManyAndReturn
   */
  export type ITRGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * The data used to create many ITRGenerations.
     */
    data: ITRGenerationCreateManyInput | ITRGenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ITRGeneration update
   */
  export type ITRGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a ITRGeneration.
     */
    data: XOR<ITRGenerationUpdateInput, ITRGenerationUncheckedUpdateInput>
    /**
     * Choose, which ITRGeneration to update.
     */
    where: ITRGenerationWhereUniqueInput
  }

  /**
   * ITRGeneration updateMany
   */
  export type ITRGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ITRGenerations.
     */
    data: XOR<ITRGenerationUpdateManyMutationInput, ITRGenerationUncheckedUpdateManyInput>
    /**
     * Filter which ITRGenerations to update
     */
    where?: ITRGenerationWhereInput
    /**
     * Limit how many ITRGenerations to update.
     */
    limit?: number
  }

  /**
   * ITRGeneration updateManyAndReturn
   */
  export type ITRGenerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * The data used to update ITRGenerations.
     */
    data: XOR<ITRGenerationUpdateManyMutationInput, ITRGenerationUncheckedUpdateManyInput>
    /**
     * Filter which ITRGenerations to update
     */
    where?: ITRGenerationWhereInput
    /**
     * Limit how many ITRGenerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ITRGeneration upsert
   */
  export type ITRGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the ITRGeneration to update in case it exists.
     */
    where: ITRGenerationWhereUniqueInput
    /**
     * In case the ITRGeneration found by the `where` argument doesn't exist, create a new ITRGeneration with this data.
     */
    create: XOR<ITRGenerationCreateInput, ITRGenerationUncheckedCreateInput>
    /**
     * In case the ITRGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ITRGenerationUpdateInput, ITRGenerationUncheckedUpdateInput>
  }

  /**
   * ITRGeneration delete
   */
  export type ITRGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
    /**
     * Filter which ITRGeneration to delete.
     */
    where: ITRGenerationWhereUniqueInput
  }

  /**
   * ITRGeneration deleteMany
   */
  export type ITRGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ITRGenerations to delete
     */
    where?: ITRGenerationWhereInput
    /**
     * Limit how many ITRGenerations to delete.
     */
    limit?: number
  }

  /**
   * ITRGeneration without action
   */
  export type ITRGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ITRGeneration
     */
    select?: ITRGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ITRGeneration
     */
    omit?: ITRGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ITRGenerationInclude<ExtArgs> | null
  }


  /**
   * Model TaxSummary
   */

  export type AggregateTaxSummary = {
    _count: TaxSummaryCountAggregateOutputType | null
    _avg: TaxSummaryAvgAggregateOutputType | null
    _sum: TaxSummarySumAggregateOutputType | null
    _min: TaxSummaryMinAggregateOutputType | null
    _max: TaxSummaryMaxAggregateOutputType | null
  }

  export type TaxSummaryAvgAggregateOutputType = {
    totalIncome: Decimal | null
    totalDeductions: Decimal | null
    taxableIncome: Decimal | null
    taxLiability: Decimal | null
    taxPaid: Decimal | null
    refundAmount: Decimal | null
  }

  export type TaxSummarySumAggregateOutputType = {
    totalIncome: Decimal | null
    totalDeductions: Decimal | null
    taxableIncome: Decimal | null
    taxLiability: Decimal | null
    taxPaid: Decimal | null
    refundAmount: Decimal | null
  }

  export type TaxSummaryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assessmentYear: string | null
    totalIncome: Decimal | null
    totalDeductions: Decimal | null
    taxableIncome: Decimal | null
    taxLiability: Decimal | null
    taxPaid: Decimal | null
    refundAmount: Decimal | null
    filingStatus: string | null
    filingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxSummaryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assessmentYear: string | null
    totalIncome: Decimal | null
    totalDeductions: Decimal | null
    taxableIncome: Decimal | null
    taxLiability: Decimal | null
    taxPaid: Decimal | null
    refundAmount: Decimal | null
    filingStatus: string | null
    filingDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxSummaryCountAggregateOutputType = {
    id: number
    userId: number
    assessmentYear: number
    totalIncome: number
    totalDeductions: number
    taxableIncome: number
    taxLiability: number
    taxPaid: number
    refundAmount: number
    filingStatus: number
    filingDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxSummaryAvgAggregateInputType = {
    totalIncome?: true
    totalDeductions?: true
    taxableIncome?: true
    taxLiability?: true
    taxPaid?: true
    refundAmount?: true
  }

  export type TaxSummarySumAggregateInputType = {
    totalIncome?: true
    totalDeductions?: true
    taxableIncome?: true
    taxLiability?: true
    taxPaid?: true
    refundAmount?: true
  }

  export type TaxSummaryMinAggregateInputType = {
    id?: true
    userId?: true
    assessmentYear?: true
    totalIncome?: true
    totalDeductions?: true
    taxableIncome?: true
    taxLiability?: true
    taxPaid?: true
    refundAmount?: true
    filingStatus?: true
    filingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxSummaryMaxAggregateInputType = {
    id?: true
    userId?: true
    assessmentYear?: true
    totalIncome?: true
    totalDeductions?: true
    taxableIncome?: true
    taxLiability?: true
    taxPaid?: true
    refundAmount?: true
    filingStatus?: true
    filingDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxSummaryCountAggregateInputType = {
    id?: true
    userId?: true
    assessmentYear?: true
    totalIncome?: true
    totalDeductions?: true
    taxableIncome?: true
    taxLiability?: true
    taxPaid?: true
    refundAmount?: true
    filingStatus?: true
    filingDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSummary to aggregate.
     */
    where?: TaxSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSummaries to fetch.
     */
    orderBy?: TaxSummaryOrderByWithRelationInput | TaxSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxSummaries
    **/
    _count?: true | TaxSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxSummaryMaxAggregateInputType
  }

  export type GetTaxSummaryAggregateType<T extends TaxSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxSummary[P]>
      : GetScalarType<T[P], AggregateTaxSummary[P]>
  }




  export type TaxSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxSummaryWhereInput
    orderBy?: TaxSummaryOrderByWithAggregationInput | TaxSummaryOrderByWithAggregationInput[]
    by: TaxSummaryScalarFieldEnum[] | TaxSummaryScalarFieldEnum
    having?: TaxSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxSummaryCountAggregateInputType | true
    _avg?: TaxSummaryAvgAggregateInputType
    _sum?: TaxSummarySumAggregateInputType
    _min?: TaxSummaryMinAggregateInputType
    _max?: TaxSummaryMaxAggregateInputType
  }

  export type TaxSummaryGroupByOutputType = {
    id: string
    userId: string
    assessmentYear: string | null
    totalIncome: Decimal | null
    totalDeductions: Decimal | null
    taxableIncome: Decimal | null
    taxLiability: Decimal | null
    taxPaid: Decimal | null
    refundAmount: Decimal | null
    filingStatus: string | null
    filingDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TaxSummaryCountAggregateOutputType | null
    _avg: TaxSummaryAvgAggregateOutputType | null
    _sum: TaxSummarySumAggregateOutputType | null
    _min: TaxSummaryMinAggregateOutputType | null
    _max: TaxSummaryMaxAggregateOutputType | null
  }

  type GetTaxSummaryGroupByPayload<T extends TaxSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], TaxSummaryGroupByOutputType[P]>
        }
      >
    >


  export type TaxSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentYear?: boolean
    totalIncome?: boolean
    totalDeductions?: boolean
    taxableIncome?: boolean
    taxLiability?: boolean
    taxPaid?: boolean
    refundAmount?: boolean
    filingStatus?: boolean
    filingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSummary"]>

  export type TaxSummarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentYear?: boolean
    totalIncome?: boolean
    totalDeductions?: boolean
    taxableIncome?: boolean
    taxLiability?: boolean
    taxPaid?: boolean
    refundAmount?: boolean
    filingStatus?: boolean
    filingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSummary"]>

  export type TaxSummarySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentYear?: boolean
    totalIncome?: boolean
    totalDeductions?: boolean
    taxableIncome?: boolean
    taxLiability?: boolean
    taxPaid?: boolean
    refundAmount?: boolean
    filingStatus?: boolean
    filingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxSummary"]>

  export type TaxSummarySelectScalar = {
    id?: boolean
    userId?: boolean
    assessmentYear?: boolean
    totalIncome?: boolean
    totalDeductions?: boolean
    taxableIncome?: boolean
    taxLiability?: boolean
    taxPaid?: boolean
    refundAmount?: boolean
    filingStatus?: boolean
    filingDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assessmentYear" | "totalIncome" | "totalDeductions" | "taxableIncome" | "taxLiability" | "taxPaid" | "refundAmount" | "filingStatus" | "filingDate" | "createdAt" | "updatedAt", ExtArgs["result"]["taxSummary"]>
  export type TaxSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxSummaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaxSummaryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaxSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxSummary"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assessmentYear: string | null
      totalIncome: Prisma.Decimal | null
      totalDeductions: Prisma.Decimal | null
      taxableIncome: Prisma.Decimal | null
      taxLiability: Prisma.Decimal | null
      taxPaid: Prisma.Decimal | null
      refundAmount: Prisma.Decimal | null
      filingStatus: string | null
      filingDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxSummary"]>
    composites: {}
  }

  type TaxSummaryGetPayload<S extends boolean | null | undefined | TaxSummaryDefaultArgs> = $Result.GetResult<Prisma.$TaxSummaryPayload, S>

  type TaxSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxSummaryCountAggregateInputType | true
    }

  export interface TaxSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxSummary'], meta: { name: 'TaxSummary' } }
    /**
     * Find zero or one TaxSummary that matches the filter.
     * @param {TaxSummaryFindUniqueArgs} args - Arguments to find a TaxSummary
     * @example
     * // Get one TaxSummary
     * const taxSummary = await prisma.taxSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxSummaryFindUniqueArgs>(args: SelectSubset<T, TaxSummaryFindUniqueArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxSummaryFindUniqueOrThrowArgs} args - Arguments to find a TaxSummary
     * @example
     * // Get one TaxSummary
     * const taxSummary = await prisma.taxSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryFindFirstArgs} args - Arguments to find a TaxSummary
     * @example
     * // Get one TaxSummary
     * const taxSummary = await prisma.taxSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxSummaryFindFirstArgs>(args?: SelectSubset<T, TaxSummaryFindFirstArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryFindFirstOrThrowArgs} args - Arguments to find a TaxSummary
     * @example
     * // Get one TaxSummary
     * const taxSummary = await prisma.taxSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxSummaries
     * const taxSummaries = await prisma.taxSummary.findMany()
     * 
     * // Get first 10 TaxSummaries
     * const taxSummaries = await prisma.taxSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxSummaryWithIdOnly = await prisma.taxSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxSummaryFindManyArgs>(args?: SelectSubset<T, TaxSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxSummary.
     * @param {TaxSummaryCreateArgs} args - Arguments to create a TaxSummary.
     * @example
     * // Create one TaxSummary
     * const TaxSummary = await prisma.taxSummary.create({
     *   data: {
     *     // ... data to create a TaxSummary
     *   }
     * })
     * 
     */
    create<T extends TaxSummaryCreateArgs>(args: SelectSubset<T, TaxSummaryCreateArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxSummaries.
     * @param {TaxSummaryCreateManyArgs} args - Arguments to create many TaxSummaries.
     * @example
     * // Create many TaxSummaries
     * const taxSummary = await prisma.taxSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxSummaryCreateManyArgs>(args?: SelectSubset<T, TaxSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxSummaries and returns the data saved in the database.
     * @param {TaxSummaryCreateManyAndReturnArgs} args - Arguments to create many TaxSummaries.
     * @example
     * // Create many TaxSummaries
     * const taxSummary = await prisma.taxSummary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxSummaries and only return the `id`
     * const taxSummaryWithIdOnly = await prisma.taxSummary.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxSummaryCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxSummaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxSummary.
     * @param {TaxSummaryDeleteArgs} args - Arguments to delete one TaxSummary.
     * @example
     * // Delete one TaxSummary
     * const TaxSummary = await prisma.taxSummary.delete({
     *   where: {
     *     // ... filter to delete one TaxSummary
     *   }
     * })
     * 
     */
    delete<T extends TaxSummaryDeleteArgs>(args: SelectSubset<T, TaxSummaryDeleteArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxSummary.
     * @param {TaxSummaryUpdateArgs} args - Arguments to update one TaxSummary.
     * @example
     * // Update one TaxSummary
     * const taxSummary = await prisma.taxSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxSummaryUpdateArgs>(args: SelectSubset<T, TaxSummaryUpdateArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxSummaries.
     * @param {TaxSummaryDeleteManyArgs} args - Arguments to filter TaxSummaries to delete.
     * @example
     * // Delete a few TaxSummaries
     * const { count } = await prisma.taxSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxSummaryDeleteManyArgs>(args?: SelectSubset<T, TaxSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxSummaries
     * const taxSummary = await prisma.taxSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxSummaryUpdateManyArgs>(args: SelectSubset<T, TaxSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxSummaries and returns the data updated in the database.
     * @param {TaxSummaryUpdateManyAndReturnArgs} args - Arguments to update many TaxSummaries.
     * @example
     * // Update many TaxSummaries
     * const taxSummary = await prisma.taxSummary.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxSummaries and only return the `id`
     * const taxSummaryWithIdOnly = await prisma.taxSummary.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxSummaryUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxSummaryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxSummary.
     * @param {TaxSummaryUpsertArgs} args - Arguments to update or create a TaxSummary.
     * @example
     * // Update or create a TaxSummary
     * const taxSummary = await prisma.taxSummary.upsert({
     *   create: {
     *     // ... data to create a TaxSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxSummary we want to update
     *   }
     * })
     */
    upsert<T extends TaxSummaryUpsertArgs>(args: SelectSubset<T, TaxSummaryUpsertArgs<ExtArgs>>): Prisma__TaxSummaryClient<$Result.GetResult<Prisma.$TaxSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryCountArgs} args - Arguments to filter TaxSummaries to count.
     * @example
     * // Count the number of TaxSummaries
     * const count = await prisma.taxSummary.count({
     *   where: {
     *     // ... the filter for the TaxSummaries we want to count
     *   }
     * })
    **/
    count<T extends TaxSummaryCountArgs>(
      args?: Subset<T, TaxSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxSummaryAggregateArgs>(args: Subset<T, TaxSummaryAggregateArgs>): Prisma.PrismaPromise<GetTaxSummaryAggregateType<T>>

    /**
     * Group by TaxSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxSummaryGroupByArgs['orderBy'] }
        : { orderBy?: TaxSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxSummary model
   */
  readonly fields: TaxSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxSummary model
   */
  interface TaxSummaryFieldRefs {
    readonly id: FieldRef<"TaxSummary", 'String'>
    readonly userId: FieldRef<"TaxSummary", 'String'>
    readonly assessmentYear: FieldRef<"TaxSummary", 'String'>
    readonly totalIncome: FieldRef<"TaxSummary", 'Decimal'>
    readonly totalDeductions: FieldRef<"TaxSummary", 'Decimal'>
    readonly taxableIncome: FieldRef<"TaxSummary", 'Decimal'>
    readonly taxLiability: FieldRef<"TaxSummary", 'Decimal'>
    readonly taxPaid: FieldRef<"TaxSummary", 'Decimal'>
    readonly refundAmount: FieldRef<"TaxSummary", 'Decimal'>
    readonly filingStatus: FieldRef<"TaxSummary", 'String'>
    readonly filingDate: FieldRef<"TaxSummary", 'DateTime'>
    readonly createdAt: FieldRef<"TaxSummary", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxSummary findUnique
   */
  export type TaxSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TaxSummary to fetch.
     */
    where: TaxSummaryWhereUniqueInput
  }

  /**
   * TaxSummary findUniqueOrThrow
   */
  export type TaxSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TaxSummary to fetch.
     */
    where: TaxSummaryWhereUniqueInput
  }

  /**
   * TaxSummary findFirst
   */
  export type TaxSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TaxSummary to fetch.
     */
    where?: TaxSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSummaries to fetch.
     */
    orderBy?: TaxSummaryOrderByWithRelationInput | TaxSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSummaries.
     */
    cursor?: TaxSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSummaries.
     */
    distinct?: TaxSummaryScalarFieldEnum | TaxSummaryScalarFieldEnum[]
  }

  /**
   * TaxSummary findFirstOrThrow
   */
  export type TaxSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TaxSummary to fetch.
     */
    where?: TaxSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSummaries to fetch.
     */
    orderBy?: TaxSummaryOrderByWithRelationInput | TaxSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxSummaries.
     */
    cursor?: TaxSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxSummaries.
     */
    distinct?: TaxSummaryScalarFieldEnum | TaxSummaryScalarFieldEnum[]
  }

  /**
   * TaxSummary findMany
   */
  export type TaxSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * Filter, which TaxSummaries to fetch.
     */
    where?: TaxSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxSummaries to fetch.
     */
    orderBy?: TaxSummaryOrderByWithRelationInput | TaxSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxSummaries.
     */
    cursor?: TaxSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxSummaries.
     */
    skip?: number
    distinct?: TaxSummaryScalarFieldEnum | TaxSummaryScalarFieldEnum[]
  }

  /**
   * TaxSummary create
   */
  export type TaxSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxSummary.
     */
    data: XOR<TaxSummaryCreateInput, TaxSummaryUncheckedCreateInput>
  }

  /**
   * TaxSummary createMany
   */
  export type TaxSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxSummaries.
     */
    data: TaxSummaryCreateManyInput | TaxSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxSummary createManyAndReturn
   */
  export type TaxSummaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * The data used to create many TaxSummaries.
     */
    data: TaxSummaryCreateManyInput | TaxSummaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxSummary update
   */
  export type TaxSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxSummary.
     */
    data: XOR<TaxSummaryUpdateInput, TaxSummaryUncheckedUpdateInput>
    /**
     * Choose, which TaxSummary to update.
     */
    where: TaxSummaryWhereUniqueInput
  }

  /**
   * TaxSummary updateMany
   */
  export type TaxSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxSummaries.
     */
    data: XOR<TaxSummaryUpdateManyMutationInput, TaxSummaryUncheckedUpdateManyInput>
    /**
     * Filter which TaxSummaries to update
     */
    where?: TaxSummaryWhereInput
    /**
     * Limit how many TaxSummaries to update.
     */
    limit?: number
  }

  /**
   * TaxSummary updateManyAndReturn
   */
  export type TaxSummaryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * The data used to update TaxSummaries.
     */
    data: XOR<TaxSummaryUpdateManyMutationInput, TaxSummaryUncheckedUpdateManyInput>
    /**
     * Filter which TaxSummaries to update
     */
    where?: TaxSummaryWhereInput
    /**
     * Limit how many TaxSummaries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxSummary upsert
   */
  export type TaxSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxSummary to update in case it exists.
     */
    where: TaxSummaryWhereUniqueInput
    /**
     * In case the TaxSummary found by the `where` argument doesn't exist, create a new TaxSummary with this data.
     */
    create: XOR<TaxSummaryCreateInput, TaxSummaryUncheckedCreateInput>
    /**
     * In case the TaxSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxSummaryUpdateInput, TaxSummaryUncheckedUpdateInput>
  }

  /**
   * TaxSummary delete
   */
  export type TaxSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
    /**
     * Filter which TaxSummary to delete.
     */
    where: TaxSummaryWhereUniqueInput
  }

  /**
   * TaxSummary deleteMany
   */
  export type TaxSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxSummaries to delete
     */
    where?: TaxSummaryWhereInput
    /**
     * Limit how many TaxSummaries to delete.
     */
    limit?: number
  }

  /**
   * TaxSummary without action
   */
  export type TaxSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxSummary
     */
    select?: TaxSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxSummary
     */
    omit?: TaxSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxSummaryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    password: 'password',
    role: 'role',
    emailVerified: 'emailVerified',
    emailVerificationDate: 'emailVerificationDate',
    lastVerificationEmailSent: 'lastVerificationEmailSent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PersonalDetailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    dob: 'dob',
    gender: 'gender',
    maritalStatus: 'maritalStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonalDetailScalarFieldEnum = (typeof PersonalDetailScalarFieldEnum)[keyof typeof PersonalDetailScalarFieldEnum]


  export const ContactDetailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    phone: 'phone',
    panNumber: 'panNumber',
    aadharNumber: 'aadharNumber',
    alternativeEmail: 'alternativeEmail',
    alternativePhone: 'alternativePhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactDetailScalarFieldEnum = (typeof ContactDetailScalarFieldEnum)[keyof typeof ContactDetailScalarFieldEnum]


  export const AddressDetailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    flatNo: 'flatNo',
    premiseName: 'premiseName',
    road: 'road',
    area: 'area',
    pincode: 'pincode',
    country: 'country',
    state: 'state',
    city: 'city',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressDetailScalarFieldEnum = (typeof AddressDetailScalarFieldEnum)[keyof typeof AddressDetailScalarFieldEnum]


  export const BankDetailScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountNumber: 'accountNumber',
    ifscCode: 'ifscCode',
    bankName: 'bankName',
    accountType: 'accountType',
    accountHolderName: 'accountHolderName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankDetailScalarFieldEnum = (typeof BankDetailScalarFieldEnum)[keyof typeof BankDetailScalarFieldEnum]


  export const Form16DataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employerName: 'employerName',
    employerTAN: 'employerTAN',
    employerCategory: 'employerCategory',
    totalTax: 'totalTax',
    grossSalary: 'grossSalary',
    notifiedIncome: 'notifiedIncome',
    salaryBreakup: 'salaryBreakup',
    perquisitesAmount: 'perquisitesAmount',
    perquisites: 'perquisites',
    profitAmount: 'profitAmount',
    profitsInLieu: 'profitsInLieu',
    notifiedCountry: 'notifiedCountry',
    notifiedIncomeOtherCountry: 'notifiedIncomeOtherCountry',
    previousYearIncomeTax: 'previousYearIncomeTax',
    exemptAllowance: 'exemptAllowance',
    exemptAllowanceBreakup: 'exemptAllowanceBreakup',
    balance: 'balance',
    standardDeduction: 'standardDeduction',
    professionalTax: 'professionalTax',
    reliefUnder89: 'reliefUnder89',
    incomeClaimed: 'incomeClaimed',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Form16DataScalarFieldEnum = (typeof Form16DataScalarFieldEnum)[keyof typeof Form16DataScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    propertyIndex: 'propertyIndex',
    propertyType: 'propertyType',
    netTaxableIncome: 'netTaxableIncome',
    houseAddress: 'houseAddress',
    ownerDetails: 'ownerDetails',
    taxSavings: 'taxSavings',
    rentalIncomeDetails: 'rentalIncomeDetails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const CapitalGainScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assetType: 'assetType',
    assetSubType: 'assetSubType',
    dateOfSale: 'dateOfSale',
    dateOfPurchase: 'dateOfPurchase',
    description: 'description',
    salePrice: 'salePrice',
    transferExpenses: 'transferExpenses',
    purchasePrice: 'purchasePrice',
    sttPaid: 'sttPaid',
    totalProfit: 'totalProfit',
    indexationCost: 'indexationCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CapitalGainScalarFieldEnum = (typeof CapitalGainScalarFieldEnum)[keyof typeof CapitalGainScalarFieldEnum]


  export const InterestIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sourceType: 'sourceType',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    interestAmount: 'interestAmount',
    tdsDeducted: 'tdsDeducted',
    financialYear: 'financialYear',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterestIncomeScalarFieldEnum = (typeof InterestIncomeScalarFieldEnum)[keyof typeof InterestIncomeScalarFieldEnum]


  export const DividendIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    dividendAmount: 'dividendAmount',
    taxDeducted: 'taxDeducted',
    dateReceived: 'dateReceived',
    shareQuantity: 'shareQuantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DividendIncomeScalarFieldEnum = (typeof DividendIncomeScalarFieldEnum)[keyof typeof DividendIncomeScalarFieldEnum]


  export const BusinessIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessName: 'businessName',
    businessType: 'businessType',
    businessAddress: 'businessAddress',
    grossReceipts: 'grossReceipts',
    totalIncome: 'totalIncome',
    businessExpenses: 'businessExpenses',
    netProfit: 'netProfit',
    depreciationClaimed: 'depreciationClaimed',
    presumptiveIncome: 'presumptiveIncome',
    section44AD: 'section44AD',
    section44AE: 'section44AE',
    auditRequired: 'auditRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessIncomeScalarFieldEnum = (typeof BusinessIncomeScalarFieldEnum)[keyof typeof BusinessIncomeScalarFieldEnum]


  export const ProfessionalIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    professionType: 'professionType',
    grossReceipts: 'grossReceipts',
    totalExpenses: 'totalExpenses',
    netProfit: 'netProfit',
    section44ADA: 'section44ADA',
    presumptiveIncome: 'presumptiveIncome',
    auditRequired: 'auditRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfessionalIncomeScalarFieldEnum = (typeof ProfessionalIncomeScalarFieldEnum)[keyof typeof ProfessionalIncomeScalarFieldEnum]


  export const ProfitLossScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessIncomeId: 'businessIncomeId',
    year: 'year',
    income: 'income',
    expenses: 'expenses',
    netProfit: 'netProfit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfitLossScalarFieldEnum = (typeof ProfitLossScalarFieldEnum)[keyof typeof ProfitLossScalarFieldEnum]


  export const BalanceSheetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessIncomeId: 'businessIncomeId',
    year: 'year',
    assets: 'assets',
    liabilities: 'liabilities',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BalanceSheetScalarFieldEnum = (typeof BalanceSheetScalarFieldEnum)[keyof typeof BalanceSheetScalarFieldEnum]


  export const DepreciationEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    businessIncomeId: 'businessIncomeId',
    assetName: 'assetName',
    assetCategory: 'assetCategory',
    purchaseDate: 'purchaseDate',
    purchaseCost: 'purchaseCost',
    depreciationRate: 'depreciationRate',
    accumulatedDepreciation: 'accumulatedDepreciation',
    writtenDownValue: 'writtenDownValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepreciationEntryScalarFieldEnum = (typeof DepreciationEntryScalarFieldEnum)[keyof typeof DepreciationEntryScalarFieldEnum]


  export const CryptoIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assetType: 'assetType',
    coinName: 'coinName',
    purchaseDate: 'purchaseDate',
    saleDate: 'saleDate',
    purchasePrice: 'purchasePrice',
    salePrice: 'salePrice',
    quantity: 'quantity',
    exchangeName: 'exchangeName',
    transactionHash: 'transactionHash',
    profit: 'profit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoIncomeScalarFieldEnum = (typeof CryptoIncomeScalarFieldEnum)[keyof typeof CryptoIncomeScalarFieldEnum]


  export const AgriculturalIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    landArea: 'landArea',
    location: 'location',
    cropType: 'cropType',
    annualIncome: 'annualIncome',
    expenses: 'expenses',
    netIncome: 'netIncome',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgriculturalIncomeScalarFieldEnum = (typeof AgriculturalIncomeScalarFieldEnum)[keyof typeof AgriculturalIncomeScalarFieldEnum]


  export const ExemptIncomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    incomeType: 'incomeType',
    description: 'description',
    amount: 'amount',
    section: 'section',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExemptIncomeScalarFieldEnum = (typeof ExemptIncomeScalarFieldEnum)[keyof typeof ExemptIncomeScalarFieldEnum]


  export const TaxSavingInvestmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    section80C: 'section80C',
    savingsInterest80TTA: 'savingsInterest80TTA',
    pensionContribution80CCC: 'pensionContribution80CCC',
    npsEmployeeContribution: 'npsEmployeeContribution',
    npsEmployerContribution: 'npsEmployerContribution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxSavingInvestmentScalarFieldEnum = (typeof TaxSavingInvestmentScalarFieldEnum)[keyof typeof TaxSavingInvestmentScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationName: 'organizationName',
    donationType: 'donationType',
    amount: 'amount',
    date: 'date',
    receiptNumber: 'receiptNumber',
    eligibleAmount: 'eligibleAmount',
    deductionPercentage: 'deductionPercentage',
    section: 'section',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const MedicalInsuranceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    policyType: 'policyType',
    insuredPersons: 'insuredPersons',
    premiumPaid: 'premiumPaid',
    eligibleAmount: 'eligibleAmount',
    policyNumber: 'policyNumber',
    insuranceCompany: 'insuranceCompany',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalInsuranceScalarFieldEnum = (typeof MedicalInsuranceScalarFieldEnum)[keyof typeof MedicalInsuranceScalarFieldEnum]


  export const TaxPaidScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taxType: 'taxType',
    amount: 'amount',
    date: 'date',
    challanNumber: 'challanNumber',
    bankName: 'bankName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxPaidScalarFieldEnum = (typeof TaxPaidScalarFieldEnum)[keyof typeof TaxPaidScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    transactionType: 'transactionType',
    amount: 'amount',
    description: 'description',
    razorpayPaymentId: 'razorpayPaymentId',
    razorpayOrderId: 'razorpayOrderId',
    status: 'status',
    timestamp: 'timestamp'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const ITRGenerationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    itrType: 'itrType',
    assessmentYear: 'assessmentYear',
    fileName: 'fileName',
    checksum: 'checksum',
    jsonData: 'jsonData',
    status: 'status',
    generatedAt: 'generatedAt',
    downloadedAt: 'downloadedAt'
  };

  export type ITRGenerationScalarFieldEnum = (typeof ITRGenerationScalarFieldEnum)[keyof typeof ITRGenerationScalarFieldEnum]


  export const TaxSummaryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assessmentYear: 'assessmentYear',
    totalIncome: 'totalIncome',
    totalDeductions: 'totalDeductions',
    taxableIncome: 'taxableIncome',
    taxLiability: 'taxLiability',
    taxPaid: 'taxPaid',
    refundAmount: 'refundAmount',
    filingStatus: 'filingStatus',
    filingDate: 'filingDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxSummaryScalarFieldEnum = (typeof TaxSummaryScalarFieldEnum)[keyof typeof TaxSummaryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'ITRType'
   */
  export type EnumITRTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ITRType'>
    


  /**
   * Reference to a field of type 'ITRType[]'
   */
  export type ListEnumITRTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ITRType[]'>
    


  /**
   * Reference to a field of type 'ITRStatus'
   */
  export type EnumITRStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ITRStatus'>
    


  /**
   * Reference to a field of type 'ITRStatus[]'
   */
  export type ListEnumITRStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ITRStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    emailVerified?: BoolFilter<"User"> | boolean
    emailVerificationDate?: DateTimeNullableFilter<"User"> | Date | string | null
    lastVerificationEmailSent?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    personalDetails?: XOR<PersonalDetailNullableScalarRelationFilter, PersonalDetailWhereInput> | null
    contactDetails?: XOR<ContactDetailNullableScalarRelationFilter, ContactDetailWhereInput> | null
    bankDetails?: XOR<BankDetailNullableScalarRelationFilter, BankDetailWhereInput> | null
    addressDetails?: XOR<AddressDetailNullableScalarRelationFilter, AddressDetailWhereInput> | null
    form16Data?: Form16DataListRelationFilter
    properties?: PropertyListRelationFilter
    capitalGains?: CapitalGainListRelationFilter
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
    professionalIncome?: XOR<ProfessionalIncomeNullableScalarRelationFilter, ProfessionalIncomeWhereInput> | null
    cryptoIncome?: CryptoIncomeListRelationFilter
    taxSavingInvestments?: XOR<TaxSavingInvestmentNullableScalarRelationFilter, TaxSavingInvestmentWhereInput> | null
    donations?: DonationListRelationFilter
    medicalInsurance?: MedicalInsuranceListRelationFilter
    taxPaid?: TaxPaidListRelationFilter
    interestIncome?: InterestIncomeListRelationFilter
    dividendIncome?: DividendIncomeListRelationFilter
    agriculturalIncome?: AgriculturalIncomeListRelationFilter
    exemptIncome?: ExemptIncomeListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    itrGenerations?: ITRGenerationListRelationFilter
    taxSummaries?: TaxSummaryListRelationFilter
    profitLoss?: ProfitLossListRelationFilter
    balanceSheets?: BalanceSheetListRelationFilter
    depreciationEntries?: DepreciationEntryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    emailVerificationDate?: SortOrderInput | SortOrder
    lastVerificationEmailSent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personalDetails?: PersonalDetailOrderByWithRelationInput
    contactDetails?: ContactDetailOrderByWithRelationInput
    bankDetails?: BankDetailOrderByWithRelationInput
    addressDetails?: AddressDetailOrderByWithRelationInput
    form16Data?: Form16DataOrderByRelationAggregateInput
    properties?: PropertyOrderByRelationAggregateInput
    capitalGains?: CapitalGainOrderByRelationAggregateInput
    businessIncome?: BusinessIncomeOrderByWithRelationInput
    professionalIncome?: ProfessionalIncomeOrderByWithRelationInput
    cryptoIncome?: CryptoIncomeOrderByRelationAggregateInput
    taxSavingInvestments?: TaxSavingInvestmentOrderByWithRelationInput
    donations?: DonationOrderByRelationAggregateInput
    medicalInsurance?: MedicalInsuranceOrderByRelationAggregateInput
    taxPaid?: TaxPaidOrderByRelationAggregateInput
    interestIncome?: InterestIncomeOrderByRelationAggregateInput
    dividendIncome?: DividendIncomeOrderByRelationAggregateInput
    agriculturalIncome?: AgriculturalIncomeOrderByRelationAggregateInput
    exemptIncome?: ExemptIncomeOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    itrGenerations?: ITRGenerationOrderByRelationAggregateInput
    taxSummaries?: TaxSummaryOrderByRelationAggregateInput
    profitLoss?: ProfitLossOrderByRelationAggregateInput
    balanceSheets?: BalanceSheetOrderByRelationAggregateInput
    depreciationEntries?: DepreciationEntryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    emailVerified?: BoolFilter<"User"> | boolean
    emailVerificationDate?: DateTimeNullableFilter<"User"> | Date | string | null
    lastVerificationEmailSent?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    personalDetails?: XOR<PersonalDetailNullableScalarRelationFilter, PersonalDetailWhereInput> | null
    contactDetails?: XOR<ContactDetailNullableScalarRelationFilter, ContactDetailWhereInput> | null
    bankDetails?: XOR<BankDetailNullableScalarRelationFilter, BankDetailWhereInput> | null
    addressDetails?: XOR<AddressDetailNullableScalarRelationFilter, AddressDetailWhereInput> | null
    form16Data?: Form16DataListRelationFilter
    properties?: PropertyListRelationFilter
    capitalGains?: CapitalGainListRelationFilter
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
    professionalIncome?: XOR<ProfessionalIncomeNullableScalarRelationFilter, ProfessionalIncomeWhereInput> | null
    cryptoIncome?: CryptoIncomeListRelationFilter
    taxSavingInvestments?: XOR<TaxSavingInvestmentNullableScalarRelationFilter, TaxSavingInvestmentWhereInput> | null
    donations?: DonationListRelationFilter
    medicalInsurance?: MedicalInsuranceListRelationFilter
    taxPaid?: TaxPaidListRelationFilter
    interestIncome?: InterestIncomeListRelationFilter
    dividendIncome?: DividendIncomeListRelationFilter
    agriculturalIncome?: AgriculturalIncomeListRelationFilter
    exemptIncome?: ExemptIncomeListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    itrGenerations?: ITRGenerationListRelationFilter
    taxSummaries?: TaxSummaryListRelationFilter
    profitLoss?: ProfitLossListRelationFilter
    balanceSheets?: BalanceSheetListRelationFilter
    depreciationEntries?: DepreciationEntryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    emailVerificationDate?: SortOrderInput | SortOrder
    lastVerificationEmailSent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerificationDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastVerificationEmailSent?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PersonalDetailWhereInput = {
    AND?: PersonalDetailWhereInput | PersonalDetailWhereInput[]
    OR?: PersonalDetailWhereInput[]
    NOT?: PersonalDetailWhereInput | PersonalDetailWhereInput[]
    id?: StringFilter<"PersonalDetail"> | string
    userId?: StringFilter<"PersonalDetail"> | string
    firstName?: StringNullableFilter<"PersonalDetail"> | string | null
    middleName?: StringNullableFilter<"PersonalDetail"> | string | null
    lastName?: StringNullableFilter<"PersonalDetail"> | string | null
    dob?: DateTimeNullableFilter<"PersonalDetail"> | Date | string | null
    gender?: EnumGenderNullableFilter<"PersonalDetail"> | $Enums.Gender | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"PersonalDetail"> | $Enums.MaritalStatus | null
    createdAt?: DateTimeFilter<"PersonalDetail"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PersonalDetailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PersonalDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PersonalDetailWhereInput | PersonalDetailWhereInput[]
    OR?: PersonalDetailWhereInput[]
    NOT?: PersonalDetailWhereInput | PersonalDetailWhereInput[]
    firstName?: StringNullableFilter<"PersonalDetail"> | string | null
    middleName?: StringNullableFilter<"PersonalDetail"> | string | null
    lastName?: StringNullableFilter<"PersonalDetail"> | string | null
    dob?: DateTimeNullableFilter<"PersonalDetail"> | Date | string | null
    gender?: EnumGenderNullableFilter<"PersonalDetail"> | $Enums.Gender | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"PersonalDetail"> | $Enums.MaritalStatus | null
    createdAt?: DateTimeFilter<"PersonalDetail"> | Date | string
    updatedAt?: DateTimeFilter<"PersonalDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PersonalDetailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonalDetailCountOrderByAggregateInput
    _max?: PersonalDetailMaxOrderByAggregateInput
    _min?: PersonalDetailMinOrderByAggregateInput
  }

  export type PersonalDetailScalarWhereWithAggregatesInput = {
    AND?: PersonalDetailScalarWhereWithAggregatesInput | PersonalDetailScalarWhereWithAggregatesInput[]
    OR?: PersonalDetailScalarWhereWithAggregatesInput[]
    NOT?: PersonalDetailScalarWhereWithAggregatesInput | PersonalDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalDetail"> | string
    userId?: StringWithAggregatesFilter<"PersonalDetail"> | string
    firstName?: StringNullableWithAggregatesFilter<"PersonalDetail"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"PersonalDetail"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"PersonalDetail"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"PersonalDetail"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"PersonalDetail"> | $Enums.Gender | null
    maritalStatus?: EnumMaritalStatusNullableWithAggregatesFilter<"PersonalDetail"> | $Enums.MaritalStatus | null
    createdAt?: DateTimeWithAggregatesFilter<"PersonalDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonalDetail"> | Date | string
  }

  export type ContactDetailWhereInput = {
    AND?: ContactDetailWhereInput | ContactDetailWhereInput[]
    OR?: ContactDetailWhereInput[]
    NOT?: ContactDetailWhereInput | ContactDetailWhereInput[]
    id?: StringFilter<"ContactDetail"> | string
    userId?: StringFilter<"ContactDetail"> | string
    email?: StringNullableFilter<"ContactDetail"> | string | null
    phone?: StringNullableFilter<"ContactDetail"> | string | null
    panNumber?: StringNullableFilter<"ContactDetail"> | string | null
    aadharNumber?: StringNullableFilter<"ContactDetail"> | string | null
    alternativeEmail?: StringNullableFilter<"ContactDetail"> | string | null
    alternativePhone?: StringNullableFilter<"ContactDetail"> | string | null
    createdAt?: DateTimeFilter<"ContactDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ContactDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContactDetailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    alternativeEmail?: SortOrderInput | SortOrder
    alternativePhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ContactDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ContactDetailWhereInput | ContactDetailWhereInput[]
    OR?: ContactDetailWhereInput[]
    NOT?: ContactDetailWhereInput | ContactDetailWhereInput[]
    email?: StringNullableFilter<"ContactDetail"> | string | null
    phone?: StringNullableFilter<"ContactDetail"> | string | null
    panNumber?: StringNullableFilter<"ContactDetail"> | string | null
    aadharNumber?: StringNullableFilter<"ContactDetail"> | string | null
    alternativeEmail?: StringNullableFilter<"ContactDetail"> | string | null
    alternativePhone?: StringNullableFilter<"ContactDetail"> | string | null
    createdAt?: DateTimeFilter<"ContactDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ContactDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ContactDetailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    panNumber?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    alternativeEmail?: SortOrderInput | SortOrder
    alternativePhone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactDetailCountOrderByAggregateInput
    _max?: ContactDetailMaxOrderByAggregateInput
    _min?: ContactDetailMinOrderByAggregateInput
  }

  export type ContactDetailScalarWhereWithAggregatesInput = {
    AND?: ContactDetailScalarWhereWithAggregatesInput | ContactDetailScalarWhereWithAggregatesInput[]
    OR?: ContactDetailScalarWhereWithAggregatesInput[]
    NOT?: ContactDetailScalarWhereWithAggregatesInput | ContactDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactDetail"> | string
    userId?: StringWithAggregatesFilter<"ContactDetail"> | string
    email?: StringNullableWithAggregatesFilter<"ContactDetail"> | string | null
    phone?: StringNullableWithAggregatesFilter<"ContactDetail"> | string | null
    panNumber?: StringNullableWithAggregatesFilter<"ContactDetail"> | string | null
    aadharNumber?: StringNullableWithAggregatesFilter<"ContactDetail"> | string | null
    alternativeEmail?: StringNullableWithAggregatesFilter<"ContactDetail"> | string | null
    alternativePhone?: StringNullableWithAggregatesFilter<"ContactDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactDetail"> | Date | string
  }

  export type AddressDetailWhereInput = {
    AND?: AddressDetailWhereInput | AddressDetailWhereInput[]
    OR?: AddressDetailWhereInput[]
    NOT?: AddressDetailWhereInput | AddressDetailWhereInput[]
    id?: StringFilter<"AddressDetail"> | string
    userId?: StringFilter<"AddressDetail"> | string
    flatNo?: StringNullableFilter<"AddressDetail"> | string | null
    premiseName?: StringNullableFilter<"AddressDetail"> | string | null
    road?: StringNullableFilter<"AddressDetail"> | string | null
    area?: StringNullableFilter<"AddressDetail"> | string | null
    pincode?: StringNullableFilter<"AddressDetail"> | string | null
    country?: StringNullableFilter<"AddressDetail"> | string | null
    state?: StringNullableFilter<"AddressDetail"> | string | null
    city?: StringNullableFilter<"AddressDetail"> | string | null
    createdAt?: DateTimeFilter<"AddressDetail"> | Date | string
    updatedAt?: DateTimeFilter<"AddressDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AddressDetailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    flatNo?: SortOrderInput | SortOrder
    premiseName?: SortOrderInput | SortOrder
    road?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AddressDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AddressDetailWhereInput | AddressDetailWhereInput[]
    OR?: AddressDetailWhereInput[]
    NOT?: AddressDetailWhereInput | AddressDetailWhereInput[]
    flatNo?: StringNullableFilter<"AddressDetail"> | string | null
    premiseName?: StringNullableFilter<"AddressDetail"> | string | null
    road?: StringNullableFilter<"AddressDetail"> | string | null
    area?: StringNullableFilter<"AddressDetail"> | string | null
    pincode?: StringNullableFilter<"AddressDetail"> | string | null
    country?: StringNullableFilter<"AddressDetail"> | string | null
    state?: StringNullableFilter<"AddressDetail"> | string | null
    city?: StringNullableFilter<"AddressDetail"> | string | null
    createdAt?: DateTimeFilter<"AddressDetail"> | Date | string
    updatedAt?: DateTimeFilter<"AddressDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AddressDetailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    flatNo?: SortOrderInput | SortOrder
    premiseName?: SortOrderInput | SortOrder
    road?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressDetailCountOrderByAggregateInput
    _max?: AddressDetailMaxOrderByAggregateInput
    _min?: AddressDetailMinOrderByAggregateInput
  }

  export type AddressDetailScalarWhereWithAggregatesInput = {
    AND?: AddressDetailScalarWhereWithAggregatesInput | AddressDetailScalarWhereWithAggregatesInput[]
    OR?: AddressDetailScalarWhereWithAggregatesInput[]
    NOT?: AddressDetailScalarWhereWithAggregatesInput | AddressDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddressDetail"> | string
    userId?: StringWithAggregatesFilter<"AddressDetail"> | string
    flatNo?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    premiseName?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    road?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    area?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    country?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    state?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    city?: StringNullableWithAggregatesFilter<"AddressDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AddressDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddressDetail"> | Date | string
  }

  export type BankDetailWhereInput = {
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    id?: StringFilter<"BankDetail"> | string
    userId?: StringFilter<"BankDetail"> | string
    accountNumber?: StringNullableFilter<"BankDetail"> | string | null
    ifscCode?: StringNullableFilter<"BankDetail"> | string | null
    bankName?: StringNullableFilter<"BankDetail"> | string | null
    accountType?: StringNullableFilter<"BankDetail"> | string | null
    accountHolderName?: StringNullableFilter<"BankDetail"> | string | null
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BankDetailOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    accountHolderName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BankDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    accountNumber?: StringNullableFilter<"BankDetail"> | string | null
    ifscCode?: StringNullableFilter<"BankDetail"> | string | null
    bankName?: StringNullableFilter<"BankDetail"> | string | null
    accountType?: StringNullableFilter<"BankDetail"> | string | null
    accountHolderName?: StringNullableFilter<"BankDetail"> | string | null
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type BankDetailOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    ifscCode?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    accountHolderName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankDetailCountOrderByAggregateInput
    _max?: BankDetailMaxOrderByAggregateInput
    _min?: BankDetailMinOrderByAggregateInput
  }

  export type BankDetailScalarWhereWithAggregatesInput = {
    AND?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    OR?: BankDetailScalarWhereWithAggregatesInput[]
    NOT?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankDetail"> | string
    userId?: StringWithAggregatesFilter<"BankDetail"> | string
    accountNumber?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    ifscCode?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    accountType?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    accountHolderName?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
  }

  export type Form16DataWhereInput = {
    AND?: Form16DataWhereInput | Form16DataWhereInput[]
    OR?: Form16DataWhereInput[]
    NOT?: Form16DataWhereInput | Form16DataWhereInput[]
    id?: StringFilter<"Form16Data"> | string
    userId?: StringFilter<"Form16Data"> | string
    employerName?: StringNullableFilter<"Form16Data"> | string | null
    employerTAN?: StringNullableFilter<"Form16Data"> | string | null
    employerCategory?: StringNullableFilter<"Form16Data"> | string | null
    totalTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    grossSalary?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: JsonNullableFilter<"Form16Data">
    perquisitesAmount?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    perquisites?: JsonNullableFilter<"Form16Data">
    profitAmount?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: JsonNullableFilter<"Form16Data">
    notifiedCountry?: JsonNullableFilter<"Form16Data">
    notifiedIncomeOtherCountry?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: JsonNullableFilter<"Form16Data">
    balance?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    professionalTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    address?: JsonNullableFilter<"Form16Data">
    createdAt?: DateTimeFilter<"Form16Data"> | Date | string
    updatedAt?: DateTimeFilter<"Form16Data"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type Form16DataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employerName?: SortOrderInput | SortOrder
    employerTAN?: SortOrderInput | SortOrder
    employerCategory?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    grossSalary?: SortOrderInput | SortOrder
    notifiedIncome?: SortOrderInput | SortOrder
    salaryBreakup?: SortOrderInput | SortOrder
    perquisitesAmount?: SortOrderInput | SortOrder
    perquisites?: SortOrderInput | SortOrder
    profitAmount?: SortOrderInput | SortOrder
    profitsInLieu?: SortOrderInput | SortOrder
    notifiedCountry?: SortOrderInput | SortOrder
    notifiedIncomeOtherCountry?: SortOrderInput | SortOrder
    previousYearIncomeTax?: SortOrderInput | SortOrder
    exemptAllowance?: SortOrderInput | SortOrder
    exemptAllowanceBreakup?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    standardDeduction?: SortOrderInput | SortOrder
    professionalTax?: SortOrderInput | SortOrder
    reliefUnder89?: SortOrderInput | SortOrder
    incomeClaimed?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type Form16DataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Form16DataWhereInput | Form16DataWhereInput[]
    OR?: Form16DataWhereInput[]
    NOT?: Form16DataWhereInput | Form16DataWhereInput[]
    userId?: StringFilter<"Form16Data"> | string
    employerName?: StringNullableFilter<"Form16Data"> | string | null
    employerTAN?: StringNullableFilter<"Form16Data"> | string | null
    employerCategory?: StringNullableFilter<"Form16Data"> | string | null
    totalTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    grossSalary?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: JsonNullableFilter<"Form16Data">
    perquisitesAmount?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    perquisites?: JsonNullableFilter<"Form16Data">
    profitAmount?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: JsonNullableFilter<"Form16Data">
    notifiedCountry?: JsonNullableFilter<"Form16Data">
    notifiedIncomeOtherCountry?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: JsonNullableFilter<"Form16Data">
    balance?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    professionalTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    address?: JsonNullableFilter<"Form16Data">
    createdAt?: DateTimeFilter<"Form16Data"> | Date | string
    updatedAt?: DateTimeFilter<"Form16Data"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type Form16DataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employerName?: SortOrderInput | SortOrder
    employerTAN?: SortOrderInput | SortOrder
    employerCategory?: SortOrderInput | SortOrder
    totalTax?: SortOrderInput | SortOrder
    grossSalary?: SortOrderInput | SortOrder
    notifiedIncome?: SortOrderInput | SortOrder
    salaryBreakup?: SortOrderInput | SortOrder
    perquisitesAmount?: SortOrderInput | SortOrder
    perquisites?: SortOrderInput | SortOrder
    profitAmount?: SortOrderInput | SortOrder
    profitsInLieu?: SortOrderInput | SortOrder
    notifiedCountry?: SortOrderInput | SortOrder
    notifiedIncomeOtherCountry?: SortOrderInput | SortOrder
    previousYearIncomeTax?: SortOrderInput | SortOrder
    exemptAllowance?: SortOrderInput | SortOrder
    exemptAllowanceBreakup?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    standardDeduction?: SortOrderInput | SortOrder
    professionalTax?: SortOrderInput | SortOrder
    reliefUnder89?: SortOrderInput | SortOrder
    incomeClaimed?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Form16DataCountOrderByAggregateInput
    _avg?: Form16DataAvgOrderByAggregateInput
    _max?: Form16DataMaxOrderByAggregateInput
    _min?: Form16DataMinOrderByAggregateInput
    _sum?: Form16DataSumOrderByAggregateInput
  }

  export type Form16DataScalarWhereWithAggregatesInput = {
    AND?: Form16DataScalarWhereWithAggregatesInput | Form16DataScalarWhereWithAggregatesInput[]
    OR?: Form16DataScalarWhereWithAggregatesInput[]
    NOT?: Form16DataScalarWhereWithAggregatesInput | Form16DataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Form16Data"> | string
    userId?: StringWithAggregatesFilter<"Form16Data"> | string
    employerName?: StringNullableWithAggregatesFilter<"Form16Data"> | string | null
    employerTAN?: StringNullableWithAggregatesFilter<"Form16Data"> | string | null
    employerCategory?: StringNullableWithAggregatesFilter<"Form16Data"> | string | null
    totalTax?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    grossSalary?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: JsonNullableWithAggregatesFilter<"Form16Data">
    perquisitesAmount?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    perquisites?: JsonNullableWithAggregatesFilter<"Form16Data">
    profitAmount?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: JsonNullableWithAggregatesFilter<"Form16Data">
    notifiedCountry?: JsonNullableWithAggregatesFilter<"Form16Data">
    notifiedIncomeOtherCountry?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: JsonNullableWithAggregatesFilter<"Form16Data">
    balance?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    professionalTax?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: DecimalNullableWithAggregatesFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    address?: JsonNullableWithAggregatesFilter<"Form16Data">
    createdAt?: DateTimeWithAggregatesFilter<"Form16Data"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Form16Data"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    userId?: StringFilter<"Property"> | string
    propertyIndex?: StringNullableFilter<"Property"> | string | null
    propertyType?: StringNullableFilter<"Property"> | string | null
    netTaxableIncome?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    houseAddress?: JsonNullableFilter<"Property">
    ownerDetails?: JsonNullableFilter<"Property">
    taxSavings?: JsonNullableFilter<"Property">
    rentalIncomeDetails?: JsonNullableFilter<"Property">
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyIndex?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    netTaxableIncome?: SortOrderInput | SortOrder
    houseAddress?: SortOrderInput | SortOrder
    ownerDetails?: SortOrderInput | SortOrder
    taxSavings?: SortOrderInput | SortOrder
    rentalIncomeDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    userId?: StringFilter<"Property"> | string
    propertyIndex?: StringNullableFilter<"Property"> | string | null
    propertyType?: StringNullableFilter<"Property"> | string | null
    netTaxableIncome?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    houseAddress?: JsonNullableFilter<"Property">
    ownerDetails?: JsonNullableFilter<"Property">
    taxSavings?: JsonNullableFilter<"Property">
    rentalIncomeDetails?: JsonNullableFilter<"Property">
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyIndex?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    netTaxableIncome?: SortOrderInput | SortOrder
    houseAddress?: SortOrderInput | SortOrder
    ownerDetails?: SortOrderInput | SortOrder
    taxSavings?: SortOrderInput | SortOrder
    rentalIncomeDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    userId?: StringWithAggregatesFilter<"Property"> | string
    propertyIndex?: StringNullableWithAggregatesFilter<"Property"> | string | null
    propertyType?: StringNullableWithAggregatesFilter<"Property"> | string | null
    netTaxableIncome?: DecimalNullableWithAggregatesFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    houseAddress?: JsonNullableWithAggregatesFilter<"Property">
    ownerDetails?: JsonNullableWithAggregatesFilter<"Property">
    taxSavings?: JsonNullableWithAggregatesFilter<"Property">
    rentalIncomeDetails?: JsonNullableWithAggregatesFilter<"Property">
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type CapitalGainWhereInput = {
    AND?: CapitalGainWhereInput | CapitalGainWhereInput[]
    OR?: CapitalGainWhereInput[]
    NOT?: CapitalGainWhereInput | CapitalGainWhereInput[]
    id?: StringFilter<"CapitalGain"> | string
    userId?: StringFilter<"CapitalGain"> | string
    assetType?: StringNullableFilter<"CapitalGain"> | string | null
    assetSubType?: StringNullableFilter<"CapitalGain"> | string | null
    dateOfSale?: DateTimeNullableFilter<"CapitalGain"> | Date | string | null
    dateOfPurchase?: DateTimeNullableFilter<"CapitalGain"> | Date | string | null
    description?: StringNullableFilter<"CapitalGain"> | string | null
    salePrice?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFilter<"CapitalGain"> | boolean
    totalProfit?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    indexationCost?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CapitalGain"> | Date | string
    updatedAt?: DateTimeFilter<"CapitalGain"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CapitalGainOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrderInput | SortOrder
    assetSubType?: SortOrderInput | SortOrder
    dateOfSale?: SortOrderInput | SortOrder
    dateOfPurchase?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    salePrice?: SortOrderInput | SortOrder
    transferExpenses?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    sttPaid?: SortOrder
    totalProfit?: SortOrderInput | SortOrder
    indexationCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CapitalGainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CapitalGainWhereInput | CapitalGainWhereInput[]
    OR?: CapitalGainWhereInput[]
    NOT?: CapitalGainWhereInput | CapitalGainWhereInput[]
    userId?: StringFilter<"CapitalGain"> | string
    assetType?: StringNullableFilter<"CapitalGain"> | string | null
    assetSubType?: StringNullableFilter<"CapitalGain"> | string | null
    dateOfSale?: DateTimeNullableFilter<"CapitalGain"> | Date | string | null
    dateOfPurchase?: DateTimeNullableFilter<"CapitalGain"> | Date | string | null
    description?: StringNullableFilter<"CapitalGain"> | string | null
    salePrice?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFilter<"CapitalGain"> | boolean
    totalProfit?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    indexationCost?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CapitalGain"> | Date | string
    updatedAt?: DateTimeFilter<"CapitalGain"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CapitalGainOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrderInput | SortOrder
    assetSubType?: SortOrderInput | SortOrder
    dateOfSale?: SortOrderInput | SortOrder
    dateOfPurchase?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    salePrice?: SortOrderInput | SortOrder
    transferExpenses?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    sttPaid?: SortOrder
    totalProfit?: SortOrderInput | SortOrder
    indexationCost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CapitalGainCountOrderByAggregateInput
    _avg?: CapitalGainAvgOrderByAggregateInput
    _max?: CapitalGainMaxOrderByAggregateInput
    _min?: CapitalGainMinOrderByAggregateInput
    _sum?: CapitalGainSumOrderByAggregateInput
  }

  export type CapitalGainScalarWhereWithAggregatesInput = {
    AND?: CapitalGainScalarWhereWithAggregatesInput | CapitalGainScalarWhereWithAggregatesInput[]
    OR?: CapitalGainScalarWhereWithAggregatesInput[]
    NOT?: CapitalGainScalarWhereWithAggregatesInput | CapitalGainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CapitalGain"> | string
    userId?: StringWithAggregatesFilter<"CapitalGain"> | string
    assetType?: StringNullableWithAggregatesFilter<"CapitalGain"> | string | null
    assetSubType?: StringNullableWithAggregatesFilter<"CapitalGain"> | string | null
    dateOfSale?: DateTimeNullableWithAggregatesFilter<"CapitalGain"> | Date | string | null
    dateOfPurchase?: DateTimeNullableWithAggregatesFilter<"CapitalGain"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"CapitalGain"> | string | null
    salePrice?: DecimalNullableWithAggregatesFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: DecimalNullableWithAggregatesFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableWithAggregatesFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolWithAggregatesFilter<"CapitalGain"> | boolean
    totalProfit?: DecimalNullableWithAggregatesFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    indexationCost?: DecimalNullableWithAggregatesFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CapitalGain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CapitalGain"> | Date | string
  }

  export type InterestIncomeWhereInput = {
    AND?: InterestIncomeWhereInput | InterestIncomeWhereInput[]
    OR?: InterestIncomeWhereInput[]
    NOT?: InterestIncomeWhereInput | InterestIncomeWhereInput[]
    id?: StringFilter<"InterestIncome"> | string
    userId?: StringFilter<"InterestIncome"> | string
    sourceType?: StringNullableFilter<"InterestIncome"> | string | null
    bankName?: StringNullableFilter<"InterestIncome"> | string | null
    accountNumber?: StringNullableFilter<"InterestIncome"> | string | null
    interestAmount?: DecimalNullableFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: DecimalNullableFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    financialYear?: StringNullableFilter<"InterestIncome"> | string | null
    createdAt?: DateTimeFilter<"InterestIncome"> | Date | string
    updatedAt?: DateTimeFilter<"InterestIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InterestIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    interestAmount?: SortOrderInput | SortOrder
    tdsDeducted?: SortOrderInput | SortOrder
    financialYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InterestIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterestIncomeWhereInput | InterestIncomeWhereInput[]
    OR?: InterestIncomeWhereInput[]
    NOT?: InterestIncomeWhereInput | InterestIncomeWhereInput[]
    userId?: StringFilter<"InterestIncome"> | string
    sourceType?: StringNullableFilter<"InterestIncome"> | string | null
    bankName?: StringNullableFilter<"InterestIncome"> | string | null
    accountNumber?: StringNullableFilter<"InterestIncome"> | string | null
    interestAmount?: DecimalNullableFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: DecimalNullableFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    financialYear?: StringNullableFilter<"InterestIncome"> | string | null
    createdAt?: DateTimeFilter<"InterestIncome"> | Date | string
    updatedAt?: DateTimeFilter<"InterestIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InterestIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountNumber?: SortOrderInput | SortOrder
    interestAmount?: SortOrderInput | SortOrder
    tdsDeducted?: SortOrderInput | SortOrder
    financialYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterestIncomeCountOrderByAggregateInput
    _avg?: InterestIncomeAvgOrderByAggregateInput
    _max?: InterestIncomeMaxOrderByAggregateInput
    _min?: InterestIncomeMinOrderByAggregateInput
    _sum?: InterestIncomeSumOrderByAggregateInput
  }

  export type InterestIncomeScalarWhereWithAggregatesInput = {
    AND?: InterestIncomeScalarWhereWithAggregatesInput | InterestIncomeScalarWhereWithAggregatesInput[]
    OR?: InterestIncomeScalarWhereWithAggregatesInput[]
    NOT?: InterestIncomeScalarWhereWithAggregatesInput | InterestIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterestIncome"> | string
    userId?: StringWithAggregatesFilter<"InterestIncome"> | string
    sourceType?: StringNullableWithAggregatesFilter<"InterestIncome"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"InterestIncome"> | string | null
    accountNumber?: StringNullableWithAggregatesFilter<"InterestIncome"> | string | null
    interestAmount?: DecimalNullableWithAggregatesFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: DecimalNullableWithAggregatesFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    financialYear?: StringNullableWithAggregatesFilter<"InterestIncome"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InterestIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InterestIncome"> | Date | string
  }

  export type DividendIncomeWhereInput = {
    AND?: DividendIncomeWhereInput | DividendIncomeWhereInput[]
    OR?: DividendIncomeWhereInput[]
    NOT?: DividendIncomeWhereInput | DividendIncomeWhereInput[]
    id?: StringFilter<"DividendIncome"> | string
    userId?: StringFilter<"DividendIncome"> | string
    companyName?: StringNullableFilter<"DividendIncome"> | string | null
    dividendAmount?: DecimalNullableFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: DecimalNullableFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    dateReceived?: DateTimeNullableFilter<"DividendIncome"> | Date | string | null
    shareQuantity?: IntNullableFilter<"DividendIncome"> | number | null
    createdAt?: DateTimeFilter<"DividendIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DividendIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DividendIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    dividendAmount?: SortOrderInput | SortOrder
    taxDeducted?: SortOrderInput | SortOrder
    dateReceived?: SortOrderInput | SortOrder
    shareQuantity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DividendIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DividendIncomeWhereInput | DividendIncomeWhereInput[]
    OR?: DividendIncomeWhereInput[]
    NOT?: DividendIncomeWhereInput | DividendIncomeWhereInput[]
    userId?: StringFilter<"DividendIncome"> | string
    companyName?: StringNullableFilter<"DividendIncome"> | string | null
    dividendAmount?: DecimalNullableFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: DecimalNullableFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    dateReceived?: DateTimeNullableFilter<"DividendIncome"> | Date | string | null
    shareQuantity?: IntNullableFilter<"DividendIncome"> | number | null
    createdAt?: DateTimeFilter<"DividendIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DividendIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DividendIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    dividendAmount?: SortOrderInput | SortOrder
    taxDeducted?: SortOrderInput | SortOrder
    dateReceived?: SortOrderInput | SortOrder
    shareQuantity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DividendIncomeCountOrderByAggregateInput
    _avg?: DividendIncomeAvgOrderByAggregateInput
    _max?: DividendIncomeMaxOrderByAggregateInput
    _min?: DividendIncomeMinOrderByAggregateInput
    _sum?: DividendIncomeSumOrderByAggregateInput
  }

  export type DividendIncomeScalarWhereWithAggregatesInput = {
    AND?: DividendIncomeScalarWhereWithAggregatesInput | DividendIncomeScalarWhereWithAggregatesInput[]
    OR?: DividendIncomeScalarWhereWithAggregatesInput[]
    NOT?: DividendIncomeScalarWhereWithAggregatesInput | DividendIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DividendIncome"> | string
    userId?: StringWithAggregatesFilter<"DividendIncome"> | string
    companyName?: StringNullableWithAggregatesFilter<"DividendIncome"> | string | null
    dividendAmount?: DecimalNullableWithAggregatesFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: DecimalNullableWithAggregatesFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    dateReceived?: DateTimeNullableWithAggregatesFilter<"DividendIncome"> | Date | string | null
    shareQuantity?: IntNullableWithAggregatesFilter<"DividendIncome"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"DividendIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DividendIncome"> | Date | string
  }

  export type BusinessIncomeWhereInput = {
    AND?: BusinessIncomeWhereInput | BusinessIncomeWhereInput[]
    OR?: BusinessIncomeWhereInput[]
    NOT?: BusinessIncomeWhereInput | BusinessIncomeWhereInput[]
    id?: StringFilter<"BusinessIncome"> | string
    userId?: StringFilter<"BusinessIncome"> | string
    businessName?: StringNullableFilter<"BusinessIncome"> | string | null
    businessType?: StringNullableFilter<"BusinessIncome"> | string | null
    businessAddress?: StringNullableFilter<"BusinessIncome"> | string | null
    grossReceipts?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    totalIncome?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    netProfit?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFilter<"BusinessIncome"> | boolean
    section44AE?: BoolFilter<"BusinessIncome"> | boolean
    auditRequired?: BoolFilter<"BusinessIncome"> | boolean
    createdAt?: DateTimeFilter<"BusinessIncome"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profitLoss?: ProfitLossListRelationFilter
    balanceSheet?: BalanceSheetListRelationFilter
    depreciation?: DepreciationEntryListRelationFilter
  }

  export type BusinessIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    grossReceipts?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    businessExpenses?: SortOrderInput | SortOrder
    netProfit?: SortOrderInput | SortOrder
    depreciationClaimed?: SortOrderInput | SortOrder
    presumptiveIncome?: SortOrderInput | SortOrder
    section44AD?: SortOrder
    section44AE?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    profitLoss?: ProfitLossOrderByRelationAggregateInput
    balanceSheet?: BalanceSheetOrderByRelationAggregateInput
    depreciation?: DepreciationEntryOrderByRelationAggregateInput
  }

  export type BusinessIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: BusinessIncomeWhereInput | BusinessIncomeWhereInput[]
    OR?: BusinessIncomeWhereInput[]
    NOT?: BusinessIncomeWhereInput | BusinessIncomeWhereInput[]
    businessName?: StringNullableFilter<"BusinessIncome"> | string | null
    businessType?: StringNullableFilter<"BusinessIncome"> | string | null
    businessAddress?: StringNullableFilter<"BusinessIncome"> | string | null
    grossReceipts?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    totalIncome?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    netProfit?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: DecimalNullableFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFilter<"BusinessIncome"> | boolean
    section44AE?: BoolFilter<"BusinessIncome"> | boolean
    auditRequired?: BoolFilter<"BusinessIncome"> | boolean
    createdAt?: DateTimeFilter<"BusinessIncome"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profitLoss?: ProfitLossListRelationFilter
    balanceSheet?: BalanceSheetListRelationFilter
    depreciation?: DepreciationEntryListRelationFilter
  }, "id" | "userId">

  export type BusinessIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    businessAddress?: SortOrderInput | SortOrder
    grossReceipts?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    businessExpenses?: SortOrderInput | SortOrder
    netProfit?: SortOrderInput | SortOrder
    depreciationClaimed?: SortOrderInput | SortOrder
    presumptiveIncome?: SortOrderInput | SortOrder
    section44AD?: SortOrder
    section44AE?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessIncomeCountOrderByAggregateInput
    _avg?: BusinessIncomeAvgOrderByAggregateInput
    _max?: BusinessIncomeMaxOrderByAggregateInput
    _min?: BusinessIncomeMinOrderByAggregateInput
    _sum?: BusinessIncomeSumOrderByAggregateInput
  }

  export type BusinessIncomeScalarWhereWithAggregatesInput = {
    AND?: BusinessIncomeScalarWhereWithAggregatesInput | BusinessIncomeScalarWhereWithAggregatesInput[]
    OR?: BusinessIncomeScalarWhereWithAggregatesInput[]
    NOT?: BusinessIncomeScalarWhereWithAggregatesInput | BusinessIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessIncome"> | string
    userId?: StringWithAggregatesFilter<"BusinessIncome"> | string
    businessName?: StringNullableWithAggregatesFilter<"BusinessIncome"> | string | null
    businessType?: StringNullableWithAggregatesFilter<"BusinessIncome"> | string | null
    businessAddress?: StringNullableWithAggregatesFilter<"BusinessIncome"> | string | null
    grossReceipts?: DecimalNullableWithAggregatesFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    totalIncome?: DecimalNullableWithAggregatesFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: DecimalNullableWithAggregatesFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    netProfit?: DecimalNullableWithAggregatesFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: DecimalNullableWithAggregatesFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: DecimalNullableWithAggregatesFilter<"BusinessIncome"> | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolWithAggregatesFilter<"BusinessIncome"> | boolean
    section44AE?: BoolWithAggregatesFilter<"BusinessIncome"> | boolean
    auditRequired?: BoolWithAggregatesFilter<"BusinessIncome"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BusinessIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessIncome"> | Date | string
  }

  export type ProfessionalIncomeWhereInput = {
    AND?: ProfessionalIncomeWhereInput | ProfessionalIncomeWhereInput[]
    OR?: ProfessionalIncomeWhereInput[]
    NOT?: ProfessionalIncomeWhereInput | ProfessionalIncomeWhereInput[]
    id?: StringFilter<"ProfessionalIncome"> | string
    userId?: StringFilter<"ProfessionalIncome"> | string
    professionType?: StringNullableFilter<"ProfessionalIncome"> | string | null
    grossReceipts?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    netProfit?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFilter<"ProfessionalIncome"> | boolean
    presumptiveIncome?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFilter<"ProfessionalIncome"> | boolean
    createdAt?: DateTimeFilter<"ProfessionalIncome"> | Date | string
    updatedAt?: DateTimeFilter<"ProfessionalIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfessionalIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    professionType?: SortOrderInput | SortOrder
    grossReceipts?: SortOrderInput | SortOrder
    totalExpenses?: SortOrderInput | SortOrder
    netProfit?: SortOrderInput | SortOrder
    section44ADA?: SortOrder
    presumptiveIncome?: SortOrderInput | SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfessionalIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfessionalIncomeWhereInput | ProfessionalIncomeWhereInput[]
    OR?: ProfessionalIncomeWhereInput[]
    NOT?: ProfessionalIncomeWhereInput | ProfessionalIncomeWhereInput[]
    professionType?: StringNullableFilter<"ProfessionalIncome"> | string | null
    grossReceipts?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    netProfit?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFilter<"ProfessionalIncome"> | boolean
    presumptiveIncome?: DecimalNullableFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFilter<"ProfessionalIncome"> | boolean
    createdAt?: DateTimeFilter<"ProfessionalIncome"> | Date | string
    updatedAt?: DateTimeFilter<"ProfessionalIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfessionalIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    professionType?: SortOrderInput | SortOrder
    grossReceipts?: SortOrderInput | SortOrder
    totalExpenses?: SortOrderInput | SortOrder
    netProfit?: SortOrderInput | SortOrder
    section44ADA?: SortOrder
    presumptiveIncome?: SortOrderInput | SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfessionalIncomeCountOrderByAggregateInput
    _avg?: ProfessionalIncomeAvgOrderByAggregateInput
    _max?: ProfessionalIncomeMaxOrderByAggregateInput
    _min?: ProfessionalIncomeMinOrderByAggregateInput
    _sum?: ProfessionalIncomeSumOrderByAggregateInput
  }

  export type ProfessionalIncomeScalarWhereWithAggregatesInput = {
    AND?: ProfessionalIncomeScalarWhereWithAggregatesInput | ProfessionalIncomeScalarWhereWithAggregatesInput[]
    OR?: ProfessionalIncomeScalarWhereWithAggregatesInput[]
    NOT?: ProfessionalIncomeScalarWhereWithAggregatesInput | ProfessionalIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfessionalIncome"> | string
    userId?: StringWithAggregatesFilter<"ProfessionalIncome"> | string
    professionType?: StringNullableWithAggregatesFilter<"ProfessionalIncome"> | string | null
    grossReceipts?: DecimalNullableWithAggregatesFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: DecimalNullableWithAggregatesFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    netProfit?: DecimalNullableWithAggregatesFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolWithAggregatesFilter<"ProfessionalIncome"> | boolean
    presumptiveIncome?: DecimalNullableWithAggregatesFilter<"ProfessionalIncome"> | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolWithAggregatesFilter<"ProfessionalIncome"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProfessionalIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfessionalIncome"> | Date | string
  }

  export type ProfitLossWhereInput = {
    AND?: ProfitLossWhereInput | ProfitLossWhereInput[]
    OR?: ProfitLossWhereInput[]
    NOT?: ProfitLossWhereInput | ProfitLossWhereInput[]
    id?: StringFilter<"ProfitLoss"> | string
    userId?: StringFilter<"ProfitLoss"> | string
    businessIncomeId?: StringNullableFilter<"ProfitLoss"> | string | null
    year?: StringNullableFilter<"ProfitLoss"> | string | null
    income?: JsonNullableFilter<"ProfitLoss">
    expenses?: JsonNullableFilter<"ProfitLoss">
    netProfit?: DecimalNullableFilter<"ProfitLoss"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProfitLoss"> | Date | string
    updatedAt?: DateTimeFilter<"ProfitLoss"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
  }

  export type ProfitLossOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    income?: SortOrderInput | SortOrder
    expenses?: SortOrderInput | SortOrder
    netProfit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    businessIncome?: BusinessIncomeOrderByWithRelationInput
  }

  export type ProfitLossWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfitLossWhereInput | ProfitLossWhereInput[]
    OR?: ProfitLossWhereInput[]
    NOT?: ProfitLossWhereInput | ProfitLossWhereInput[]
    userId?: StringFilter<"ProfitLoss"> | string
    businessIncomeId?: StringNullableFilter<"ProfitLoss"> | string | null
    year?: StringNullableFilter<"ProfitLoss"> | string | null
    income?: JsonNullableFilter<"ProfitLoss">
    expenses?: JsonNullableFilter<"ProfitLoss">
    netProfit?: DecimalNullableFilter<"ProfitLoss"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProfitLoss"> | Date | string
    updatedAt?: DateTimeFilter<"ProfitLoss"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
  }, "id">

  export type ProfitLossOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    income?: SortOrderInput | SortOrder
    expenses?: SortOrderInput | SortOrder
    netProfit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfitLossCountOrderByAggregateInput
    _avg?: ProfitLossAvgOrderByAggregateInput
    _max?: ProfitLossMaxOrderByAggregateInput
    _min?: ProfitLossMinOrderByAggregateInput
    _sum?: ProfitLossSumOrderByAggregateInput
  }

  export type ProfitLossScalarWhereWithAggregatesInput = {
    AND?: ProfitLossScalarWhereWithAggregatesInput | ProfitLossScalarWhereWithAggregatesInput[]
    OR?: ProfitLossScalarWhereWithAggregatesInput[]
    NOT?: ProfitLossScalarWhereWithAggregatesInput | ProfitLossScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfitLoss"> | string
    userId?: StringWithAggregatesFilter<"ProfitLoss"> | string
    businessIncomeId?: StringNullableWithAggregatesFilter<"ProfitLoss"> | string | null
    year?: StringNullableWithAggregatesFilter<"ProfitLoss"> | string | null
    income?: JsonNullableWithAggregatesFilter<"ProfitLoss">
    expenses?: JsonNullableWithAggregatesFilter<"ProfitLoss">
    netProfit?: DecimalNullableWithAggregatesFilter<"ProfitLoss"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProfitLoss"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfitLoss"> | Date | string
  }

  export type BalanceSheetWhereInput = {
    AND?: BalanceSheetWhereInput | BalanceSheetWhereInput[]
    OR?: BalanceSheetWhereInput[]
    NOT?: BalanceSheetWhereInput | BalanceSheetWhereInput[]
    id?: StringFilter<"BalanceSheet"> | string
    userId?: StringFilter<"BalanceSheet"> | string
    businessIncomeId?: StringNullableFilter<"BalanceSheet"> | string | null
    year?: StringNullableFilter<"BalanceSheet"> | string | null
    assets?: JsonNullableFilter<"BalanceSheet">
    liabilities?: JsonNullableFilter<"BalanceSheet">
    createdAt?: DateTimeFilter<"BalanceSheet"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceSheet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
  }

  export type BalanceSheetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    assets?: SortOrderInput | SortOrder
    liabilities?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    businessIncome?: BusinessIncomeOrderByWithRelationInput
  }

  export type BalanceSheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BalanceSheetWhereInput | BalanceSheetWhereInput[]
    OR?: BalanceSheetWhereInput[]
    NOT?: BalanceSheetWhereInput | BalanceSheetWhereInput[]
    userId?: StringFilter<"BalanceSheet"> | string
    businessIncomeId?: StringNullableFilter<"BalanceSheet"> | string | null
    year?: StringNullableFilter<"BalanceSheet"> | string | null
    assets?: JsonNullableFilter<"BalanceSheet">
    liabilities?: JsonNullableFilter<"BalanceSheet">
    createdAt?: DateTimeFilter<"BalanceSheet"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceSheet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
  }, "id">

  export type BalanceSheetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    assets?: SortOrderInput | SortOrder
    liabilities?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BalanceSheetCountOrderByAggregateInput
    _max?: BalanceSheetMaxOrderByAggregateInput
    _min?: BalanceSheetMinOrderByAggregateInput
  }

  export type BalanceSheetScalarWhereWithAggregatesInput = {
    AND?: BalanceSheetScalarWhereWithAggregatesInput | BalanceSheetScalarWhereWithAggregatesInput[]
    OR?: BalanceSheetScalarWhereWithAggregatesInput[]
    NOT?: BalanceSheetScalarWhereWithAggregatesInput | BalanceSheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BalanceSheet"> | string
    userId?: StringWithAggregatesFilter<"BalanceSheet"> | string
    businessIncomeId?: StringNullableWithAggregatesFilter<"BalanceSheet"> | string | null
    year?: StringNullableWithAggregatesFilter<"BalanceSheet"> | string | null
    assets?: JsonNullableWithAggregatesFilter<"BalanceSheet">
    liabilities?: JsonNullableWithAggregatesFilter<"BalanceSheet">
    createdAt?: DateTimeWithAggregatesFilter<"BalanceSheet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BalanceSheet"> | Date | string
  }

  export type DepreciationEntryWhereInput = {
    AND?: DepreciationEntryWhereInput | DepreciationEntryWhereInput[]
    OR?: DepreciationEntryWhereInput[]
    NOT?: DepreciationEntryWhereInput | DepreciationEntryWhereInput[]
    id?: StringFilter<"DepreciationEntry"> | string
    userId?: StringFilter<"DepreciationEntry"> | string
    businessIncomeId?: StringNullableFilter<"DepreciationEntry"> | string | null
    assetName?: StringNullableFilter<"DepreciationEntry"> | string | null
    assetCategory?: StringNullableFilter<"DepreciationEntry"> | string | null
    purchaseDate?: DateTimeNullableFilter<"DepreciationEntry"> | Date | string | null
    purchaseCost?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DepreciationEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DepreciationEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
  }

  export type DepreciationEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrderInput | SortOrder
    assetName?: SortOrderInput | SortOrder
    assetCategory?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    purchaseCost?: SortOrderInput | SortOrder
    depreciationRate?: SortOrderInput | SortOrder
    accumulatedDepreciation?: SortOrderInput | SortOrder
    writtenDownValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    businessIncome?: BusinessIncomeOrderByWithRelationInput
  }

  export type DepreciationEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepreciationEntryWhereInput | DepreciationEntryWhereInput[]
    OR?: DepreciationEntryWhereInput[]
    NOT?: DepreciationEntryWhereInput | DepreciationEntryWhereInput[]
    userId?: StringFilter<"DepreciationEntry"> | string
    businessIncomeId?: StringNullableFilter<"DepreciationEntry"> | string | null
    assetName?: StringNullableFilter<"DepreciationEntry"> | string | null
    assetCategory?: StringNullableFilter<"DepreciationEntry"> | string | null
    purchaseDate?: DateTimeNullableFilter<"DepreciationEntry"> | Date | string | null
    purchaseCost?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DepreciationEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DepreciationEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    businessIncome?: XOR<BusinessIncomeNullableScalarRelationFilter, BusinessIncomeWhereInput> | null
  }, "id">

  export type DepreciationEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrderInput | SortOrder
    assetName?: SortOrderInput | SortOrder
    assetCategory?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    purchaseCost?: SortOrderInput | SortOrder
    depreciationRate?: SortOrderInput | SortOrder
    accumulatedDepreciation?: SortOrderInput | SortOrder
    writtenDownValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepreciationEntryCountOrderByAggregateInput
    _avg?: DepreciationEntryAvgOrderByAggregateInput
    _max?: DepreciationEntryMaxOrderByAggregateInput
    _min?: DepreciationEntryMinOrderByAggregateInput
    _sum?: DepreciationEntrySumOrderByAggregateInput
  }

  export type DepreciationEntryScalarWhereWithAggregatesInput = {
    AND?: DepreciationEntryScalarWhereWithAggregatesInput | DepreciationEntryScalarWhereWithAggregatesInput[]
    OR?: DepreciationEntryScalarWhereWithAggregatesInput[]
    NOT?: DepreciationEntryScalarWhereWithAggregatesInput | DepreciationEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepreciationEntry"> | string
    userId?: StringWithAggregatesFilter<"DepreciationEntry"> | string
    businessIncomeId?: StringNullableWithAggregatesFilter<"DepreciationEntry"> | string | null
    assetName?: StringNullableWithAggregatesFilter<"DepreciationEntry"> | string | null
    assetCategory?: StringNullableWithAggregatesFilter<"DepreciationEntry"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"DepreciationEntry"> | Date | string | null
    purchaseCost?: DecimalNullableWithAggregatesFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: DecimalNullableWithAggregatesFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: DecimalNullableWithAggregatesFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: DecimalNullableWithAggregatesFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DepreciationEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepreciationEntry"> | Date | string
  }

  export type CryptoIncomeWhereInput = {
    AND?: CryptoIncomeWhereInput | CryptoIncomeWhereInput[]
    OR?: CryptoIncomeWhereInput[]
    NOT?: CryptoIncomeWhereInput | CryptoIncomeWhereInput[]
    id?: StringFilter<"CryptoIncome"> | string
    userId?: StringFilter<"CryptoIncome"> | string
    assetType?: StringNullableFilter<"CryptoIncome"> | string | null
    coinName?: StringNullableFilter<"CryptoIncome"> | string | null
    purchaseDate?: DateTimeNullableFilter<"CryptoIncome"> | Date | string | null
    saleDate?: DateTimeNullableFilter<"CryptoIncome"> | Date | string | null
    purchasePrice?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    salePrice?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    quantity?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    exchangeName?: StringNullableFilter<"CryptoIncome"> | string | null
    transactionHash?: StringNullableFilter<"CryptoIncome"> | string | null
    profit?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CryptoIncome"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CryptoIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrderInput | SortOrder
    coinName?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    saleDate?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    salePrice?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    exchangeName?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CryptoIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CryptoIncomeWhereInput | CryptoIncomeWhereInput[]
    OR?: CryptoIncomeWhereInput[]
    NOT?: CryptoIncomeWhereInput | CryptoIncomeWhereInput[]
    userId?: StringFilter<"CryptoIncome"> | string
    assetType?: StringNullableFilter<"CryptoIncome"> | string | null
    coinName?: StringNullableFilter<"CryptoIncome"> | string | null
    purchaseDate?: DateTimeNullableFilter<"CryptoIncome"> | Date | string | null
    saleDate?: DateTimeNullableFilter<"CryptoIncome"> | Date | string | null
    purchasePrice?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    salePrice?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    quantity?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    exchangeName?: StringNullableFilter<"CryptoIncome"> | string | null
    transactionHash?: StringNullableFilter<"CryptoIncome"> | string | null
    profit?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CryptoIncome"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CryptoIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrderInput | SortOrder
    coinName?: SortOrderInput | SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    saleDate?: SortOrderInput | SortOrder
    purchasePrice?: SortOrderInput | SortOrder
    salePrice?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    exchangeName?: SortOrderInput | SortOrder
    transactionHash?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoIncomeCountOrderByAggregateInput
    _avg?: CryptoIncomeAvgOrderByAggregateInput
    _max?: CryptoIncomeMaxOrderByAggregateInput
    _min?: CryptoIncomeMinOrderByAggregateInput
    _sum?: CryptoIncomeSumOrderByAggregateInput
  }

  export type CryptoIncomeScalarWhereWithAggregatesInput = {
    AND?: CryptoIncomeScalarWhereWithAggregatesInput | CryptoIncomeScalarWhereWithAggregatesInput[]
    OR?: CryptoIncomeScalarWhereWithAggregatesInput[]
    NOT?: CryptoIncomeScalarWhereWithAggregatesInput | CryptoIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoIncome"> | string
    userId?: StringWithAggregatesFilter<"CryptoIncome"> | string
    assetType?: StringNullableWithAggregatesFilter<"CryptoIncome"> | string | null
    coinName?: StringNullableWithAggregatesFilter<"CryptoIncome"> | string | null
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"CryptoIncome"> | Date | string | null
    saleDate?: DateTimeNullableWithAggregatesFilter<"CryptoIncome"> | Date | string | null
    purchasePrice?: DecimalNullableWithAggregatesFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    salePrice?: DecimalNullableWithAggregatesFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    quantity?: DecimalNullableWithAggregatesFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    exchangeName?: StringNullableWithAggregatesFilter<"CryptoIncome"> | string | null
    transactionHash?: StringNullableWithAggregatesFilter<"CryptoIncome"> | string | null
    profit?: DecimalNullableWithAggregatesFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CryptoIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoIncome"> | Date | string
  }

  export type AgriculturalIncomeWhereInput = {
    AND?: AgriculturalIncomeWhereInput | AgriculturalIncomeWhereInput[]
    OR?: AgriculturalIncomeWhereInput[]
    NOT?: AgriculturalIncomeWhereInput | AgriculturalIncomeWhereInput[]
    id?: StringFilter<"AgriculturalIncome"> | string
    userId?: StringFilter<"AgriculturalIncome"> | string
    landArea?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    location?: StringNullableFilter<"AgriculturalIncome"> | string | null
    cropType?: StringNullableFilter<"AgriculturalIncome"> | string | null
    annualIncome?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    netIncome?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AgriculturalIncome"> | Date | string
    updatedAt?: DateTimeFilter<"AgriculturalIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AgriculturalIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    landArea?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    cropType?: SortOrderInput | SortOrder
    annualIncome?: SortOrderInput | SortOrder
    expenses?: SortOrderInput | SortOrder
    netIncome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AgriculturalIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgriculturalIncomeWhereInput | AgriculturalIncomeWhereInput[]
    OR?: AgriculturalIncomeWhereInput[]
    NOT?: AgriculturalIncomeWhereInput | AgriculturalIncomeWhereInput[]
    userId?: StringFilter<"AgriculturalIncome"> | string
    landArea?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    location?: StringNullableFilter<"AgriculturalIncome"> | string | null
    cropType?: StringNullableFilter<"AgriculturalIncome"> | string | null
    annualIncome?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    netIncome?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AgriculturalIncome"> | Date | string
    updatedAt?: DateTimeFilter<"AgriculturalIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AgriculturalIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    landArea?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    cropType?: SortOrderInput | SortOrder
    annualIncome?: SortOrderInput | SortOrder
    expenses?: SortOrderInput | SortOrder
    netIncome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgriculturalIncomeCountOrderByAggregateInput
    _avg?: AgriculturalIncomeAvgOrderByAggregateInput
    _max?: AgriculturalIncomeMaxOrderByAggregateInput
    _min?: AgriculturalIncomeMinOrderByAggregateInput
    _sum?: AgriculturalIncomeSumOrderByAggregateInput
  }

  export type AgriculturalIncomeScalarWhereWithAggregatesInput = {
    AND?: AgriculturalIncomeScalarWhereWithAggregatesInput | AgriculturalIncomeScalarWhereWithAggregatesInput[]
    OR?: AgriculturalIncomeScalarWhereWithAggregatesInput[]
    NOT?: AgriculturalIncomeScalarWhereWithAggregatesInput | AgriculturalIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgriculturalIncome"> | string
    userId?: StringWithAggregatesFilter<"AgriculturalIncome"> | string
    landArea?: DecimalNullableWithAggregatesFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    location?: StringNullableWithAggregatesFilter<"AgriculturalIncome"> | string | null
    cropType?: StringNullableWithAggregatesFilter<"AgriculturalIncome"> | string | null
    annualIncome?: DecimalNullableWithAggregatesFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableWithAggregatesFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    netIncome?: DecimalNullableWithAggregatesFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AgriculturalIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgriculturalIncome"> | Date | string
  }

  export type ExemptIncomeWhereInput = {
    AND?: ExemptIncomeWhereInput | ExemptIncomeWhereInput[]
    OR?: ExemptIncomeWhereInput[]
    NOT?: ExemptIncomeWhereInput | ExemptIncomeWhereInput[]
    id?: StringFilter<"ExemptIncome"> | string
    userId?: StringFilter<"ExemptIncome"> | string
    incomeType?: StringNullableFilter<"ExemptIncome"> | string | null
    description?: StringNullableFilter<"ExemptIncome"> | string | null
    amount?: DecimalNullableFilter<"ExemptIncome"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableFilter<"ExemptIncome"> | string | null
    createdAt?: DateTimeFilter<"ExemptIncome"> | Date | string
    updatedAt?: DateTimeFilter<"ExemptIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExemptIncomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    incomeType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ExemptIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExemptIncomeWhereInput | ExemptIncomeWhereInput[]
    OR?: ExemptIncomeWhereInput[]
    NOT?: ExemptIncomeWhereInput | ExemptIncomeWhereInput[]
    userId?: StringFilter<"ExemptIncome"> | string
    incomeType?: StringNullableFilter<"ExemptIncome"> | string | null
    description?: StringNullableFilter<"ExemptIncome"> | string | null
    amount?: DecimalNullableFilter<"ExemptIncome"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableFilter<"ExemptIncome"> | string | null
    createdAt?: DateTimeFilter<"ExemptIncome"> | Date | string
    updatedAt?: DateTimeFilter<"ExemptIncome"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ExemptIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    incomeType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExemptIncomeCountOrderByAggregateInput
    _avg?: ExemptIncomeAvgOrderByAggregateInput
    _max?: ExemptIncomeMaxOrderByAggregateInput
    _min?: ExemptIncomeMinOrderByAggregateInput
    _sum?: ExemptIncomeSumOrderByAggregateInput
  }

  export type ExemptIncomeScalarWhereWithAggregatesInput = {
    AND?: ExemptIncomeScalarWhereWithAggregatesInput | ExemptIncomeScalarWhereWithAggregatesInput[]
    OR?: ExemptIncomeScalarWhereWithAggregatesInput[]
    NOT?: ExemptIncomeScalarWhereWithAggregatesInput | ExemptIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExemptIncome"> | string
    userId?: StringWithAggregatesFilter<"ExemptIncome"> | string
    incomeType?: StringNullableWithAggregatesFilter<"ExemptIncome"> | string | null
    description?: StringNullableWithAggregatesFilter<"ExemptIncome"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"ExemptIncome"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableWithAggregatesFilter<"ExemptIncome"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExemptIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExemptIncome"> | Date | string
  }

  export type TaxSavingInvestmentWhereInput = {
    AND?: TaxSavingInvestmentWhereInput | TaxSavingInvestmentWhereInput[]
    OR?: TaxSavingInvestmentWhereInput[]
    NOT?: TaxSavingInvestmentWhereInput | TaxSavingInvestmentWhereInput[]
    id?: StringFilter<"TaxSavingInvestment"> | string
    userId?: StringFilter<"TaxSavingInvestment"> | string
    section80C?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TaxSavingInvestment"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSavingInvestment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaxSavingInvestmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TaxSavingInvestmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TaxSavingInvestmentWhereInput | TaxSavingInvestmentWhereInput[]
    OR?: TaxSavingInvestmentWhereInput[]
    NOT?: TaxSavingInvestmentWhereInput | TaxSavingInvestmentWhereInput[]
    section80C?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TaxSavingInvestment"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSavingInvestment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type TaxSavingInvestmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxSavingInvestmentCountOrderByAggregateInput
    _avg?: TaxSavingInvestmentAvgOrderByAggregateInput
    _max?: TaxSavingInvestmentMaxOrderByAggregateInput
    _min?: TaxSavingInvestmentMinOrderByAggregateInput
    _sum?: TaxSavingInvestmentSumOrderByAggregateInput
  }

  export type TaxSavingInvestmentScalarWhereWithAggregatesInput = {
    AND?: TaxSavingInvestmentScalarWhereWithAggregatesInput | TaxSavingInvestmentScalarWhereWithAggregatesInput[]
    OR?: TaxSavingInvestmentScalarWhereWithAggregatesInput[]
    NOT?: TaxSavingInvestmentScalarWhereWithAggregatesInput | TaxSavingInvestmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxSavingInvestment"> | string
    userId?: StringWithAggregatesFilter<"TaxSavingInvestment"> | string
    section80C?: DecimalWithAggregatesFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalWithAggregatesFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalWithAggregatesFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalWithAggregatesFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalWithAggregatesFilter<"TaxSavingInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"TaxSavingInvestment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxSavingInvestment"> | Date | string
  }

  export type DonationWhereInput = {
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    id?: StringFilter<"Donation"> | string
    userId?: StringFilter<"Donation"> | string
    organizationName?: StringNullableFilter<"Donation"> | string | null
    donationType?: StringNullableFilter<"Donation"> | string | null
    amount?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableFilter<"Donation"> | Date | string | null
    receiptNumber?: StringNullableFilter<"Donation"> | string | null
    eligibleAmount?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationName?: SortOrderInput | SortOrder
    donationType?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    eligibleAmount?: SortOrderInput | SortOrder
    deductionPercentage?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DonationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    userId?: StringFilter<"Donation"> | string
    organizationName?: StringNullableFilter<"Donation"> | string | null
    donationType?: StringNullableFilter<"Donation"> | string | null
    amount?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableFilter<"Donation"> | Date | string | null
    receiptNumber?: StringNullableFilter<"Donation"> | string | null
    eligibleAmount?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationName?: SortOrderInput | SortOrder
    donationType?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    eligibleAmount?: SortOrderInput | SortOrder
    deductionPercentage?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    OR?: DonationScalarWhereWithAggregatesInput[]
    NOT?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Donation"> | string
    userId?: StringWithAggregatesFilter<"Donation"> | string
    organizationName?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    donationType?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableWithAggregatesFilter<"Donation"> | Date | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    eligibleAmount?: DecimalNullableWithAggregatesFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: DecimalNullableWithAggregatesFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableWithAggregatesFilter<"Donation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Donation"> | Date | string
  }

  export type MedicalInsuranceWhereInput = {
    AND?: MedicalInsuranceWhereInput | MedicalInsuranceWhereInput[]
    OR?: MedicalInsuranceWhereInput[]
    NOT?: MedicalInsuranceWhereInput | MedicalInsuranceWhereInput[]
    id?: StringFilter<"MedicalInsurance"> | string
    userId?: StringFilter<"MedicalInsurance"> | string
    policyType?: StringNullableFilter<"MedicalInsurance"> | string | null
    insuredPersons?: StringNullableFilter<"MedicalInsurance"> | string | null
    premiumPaid?: DecimalNullableFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: DecimalNullableFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    policyNumber?: StringNullableFilter<"MedicalInsurance"> | string | null
    insuranceCompany?: StringNullableFilter<"MedicalInsurance"> | string | null
    createdAt?: DateTimeFilter<"MedicalInsurance"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInsurance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MedicalInsuranceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    policyType?: SortOrderInput | SortOrder
    insuredPersons?: SortOrderInput | SortOrder
    premiumPaid?: SortOrderInput | SortOrder
    eligibleAmount?: SortOrderInput | SortOrder
    policyNumber?: SortOrderInput | SortOrder
    insuranceCompany?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MedicalInsuranceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalInsuranceWhereInput | MedicalInsuranceWhereInput[]
    OR?: MedicalInsuranceWhereInput[]
    NOT?: MedicalInsuranceWhereInput | MedicalInsuranceWhereInput[]
    userId?: StringFilter<"MedicalInsurance"> | string
    policyType?: StringNullableFilter<"MedicalInsurance"> | string | null
    insuredPersons?: StringNullableFilter<"MedicalInsurance"> | string | null
    premiumPaid?: DecimalNullableFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: DecimalNullableFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    policyNumber?: StringNullableFilter<"MedicalInsurance"> | string | null
    insuranceCompany?: StringNullableFilter<"MedicalInsurance"> | string | null
    createdAt?: DateTimeFilter<"MedicalInsurance"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInsurance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MedicalInsuranceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    policyType?: SortOrderInput | SortOrder
    insuredPersons?: SortOrderInput | SortOrder
    premiumPaid?: SortOrderInput | SortOrder
    eligibleAmount?: SortOrderInput | SortOrder
    policyNumber?: SortOrderInput | SortOrder
    insuranceCompany?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalInsuranceCountOrderByAggregateInput
    _avg?: MedicalInsuranceAvgOrderByAggregateInput
    _max?: MedicalInsuranceMaxOrderByAggregateInput
    _min?: MedicalInsuranceMinOrderByAggregateInput
    _sum?: MedicalInsuranceSumOrderByAggregateInput
  }

  export type MedicalInsuranceScalarWhereWithAggregatesInput = {
    AND?: MedicalInsuranceScalarWhereWithAggregatesInput | MedicalInsuranceScalarWhereWithAggregatesInput[]
    OR?: MedicalInsuranceScalarWhereWithAggregatesInput[]
    NOT?: MedicalInsuranceScalarWhereWithAggregatesInput | MedicalInsuranceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalInsurance"> | string
    userId?: StringWithAggregatesFilter<"MedicalInsurance"> | string
    policyType?: StringNullableWithAggregatesFilter<"MedicalInsurance"> | string | null
    insuredPersons?: StringNullableWithAggregatesFilter<"MedicalInsurance"> | string | null
    premiumPaid?: DecimalNullableWithAggregatesFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: DecimalNullableWithAggregatesFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    policyNumber?: StringNullableWithAggregatesFilter<"MedicalInsurance"> | string | null
    insuranceCompany?: StringNullableWithAggregatesFilter<"MedicalInsurance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicalInsurance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalInsurance"> | Date | string
  }

  export type TaxPaidWhereInput = {
    AND?: TaxPaidWhereInput | TaxPaidWhereInput[]
    OR?: TaxPaidWhereInput[]
    NOT?: TaxPaidWhereInput | TaxPaidWhereInput[]
    id?: StringFilter<"TaxPaid"> | string
    userId?: StringFilter<"TaxPaid"> | string
    taxType?: StringNullableFilter<"TaxPaid"> | string | null
    amount?: DecimalNullableFilter<"TaxPaid"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableFilter<"TaxPaid"> | Date | string | null
    challanNumber?: StringNullableFilter<"TaxPaid"> | string | null
    bankName?: StringNullableFilter<"TaxPaid"> | string | null
    createdAt?: DateTimeFilter<"TaxPaid"> | Date | string
    updatedAt?: DateTimeFilter<"TaxPaid"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaxPaidOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taxType?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    challanNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TaxPaidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxPaidWhereInput | TaxPaidWhereInput[]
    OR?: TaxPaidWhereInput[]
    NOT?: TaxPaidWhereInput | TaxPaidWhereInput[]
    userId?: StringFilter<"TaxPaid"> | string
    taxType?: StringNullableFilter<"TaxPaid"> | string | null
    amount?: DecimalNullableFilter<"TaxPaid"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableFilter<"TaxPaid"> | Date | string | null
    challanNumber?: StringNullableFilter<"TaxPaid"> | string | null
    bankName?: StringNullableFilter<"TaxPaid"> | string | null
    createdAt?: DateTimeFilter<"TaxPaid"> | Date | string
    updatedAt?: DateTimeFilter<"TaxPaid"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaxPaidOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taxType?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    challanNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxPaidCountOrderByAggregateInput
    _avg?: TaxPaidAvgOrderByAggregateInput
    _max?: TaxPaidMaxOrderByAggregateInput
    _min?: TaxPaidMinOrderByAggregateInput
    _sum?: TaxPaidSumOrderByAggregateInput
  }

  export type TaxPaidScalarWhereWithAggregatesInput = {
    AND?: TaxPaidScalarWhereWithAggregatesInput | TaxPaidScalarWhereWithAggregatesInput[]
    OR?: TaxPaidScalarWhereWithAggregatesInput[]
    NOT?: TaxPaidScalarWhereWithAggregatesInput | TaxPaidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxPaid"> | string
    userId?: StringWithAggregatesFilter<"TaxPaid"> | string
    taxType?: StringNullableWithAggregatesFilter<"TaxPaid"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"TaxPaid"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableWithAggregatesFilter<"TaxPaid"> | Date | string | null
    challanNumber?: StringNullableWithAggregatesFilter<"TaxPaid"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"TaxPaid"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxPaid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxPaid"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    balance?: DecimalFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    transactions?: WalletTransactionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: WalletTransactionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: DecimalFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    transactions?: WalletTransactionListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: DecimalWithAggregatesFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    transactionType?: EnumTransactionTypeFilter<"WalletTransaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    razorpayPaymentId?: StringNullableFilter<"WalletTransaction"> | string | null
    razorpayOrderId?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"WalletTransaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeFilter<"WalletTransaction"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    walletId?: StringFilter<"WalletTransaction"> | string
    transactionType?: EnumTransactionTypeFilter<"WalletTransaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    razorpayPaymentId?: StringNullableFilter<"WalletTransaction"> | string | null
    razorpayOrderId?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"WalletTransaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeFilter<"WalletTransaction"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
  }, "id">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    razorpayPaymentId?: SortOrderInput | SortOrder
    razorpayOrderId?: SortOrderInput | SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    transactionType?: EnumTransactionTypeWithAggregatesFilter<"WalletTransaction"> | $Enums.TransactionType
    amount?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    razorpayPaymentId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    razorpayOrderId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"WalletTransaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type ITRGenerationWhereInput = {
    AND?: ITRGenerationWhereInput | ITRGenerationWhereInput[]
    OR?: ITRGenerationWhereInput[]
    NOT?: ITRGenerationWhereInput | ITRGenerationWhereInput[]
    id?: StringFilter<"ITRGeneration"> | string
    userId?: StringFilter<"ITRGeneration"> | string
    itrType?: EnumITRTypeFilter<"ITRGeneration"> | $Enums.ITRType
    assessmentYear?: StringFilter<"ITRGeneration"> | string
    fileName?: StringFilter<"ITRGeneration"> | string
    checksum?: StringFilter<"ITRGeneration"> | string
    jsonData?: JsonFilter<"ITRGeneration">
    status?: EnumITRStatusFilter<"ITRGeneration"> | $Enums.ITRStatus
    generatedAt?: DateTimeFilter<"ITRGeneration"> | Date | string
    downloadedAt?: DateTimeNullableFilter<"ITRGeneration"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ITRGenerationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    itrType?: SortOrder
    assessmentYear?: SortOrder
    fileName?: SortOrder
    checksum?: SortOrder
    jsonData?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ITRGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    checksum?: string
    AND?: ITRGenerationWhereInput | ITRGenerationWhereInput[]
    OR?: ITRGenerationWhereInput[]
    NOT?: ITRGenerationWhereInput | ITRGenerationWhereInput[]
    userId?: StringFilter<"ITRGeneration"> | string
    itrType?: EnumITRTypeFilter<"ITRGeneration"> | $Enums.ITRType
    assessmentYear?: StringFilter<"ITRGeneration"> | string
    fileName?: StringFilter<"ITRGeneration"> | string
    jsonData?: JsonFilter<"ITRGeneration">
    status?: EnumITRStatusFilter<"ITRGeneration"> | $Enums.ITRStatus
    generatedAt?: DateTimeFilter<"ITRGeneration"> | Date | string
    downloadedAt?: DateTimeNullableFilter<"ITRGeneration"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "checksum">

  export type ITRGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    itrType?: SortOrder
    assessmentYear?: SortOrder
    fileName?: SortOrder
    checksum?: SortOrder
    jsonData?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrderInput | SortOrder
    _count?: ITRGenerationCountOrderByAggregateInput
    _max?: ITRGenerationMaxOrderByAggregateInput
    _min?: ITRGenerationMinOrderByAggregateInput
  }

  export type ITRGenerationScalarWhereWithAggregatesInput = {
    AND?: ITRGenerationScalarWhereWithAggregatesInput | ITRGenerationScalarWhereWithAggregatesInput[]
    OR?: ITRGenerationScalarWhereWithAggregatesInput[]
    NOT?: ITRGenerationScalarWhereWithAggregatesInput | ITRGenerationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ITRGeneration"> | string
    userId?: StringWithAggregatesFilter<"ITRGeneration"> | string
    itrType?: EnumITRTypeWithAggregatesFilter<"ITRGeneration"> | $Enums.ITRType
    assessmentYear?: StringWithAggregatesFilter<"ITRGeneration"> | string
    fileName?: StringWithAggregatesFilter<"ITRGeneration"> | string
    checksum?: StringWithAggregatesFilter<"ITRGeneration"> | string
    jsonData?: JsonWithAggregatesFilter<"ITRGeneration">
    status?: EnumITRStatusWithAggregatesFilter<"ITRGeneration"> | $Enums.ITRStatus
    generatedAt?: DateTimeWithAggregatesFilter<"ITRGeneration"> | Date | string
    downloadedAt?: DateTimeNullableWithAggregatesFilter<"ITRGeneration"> | Date | string | null
  }

  export type TaxSummaryWhereInput = {
    AND?: TaxSummaryWhereInput | TaxSummaryWhereInput[]
    OR?: TaxSummaryWhereInput[]
    NOT?: TaxSummaryWhereInput | TaxSummaryWhereInput[]
    id?: StringFilter<"TaxSummary"> | string
    userId?: StringFilter<"TaxSummary"> | string
    assessmentYear?: StringNullableFilter<"TaxSummary"> | string | null
    totalIncome?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxLiability?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxPaid?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    refundAmount?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    filingStatus?: StringNullableFilter<"TaxSummary"> | string | null
    filingDate?: DateTimeNullableFilter<"TaxSummary"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxSummary"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSummary"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaxSummaryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentYear?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    totalDeductions?: SortOrderInput | SortOrder
    taxableIncome?: SortOrderInput | SortOrder
    taxLiability?: SortOrderInput | SortOrder
    taxPaid?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    filingStatus?: SortOrderInput | SortOrder
    filingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TaxSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxSummaryWhereInput | TaxSummaryWhereInput[]
    OR?: TaxSummaryWhereInput[]
    NOT?: TaxSummaryWhereInput | TaxSummaryWhereInput[]
    userId?: StringFilter<"TaxSummary"> | string
    assessmentYear?: StringNullableFilter<"TaxSummary"> | string | null
    totalIncome?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxLiability?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxPaid?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    refundAmount?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    filingStatus?: StringNullableFilter<"TaxSummary"> | string | null
    filingDate?: DateTimeNullableFilter<"TaxSummary"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxSummary"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSummary"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaxSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentYear?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    totalDeductions?: SortOrderInput | SortOrder
    taxableIncome?: SortOrderInput | SortOrder
    taxLiability?: SortOrderInput | SortOrder
    taxPaid?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    filingStatus?: SortOrderInput | SortOrder
    filingDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxSummaryCountOrderByAggregateInput
    _avg?: TaxSummaryAvgOrderByAggregateInput
    _max?: TaxSummaryMaxOrderByAggregateInput
    _min?: TaxSummaryMinOrderByAggregateInput
    _sum?: TaxSummarySumOrderByAggregateInput
  }

  export type TaxSummaryScalarWhereWithAggregatesInput = {
    AND?: TaxSummaryScalarWhereWithAggregatesInput | TaxSummaryScalarWhereWithAggregatesInput[]
    OR?: TaxSummaryScalarWhereWithAggregatesInput[]
    NOT?: TaxSummaryScalarWhereWithAggregatesInput | TaxSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxSummary"> | string
    userId?: StringWithAggregatesFilter<"TaxSummary"> | string
    assessmentYear?: StringNullableWithAggregatesFilter<"TaxSummary"> | string | null
    totalIncome?: DecimalNullableWithAggregatesFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: DecimalNullableWithAggregatesFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: DecimalNullableWithAggregatesFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxLiability?: DecimalNullableWithAggregatesFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxPaid?: DecimalNullableWithAggregatesFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    refundAmount?: DecimalNullableWithAggregatesFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    filingStatus?: StringNullableWithAggregatesFilter<"TaxSummary"> | string | null
    filingDate?: DateTimeNullableWithAggregatesFilter<"TaxSummary"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxSummary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxSummary"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalDetailCreateInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    gender?: $Enums.Gender | null
    maritalStatus?: $Enums.MaritalStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPersonalDetailsInput
  }

  export type PersonalDetailUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    gender?: $Enums.Gender | null
    maritalStatus?: $Enums.MaritalStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalDetailCreateManyInput = {
    id?: string
    userId: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    gender?: $Enums.Gender | null
    maritalStatus?: $Enums.MaritalStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactDetailCreateInput = {
    id?: string
    email?: string | null
    phone?: string | null
    panNumber?: string | null
    aadharNumber?: string | null
    alternativeEmail?: string | null
    alternativePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutContactDetailsInput
  }

  export type ContactDetailUncheckedCreateInput = {
    id?: string
    userId: string
    email?: string | null
    phone?: string | null
    panNumber?: string | null
    aadharNumber?: string | null
    alternativeEmail?: string | null
    alternativePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutContactDetailsNestedInput
  }

  export type ContactDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactDetailCreateManyInput = {
    id?: string
    userId: string
    email?: string | null
    phone?: string | null
    panNumber?: string | null
    aadharNumber?: string | null
    alternativeEmail?: string | null
    alternativePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressDetailCreateInput = {
    id?: string
    flatNo?: string | null
    premiseName?: string | null
    road?: string | null
    area?: string | null
    pincode?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAddressDetailsInput
  }

  export type AddressDetailUncheckedCreateInput = {
    id?: string
    userId: string
    flatNo?: string | null
    premiseName?: string | null
    road?: string | null
    area?: string | null
    pincode?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    premiseName?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressDetailsNestedInput
  }

  export type AddressDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    premiseName?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressDetailCreateManyInput = {
    id?: string
    userId: string
    flatNo?: string | null
    premiseName?: string | null
    road?: string | null
    area?: string | null
    pincode?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    premiseName?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    premiseName?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateInput = {
    id?: string
    accountNumber?: string | null
    ifscCode?: string | null
    bankName?: string | null
    accountType?: string | null
    accountHolderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBankDetailsInput
  }

  export type BankDetailUncheckedCreateInput = {
    id?: string
    userId: string
    accountNumber?: string | null
    ifscCode?: string | null
    bankName?: string | null
    accountType?: string | null
    accountHolderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBankDetailsNestedInput
  }

  export type BankDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateManyInput = {
    id?: string
    userId: string
    accountNumber?: string | null
    ifscCode?: string | null
    bankName?: string | null
    accountType?: string | null
    accountHolderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Form16DataCreateInput = {
    id?: string
    employerName?: string | null
    employerTAN?: string | null
    employerCategory?: string | null
    totalTax?: Decimal | DecimalJsLike | number | string | null
    grossSalary?: Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: Decimal | DecimalJsLike | number | string | null
    standardDeduction?: Decimal | DecimalJsLike | number | string | null
    professionalTax?: Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForm16DataInput
  }

  export type Form16DataUncheckedCreateInput = {
    id?: string
    userId: string
    employerName?: string | null
    employerTAN?: string | null
    employerCategory?: string | null
    totalTax?: Decimal | DecimalJsLike | number | string | null
    grossSalary?: Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: Decimal | DecimalJsLike | number | string | null
    standardDeduction?: Decimal | DecimalJsLike | number | string | null
    professionalTax?: Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Form16DataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForm16DataNestedInput
  }

  export type Form16DataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Form16DataCreateManyInput = {
    id?: string
    userId: string
    employerName?: string | null
    employerTAN?: string | null
    employerCategory?: string | null
    totalTax?: Decimal | DecimalJsLike | number | string | null
    grossSalary?: Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: Decimal | DecimalJsLike | number | string | null
    standardDeduction?: Decimal | DecimalJsLike | number | string | null
    professionalTax?: Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Form16DataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Form16DataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    propertyIndex?: string | null
    propertyType?: string | null
    netTaxableIncome?: Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    userId: string
    propertyIndex?: string | null
    propertyType?: string | null
    netTaxableIncome?: Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyInput = {
    id?: string
    userId: string
    propertyIndex?: string | null
    propertyType?: string | null
    netTaxableIncome?: Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapitalGainCreateInput = {
    id?: string
    assetType?: string | null
    assetSubType?: string | null
    dateOfSale?: Date | string | null
    dateOfPurchase?: Date | string | null
    description?: string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    transferExpenses?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    sttPaid?: boolean
    totalProfit?: Decimal | DecimalJsLike | number | string | null
    indexationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCapitalGainsInput
  }

  export type CapitalGainUncheckedCreateInput = {
    id?: string
    userId: string
    assetType?: string | null
    assetSubType?: string | null
    dateOfSale?: Date | string | null
    dateOfPurchase?: Date | string | null
    description?: string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    transferExpenses?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    sttPaid?: boolean
    totalProfit?: Decimal | DecimalJsLike | number | string | null
    indexationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapitalGainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCapitalGainsNestedInput
  }

  export type CapitalGainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapitalGainCreateManyInput = {
    id?: string
    userId: string
    assetType?: string | null
    assetSubType?: string | null
    dateOfSale?: Date | string | null
    dateOfPurchase?: Date | string | null
    description?: string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    transferExpenses?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    sttPaid?: boolean
    totalProfit?: Decimal | DecimalJsLike | number | string | null
    indexationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapitalGainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapitalGainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestIncomeCreateInput = {
    id?: string
    sourceType?: string | null
    bankName?: string | null
    accountNumber?: string | null
    interestAmount?: Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: Decimal | DecimalJsLike | number | string | null
    financialYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInterestIncomeInput
  }

  export type InterestIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    sourceType?: string | null
    bankName?: string | null
    accountNumber?: string | null
    interestAmount?: Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: Decimal | DecimalJsLike | number | string | null
    financialYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterestIncomeNestedInput
  }

  export type InterestIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestIncomeCreateManyInput = {
    id?: string
    userId: string
    sourceType?: string | null
    bankName?: string | null
    accountNumber?: string | null
    interestAmount?: Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: Decimal | DecimalJsLike | number | string | null
    financialYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DividendIncomeCreateInput = {
    id?: string
    companyName?: string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    taxDeducted?: Decimal | DecimalJsLike | number | string | null
    dateReceived?: Date | string | null
    shareQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDividendIncomeInput
  }

  export type DividendIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    companyName?: string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    taxDeducted?: Decimal | DecimalJsLike | number | string | null
    dateReceived?: Date | string | null
    shareQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DividendIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDividendIncomeNestedInput
  }

  export type DividendIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DividendIncomeCreateManyInput = {
    id?: string
    userId: string
    companyName?: string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    taxDeducted?: Decimal | DecimalJsLike | number | string | null
    dateReceived?: Date | string | null
    shareQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DividendIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DividendIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessIncomeCreateInput = {
    id?: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessIncomeInput
    profitLoss?: ProfitLossCreateNestedManyWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetUncheckedCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryUncheckedCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessIncomeNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type BusinessIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type BusinessIncomeCreateManyInput = {
    id?: string
    userId: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfessionalIncomeCreateInput = {
    id?: string
    professionType?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    section44ADA?: boolean
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfessionalIncomeInput
  }

  export type ProfessionalIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    professionType?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    section44ADA?: boolean
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfessionalIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionType?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFieldUpdateOperationsInput | boolean
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfessionalIncomeNestedInput
  }

  export type ProfessionalIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    professionType?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFieldUpdateOperationsInput | boolean
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfessionalIncomeCreateManyInput = {
    id?: string
    userId: string
    professionType?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    section44ADA?: boolean
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfessionalIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionType?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFieldUpdateOperationsInput | boolean
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfessionalIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    professionType?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFieldUpdateOperationsInput | boolean
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossCreateInput = {
    id?: string
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfitLossInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutProfitLossInput
  }

  export type ProfitLossUncheckedCreateInput = {
    id?: string
    userId: string
    businessIncomeId?: string | null
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfitLossUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfitLossNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutProfitLossNestedInput
  }

  export type ProfitLossUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossCreateManyInput = {
    id?: string
    userId: string
    businessIncomeId?: string | null
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfitLossUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetCreateInput = {
    id?: string
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBalanceSheetsInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutBalanceSheetInput
  }

  export type BalanceSheetUncheckedCreateInput = {
    id?: string
    userId: string
    businessIncomeId?: string | null
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceSheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBalanceSheetsNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutBalanceSheetNestedInput
  }

  export type BalanceSheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetCreateManyInput = {
    id?: string
    userId: string
    businessIncomeId?: string | null
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceSheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryCreateInput = {
    id?: string
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepreciationEntriesInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutDepreciationInput
  }

  export type DepreciationEntryUncheckedCreateInput = {
    id?: string
    userId: string
    businessIncomeId?: string | null
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepreciationEntriesNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutDepreciationNestedInput
  }

  export type DepreciationEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryCreateManyInput = {
    id?: string
    userId: string
    businessIncomeId?: string | null
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeCreateInput = {
    id?: string
    assetType?: string | null
    coinName?: string | null
    purchaseDate?: Date | string | null
    saleDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    exchangeName?: string | null
    transactionHash?: string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoIncomeInput
  }

  export type CryptoIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    assetType?: string | null
    coinName?: string | null
    purchaseDate?: Date | string | null
    saleDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    exchangeName?: string | null
    transactionHash?: string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoIncomeNestedInput
  }

  export type CryptoIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeCreateManyInput = {
    id?: string
    userId: string
    assetType?: string | null
    coinName?: string | null
    purchaseDate?: Date | string | null
    saleDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    exchangeName?: string | null
    transactionHash?: string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgriculturalIncomeCreateInput = {
    id?: string
    landArea?: Decimal | DecimalJsLike | number | string | null
    location?: string | null
    cropType?: string | null
    annualIncome?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    netIncome?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgriculturalIncomeInput
  }

  export type AgriculturalIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    landArea?: Decimal | DecimalJsLike | number | string | null
    location?: string | null
    cropType?: string | null
    annualIncome?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    netIncome?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgriculturalIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgriculturalIncomeNestedInput
  }

  export type AgriculturalIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgriculturalIncomeCreateManyInput = {
    id?: string
    userId: string
    landArea?: Decimal | DecimalJsLike | number | string | null
    location?: string | null
    cropType?: string | null
    annualIncome?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    netIncome?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgriculturalIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgriculturalIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExemptIncomeCreateInput = {
    id?: string
    incomeType?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExemptIncomeInput
  }

  export type ExemptIncomeUncheckedCreateInput = {
    id?: string
    userId: string
    incomeType?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExemptIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExemptIncomeNestedInput
  }

  export type ExemptIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExemptIncomeCreateManyInput = {
    id?: string
    userId: string
    incomeType?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExemptIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExemptIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSavingInvestmentCreateInput = {
    id?: string
    section80C?: Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTaxSavingInvestmentsInput
  }

  export type TaxSavingInvestmentUncheckedCreateInput = {
    id?: string
    userId: string
    section80C?: Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSavingInvestmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section80C?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaxSavingInvestmentsNestedInput
  }

  export type TaxSavingInvestmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    section80C?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSavingInvestmentCreateManyInput = {
    id?: string
    userId: string
    section80C?: Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSavingInvestmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section80C?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSavingInvestmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    section80C?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateInput = {
    id?: string
    organizationName?: string | null
    donationType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    receiptNumber?: string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateInput = {
    id?: string
    userId: string
    organizationName?: string | null
    donationType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    receiptNumber?: string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type DonationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateManyInput = {
    id?: string
    userId: string
    organizationName?: string | null
    donationType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    receiptNumber?: string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInsuranceCreateInput = {
    id?: string
    policyType?: string | null
    insuredPersons?: string | null
    premiumPaid?: Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    policyNumber?: string | null
    insuranceCompany?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMedicalInsuranceInput
  }

  export type MedicalInsuranceUncheckedCreateInput = {
    id?: string
    userId: string
    policyType?: string | null
    insuredPersons?: string | null
    premiumPaid?: Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    policyNumber?: string | null
    insuranceCompany?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInsuranceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMedicalInsuranceNestedInput
  }

  export type MedicalInsuranceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInsuranceCreateManyInput = {
    id?: string
    userId: string
    policyType?: string | null
    insuredPersons?: string | null
    premiumPaid?: Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    policyNumber?: string | null
    insuranceCompany?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInsuranceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInsuranceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPaidCreateInput = {
    id?: string
    taxType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    challanNumber?: string | null
    bankName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTaxPaidInput
  }

  export type TaxPaidUncheckedCreateInput = {
    id?: string
    userId: string
    taxType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    challanNumber?: string | null
    bankName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxPaidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaxPaidNestedInput
  }

  export type TaxPaidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPaidCreateManyInput = {
    id?: string
    userId: string
    taxType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    challanNumber?: string | null
    bankName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxPaidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPaidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionCreateNestedManyWithoutWalletInput
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUpdateManyWithoutWalletNestedInput
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
    wallet: WalletCreateNestedOneWithoutTransactionsInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    walletId: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ITRGenerationCreateInput = {
    id?: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonNullValueInput | InputJsonValue
    status?: $Enums.ITRStatus
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
    user: UserCreateNestedOneWithoutItrGenerationsInput
  }

  export type ITRGenerationUncheckedCreateInput = {
    id?: string
    userId: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonNullValueInput | InputJsonValue
    status?: $Enums.ITRStatus
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
  }

  export type ITRGenerationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutItrGenerationsNestedInput
  }

  export type ITRGenerationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ITRGenerationCreateManyInput = {
    id?: string
    userId: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonNullValueInput | InputJsonValue
    status?: $Enums.ITRStatus
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
  }

  export type ITRGenerationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ITRGenerationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaxSummaryCreateInput = {
    id?: string
    assessmentYear?: string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    totalDeductions?: Decimal | DecimalJsLike | number | string | null
    taxableIncome?: Decimal | DecimalJsLike | number | string | null
    taxLiability?: Decimal | DecimalJsLike | number | string | null
    taxPaid?: Decimal | DecimalJsLike | number | string | null
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    filingStatus?: string | null
    filingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTaxSummariesInput
  }

  export type TaxSummaryUncheckedCreateInput = {
    id?: string
    userId: string
    assessmentYear?: string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    totalDeductions?: Decimal | DecimalJsLike | number | string | null
    taxableIncome?: Decimal | DecimalJsLike | number | string | null
    taxLiability?: Decimal | DecimalJsLike | number | string | null
    taxPaid?: Decimal | DecimalJsLike | number | string | null
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    filingStatus?: string | null
    filingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSummaryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaxSummariesNestedInput
  }

  export type TaxSummaryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSummaryCreateManyInput = {
    id?: string
    userId: string
    assessmentYear?: string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    totalDeductions?: Decimal | DecimalJsLike | number | string | null
    taxableIncome?: Decimal | DecimalJsLike | number | string | null
    taxLiability?: Decimal | DecimalJsLike | number | string | null
    taxPaid?: Decimal | DecimalJsLike | number | string | null
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    filingStatus?: string | null
    filingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSummaryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSummaryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PersonalDetailNullableScalarRelationFilter = {
    is?: PersonalDetailWhereInput | null
    isNot?: PersonalDetailWhereInput | null
  }

  export type ContactDetailNullableScalarRelationFilter = {
    is?: ContactDetailWhereInput | null
    isNot?: ContactDetailWhereInput | null
  }

  export type BankDetailNullableScalarRelationFilter = {
    is?: BankDetailWhereInput | null
    isNot?: BankDetailWhereInput | null
  }

  export type AddressDetailNullableScalarRelationFilter = {
    is?: AddressDetailWhereInput | null
    isNot?: AddressDetailWhereInput | null
  }

  export type Form16DataListRelationFilter = {
    every?: Form16DataWhereInput
    some?: Form16DataWhereInput
    none?: Form16DataWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type CapitalGainListRelationFilter = {
    every?: CapitalGainWhereInput
    some?: CapitalGainWhereInput
    none?: CapitalGainWhereInput
  }

  export type BusinessIncomeNullableScalarRelationFilter = {
    is?: BusinessIncomeWhereInput | null
    isNot?: BusinessIncomeWhereInput | null
  }

  export type ProfessionalIncomeNullableScalarRelationFilter = {
    is?: ProfessionalIncomeWhereInput | null
    isNot?: ProfessionalIncomeWhereInput | null
  }

  export type CryptoIncomeListRelationFilter = {
    every?: CryptoIncomeWhereInput
    some?: CryptoIncomeWhereInput
    none?: CryptoIncomeWhereInput
  }

  export type TaxSavingInvestmentNullableScalarRelationFilter = {
    is?: TaxSavingInvestmentWhereInput | null
    isNot?: TaxSavingInvestmentWhereInput | null
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type MedicalInsuranceListRelationFilter = {
    every?: MedicalInsuranceWhereInput
    some?: MedicalInsuranceWhereInput
    none?: MedicalInsuranceWhereInput
  }

  export type TaxPaidListRelationFilter = {
    every?: TaxPaidWhereInput
    some?: TaxPaidWhereInput
    none?: TaxPaidWhereInput
  }

  export type InterestIncomeListRelationFilter = {
    every?: InterestIncomeWhereInput
    some?: InterestIncomeWhereInput
    none?: InterestIncomeWhereInput
  }

  export type DividendIncomeListRelationFilter = {
    every?: DividendIncomeWhereInput
    some?: DividendIncomeWhereInput
    none?: DividendIncomeWhereInput
  }

  export type AgriculturalIncomeListRelationFilter = {
    every?: AgriculturalIncomeWhereInput
    some?: AgriculturalIncomeWhereInput
    none?: AgriculturalIncomeWhereInput
  }

  export type ExemptIncomeListRelationFilter = {
    every?: ExemptIncomeWhereInput
    some?: ExemptIncomeWhereInput
    none?: ExemptIncomeWhereInput
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type ITRGenerationListRelationFilter = {
    every?: ITRGenerationWhereInput
    some?: ITRGenerationWhereInput
    none?: ITRGenerationWhereInput
  }

  export type TaxSummaryListRelationFilter = {
    every?: TaxSummaryWhereInput
    some?: TaxSummaryWhereInput
    none?: TaxSummaryWhereInput
  }

  export type ProfitLossListRelationFilter = {
    every?: ProfitLossWhereInput
    some?: ProfitLossWhereInput
    none?: ProfitLossWhereInput
  }

  export type BalanceSheetListRelationFilter = {
    every?: BalanceSheetWhereInput
    some?: BalanceSheetWhereInput
    none?: BalanceSheetWhereInput
  }

  export type DepreciationEntryListRelationFilter = {
    every?: DepreciationEntryWhereInput
    some?: DepreciationEntryWhereInput
    none?: DepreciationEntryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Form16DataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CapitalGainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalInsuranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxPaidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterestIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DividendIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgriculturalIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExemptIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ITRGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfitLossOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalanceSheetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepreciationEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    emailVerificationDate?: SortOrder
    lastVerificationEmailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    emailVerificationDate?: SortOrder
    lastVerificationEmailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    emailVerificationDate?: SortOrder
    lastVerificationEmailSent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PersonalDetailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    maritalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    maritalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalDetailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    maritalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type ContactDetailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    panNumber?: SortOrder
    aadharNumber?: SortOrder
    alternativeEmail?: SortOrder
    alternativePhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    panNumber?: SortOrder
    aadharNumber?: SortOrder
    alternativeEmail?: SortOrder
    alternativePhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactDetailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    panNumber?: SortOrder
    aadharNumber?: SortOrder
    alternativeEmail?: SortOrder
    alternativePhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressDetailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    flatNo?: SortOrder
    premiseName?: SortOrder
    road?: SortOrder
    area?: SortOrder
    pincode?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    flatNo?: SortOrder
    premiseName?: SortOrder
    road?: SortOrder
    area?: SortOrder
    pincode?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressDetailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    flatNo?: SortOrder
    premiseName?: SortOrder
    road?: SortOrder
    area?: SortOrder
    pincode?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    bankName?: SortOrder
    accountType?: SortOrder
    accountHolderName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    bankName?: SortOrder
    accountType?: SortOrder
    accountHolderName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountNumber?: SortOrder
    ifscCode?: SortOrder
    bankName?: SortOrder
    accountType?: SortOrder
    accountHolderName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Form16DataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employerName?: SortOrder
    employerTAN?: SortOrder
    employerCategory?: SortOrder
    totalTax?: SortOrder
    grossSalary?: SortOrder
    notifiedIncome?: SortOrder
    salaryBreakup?: SortOrder
    perquisitesAmount?: SortOrder
    perquisites?: SortOrder
    profitAmount?: SortOrder
    profitsInLieu?: SortOrder
    notifiedCountry?: SortOrder
    notifiedIncomeOtherCountry?: SortOrder
    previousYearIncomeTax?: SortOrder
    exemptAllowance?: SortOrder
    exemptAllowanceBreakup?: SortOrder
    balance?: SortOrder
    standardDeduction?: SortOrder
    professionalTax?: SortOrder
    reliefUnder89?: SortOrder
    incomeClaimed?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Form16DataAvgOrderByAggregateInput = {
    totalTax?: SortOrder
    grossSalary?: SortOrder
    notifiedIncome?: SortOrder
    perquisitesAmount?: SortOrder
    profitAmount?: SortOrder
    notifiedIncomeOtherCountry?: SortOrder
    previousYearIncomeTax?: SortOrder
    exemptAllowance?: SortOrder
    balance?: SortOrder
    standardDeduction?: SortOrder
    professionalTax?: SortOrder
    reliefUnder89?: SortOrder
    incomeClaimed?: SortOrder
  }

  export type Form16DataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employerName?: SortOrder
    employerTAN?: SortOrder
    employerCategory?: SortOrder
    totalTax?: SortOrder
    grossSalary?: SortOrder
    notifiedIncome?: SortOrder
    perquisitesAmount?: SortOrder
    profitAmount?: SortOrder
    notifiedIncomeOtherCountry?: SortOrder
    previousYearIncomeTax?: SortOrder
    exemptAllowance?: SortOrder
    balance?: SortOrder
    standardDeduction?: SortOrder
    professionalTax?: SortOrder
    reliefUnder89?: SortOrder
    incomeClaimed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Form16DataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employerName?: SortOrder
    employerTAN?: SortOrder
    employerCategory?: SortOrder
    totalTax?: SortOrder
    grossSalary?: SortOrder
    notifiedIncome?: SortOrder
    perquisitesAmount?: SortOrder
    profitAmount?: SortOrder
    notifiedIncomeOtherCountry?: SortOrder
    previousYearIncomeTax?: SortOrder
    exemptAllowance?: SortOrder
    balance?: SortOrder
    standardDeduction?: SortOrder
    professionalTax?: SortOrder
    reliefUnder89?: SortOrder
    incomeClaimed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Form16DataSumOrderByAggregateInput = {
    totalTax?: SortOrder
    grossSalary?: SortOrder
    notifiedIncome?: SortOrder
    perquisitesAmount?: SortOrder
    profitAmount?: SortOrder
    notifiedIncomeOtherCountry?: SortOrder
    previousYearIncomeTax?: SortOrder
    exemptAllowance?: SortOrder
    balance?: SortOrder
    standardDeduction?: SortOrder
    professionalTax?: SortOrder
    reliefUnder89?: SortOrder
    incomeClaimed?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyIndex?: SortOrder
    propertyType?: SortOrder
    netTaxableIncome?: SortOrder
    houseAddress?: SortOrder
    ownerDetails?: SortOrder
    taxSavings?: SortOrder
    rentalIncomeDetails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    netTaxableIncome?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyIndex?: SortOrder
    propertyType?: SortOrder
    netTaxableIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyIndex?: SortOrder
    propertyType?: SortOrder
    netTaxableIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    netTaxableIncome?: SortOrder
  }

  export type CapitalGainCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrder
    assetSubType?: SortOrder
    dateOfSale?: SortOrder
    dateOfPurchase?: SortOrder
    description?: SortOrder
    salePrice?: SortOrder
    transferExpenses?: SortOrder
    purchasePrice?: SortOrder
    sttPaid?: SortOrder
    totalProfit?: SortOrder
    indexationCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapitalGainAvgOrderByAggregateInput = {
    salePrice?: SortOrder
    transferExpenses?: SortOrder
    purchasePrice?: SortOrder
    totalProfit?: SortOrder
    indexationCost?: SortOrder
  }

  export type CapitalGainMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrder
    assetSubType?: SortOrder
    dateOfSale?: SortOrder
    dateOfPurchase?: SortOrder
    description?: SortOrder
    salePrice?: SortOrder
    transferExpenses?: SortOrder
    purchasePrice?: SortOrder
    sttPaid?: SortOrder
    totalProfit?: SortOrder
    indexationCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapitalGainMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrder
    assetSubType?: SortOrder
    dateOfSale?: SortOrder
    dateOfPurchase?: SortOrder
    description?: SortOrder
    salePrice?: SortOrder
    transferExpenses?: SortOrder
    purchasePrice?: SortOrder
    sttPaid?: SortOrder
    totalProfit?: SortOrder
    indexationCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CapitalGainSumOrderByAggregateInput = {
    salePrice?: SortOrder
    transferExpenses?: SortOrder
    purchasePrice?: SortOrder
    totalProfit?: SortOrder
    indexationCost?: SortOrder
  }

  export type InterestIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sourceType?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    interestAmount?: SortOrder
    tdsDeducted?: SortOrder
    financialYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestIncomeAvgOrderByAggregateInput = {
    interestAmount?: SortOrder
    tdsDeducted?: SortOrder
  }

  export type InterestIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sourceType?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    interestAmount?: SortOrder
    tdsDeducted?: SortOrder
    financialYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sourceType?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    interestAmount?: SortOrder
    tdsDeducted?: SortOrder
    financialYear?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterestIncomeSumOrderByAggregateInput = {
    interestAmount?: SortOrder
    tdsDeducted?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DividendIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    dividendAmount?: SortOrder
    taxDeducted?: SortOrder
    dateReceived?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DividendIncomeAvgOrderByAggregateInput = {
    dividendAmount?: SortOrder
    taxDeducted?: SortOrder
    shareQuantity?: SortOrder
  }

  export type DividendIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    dividendAmount?: SortOrder
    taxDeducted?: SortOrder
    dateReceived?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DividendIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    dividendAmount?: SortOrder
    taxDeducted?: SortOrder
    dateReceived?: SortOrder
    shareQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DividendIncomeSumOrderByAggregateInput = {
    dividendAmount?: SortOrder
    taxDeducted?: SortOrder
    shareQuantity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BusinessIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    businessType?: SortOrder
    businessAddress?: SortOrder
    grossReceipts?: SortOrder
    totalIncome?: SortOrder
    businessExpenses?: SortOrder
    netProfit?: SortOrder
    depreciationClaimed?: SortOrder
    presumptiveIncome?: SortOrder
    section44AD?: SortOrder
    section44AE?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessIncomeAvgOrderByAggregateInput = {
    grossReceipts?: SortOrder
    totalIncome?: SortOrder
    businessExpenses?: SortOrder
    netProfit?: SortOrder
    depreciationClaimed?: SortOrder
    presumptiveIncome?: SortOrder
  }

  export type BusinessIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    businessType?: SortOrder
    businessAddress?: SortOrder
    grossReceipts?: SortOrder
    totalIncome?: SortOrder
    businessExpenses?: SortOrder
    netProfit?: SortOrder
    depreciationClaimed?: SortOrder
    presumptiveIncome?: SortOrder
    section44AD?: SortOrder
    section44AE?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessName?: SortOrder
    businessType?: SortOrder
    businessAddress?: SortOrder
    grossReceipts?: SortOrder
    totalIncome?: SortOrder
    businessExpenses?: SortOrder
    netProfit?: SortOrder
    depreciationClaimed?: SortOrder
    presumptiveIncome?: SortOrder
    section44AD?: SortOrder
    section44AE?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessIncomeSumOrderByAggregateInput = {
    grossReceipts?: SortOrder
    totalIncome?: SortOrder
    businessExpenses?: SortOrder
    netProfit?: SortOrder
    depreciationClaimed?: SortOrder
    presumptiveIncome?: SortOrder
  }

  export type ProfessionalIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    professionType?: SortOrder
    grossReceipts?: SortOrder
    totalExpenses?: SortOrder
    netProfit?: SortOrder
    section44ADA?: SortOrder
    presumptiveIncome?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfessionalIncomeAvgOrderByAggregateInput = {
    grossReceipts?: SortOrder
    totalExpenses?: SortOrder
    netProfit?: SortOrder
    presumptiveIncome?: SortOrder
  }

  export type ProfessionalIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    professionType?: SortOrder
    grossReceipts?: SortOrder
    totalExpenses?: SortOrder
    netProfit?: SortOrder
    section44ADA?: SortOrder
    presumptiveIncome?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfessionalIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    professionType?: SortOrder
    grossReceipts?: SortOrder
    totalExpenses?: SortOrder
    netProfit?: SortOrder
    section44ADA?: SortOrder
    presumptiveIncome?: SortOrder
    auditRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfessionalIncomeSumOrderByAggregateInput = {
    grossReceipts?: SortOrder
    totalExpenses?: SortOrder
    netProfit?: SortOrder
    presumptiveIncome?: SortOrder
  }

  export type ProfitLossCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    year?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    netProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfitLossAvgOrderByAggregateInput = {
    netProfit?: SortOrder
  }

  export type ProfitLossMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    year?: SortOrder
    netProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfitLossMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    year?: SortOrder
    netProfit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfitLossSumOrderByAggregateInput = {
    netProfit?: SortOrder
  }

  export type BalanceSheetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    year?: SortOrder
    assets?: SortOrder
    liabilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceSheetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalanceSheetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    assetName?: SortOrder
    assetCategory?: SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    depreciationRate?: SortOrder
    accumulatedDepreciation?: SortOrder
    writtenDownValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationEntryAvgOrderByAggregateInput = {
    purchaseCost?: SortOrder
    depreciationRate?: SortOrder
    accumulatedDepreciation?: SortOrder
    writtenDownValue?: SortOrder
  }

  export type DepreciationEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    assetName?: SortOrder
    assetCategory?: SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    depreciationRate?: SortOrder
    accumulatedDepreciation?: SortOrder
    writtenDownValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    businessIncomeId?: SortOrder
    assetName?: SortOrder
    assetCategory?: SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    depreciationRate?: SortOrder
    accumulatedDepreciation?: SortOrder
    writtenDownValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepreciationEntrySumOrderByAggregateInput = {
    purchaseCost?: SortOrder
    depreciationRate?: SortOrder
    accumulatedDepreciation?: SortOrder
    writtenDownValue?: SortOrder
  }

  export type CryptoIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrder
    coinName?: SortOrder
    purchaseDate?: SortOrder
    saleDate?: SortOrder
    purchasePrice?: SortOrder
    salePrice?: SortOrder
    quantity?: SortOrder
    exchangeName?: SortOrder
    transactionHash?: SortOrder
    profit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoIncomeAvgOrderByAggregateInput = {
    purchasePrice?: SortOrder
    salePrice?: SortOrder
    quantity?: SortOrder
    profit?: SortOrder
  }

  export type CryptoIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrder
    coinName?: SortOrder
    purchaseDate?: SortOrder
    saleDate?: SortOrder
    purchasePrice?: SortOrder
    salePrice?: SortOrder
    quantity?: SortOrder
    exchangeName?: SortOrder
    transactionHash?: SortOrder
    profit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assetType?: SortOrder
    coinName?: SortOrder
    purchaseDate?: SortOrder
    saleDate?: SortOrder
    purchasePrice?: SortOrder
    salePrice?: SortOrder
    quantity?: SortOrder
    exchangeName?: SortOrder
    transactionHash?: SortOrder
    profit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoIncomeSumOrderByAggregateInput = {
    purchasePrice?: SortOrder
    salePrice?: SortOrder
    quantity?: SortOrder
    profit?: SortOrder
  }

  export type AgriculturalIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    landArea?: SortOrder
    location?: SortOrder
    cropType?: SortOrder
    annualIncome?: SortOrder
    expenses?: SortOrder
    netIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgriculturalIncomeAvgOrderByAggregateInput = {
    landArea?: SortOrder
    annualIncome?: SortOrder
    expenses?: SortOrder
    netIncome?: SortOrder
  }

  export type AgriculturalIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    landArea?: SortOrder
    location?: SortOrder
    cropType?: SortOrder
    annualIncome?: SortOrder
    expenses?: SortOrder
    netIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgriculturalIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    landArea?: SortOrder
    location?: SortOrder
    cropType?: SortOrder
    annualIncome?: SortOrder
    expenses?: SortOrder
    netIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgriculturalIncomeSumOrderByAggregateInput = {
    landArea?: SortOrder
    annualIncome?: SortOrder
    expenses?: SortOrder
    netIncome?: SortOrder
  }

  export type ExemptIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    incomeType?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExemptIncomeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExemptIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    incomeType?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExemptIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    incomeType?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExemptIncomeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TaxSavingInvestmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSavingInvestmentAvgOrderByAggregateInput = {
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
  }

  export type TaxSavingInvestmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSavingInvestmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSavingInvestmentSumOrderByAggregateInput = {
    section80C?: SortOrder
    savingsInterest80TTA?: SortOrder
    pensionContribution80CCC?: SortOrder
    npsEmployeeContribution?: SortOrder
    npsEmployerContribution?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationName?: SortOrder
    donationType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    receiptNumber?: SortOrder
    eligibleAmount?: SortOrder
    deductionPercentage?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    amount?: SortOrder
    eligibleAmount?: SortOrder
    deductionPercentage?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationName?: SortOrder
    donationType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    receiptNumber?: SortOrder
    eligibleAmount?: SortOrder
    deductionPercentage?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationName?: SortOrder
    donationType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    receiptNumber?: SortOrder
    eligibleAmount?: SortOrder
    deductionPercentage?: SortOrder
    section?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    amount?: SortOrder
    eligibleAmount?: SortOrder
    deductionPercentage?: SortOrder
  }

  export type MedicalInsuranceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    policyType?: SortOrder
    insuredPersons?: SortOrder
    premiumPaid?: SortOrder
    eligibleAmount?: SortOrder
    policyNumber?: SortOrder
    insuranceCompany?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInsuranceAvgOrderByAggregateInput = {
    premiumPaid?: SortOrder
    eligibleAmount?: SortOrder
  }

  export type MedicalInsuranceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    policyType?: SortOrder
    insuredPersons?: SortOrder
    premiumPaid?: SortOrder
    eligibleAmount?: SortOrder
    policyNumber?: SortOrder
    insuranceCompany?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInsuranceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    policyType?: SortOrder
    insuredPersons?: SortOrder
    premiumPaid?: SortOrder
    eligibleAmount?: SortOrder
    policyNumber?: SortOrder
    insuranceCompany?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalInsuranceSumOrderByAggregateInput = {
    premiumPaid?: SortOrder
    eligibleAmount?: SortOrder
  }

  export type TaxPaidCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taxType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    challanNumber?: SortOrder
    bankName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPaidAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TaxPaidMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taxType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    challanNumber?: SortOrder
    bankName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPaidMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taxType?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    challanNumber?: SortOrder
    bankName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxPaidSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type WalletScalarRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    razorpayPaymentId?: SortOrder
    razorpayOrderId?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumITRTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRType | EnumITRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumITRTypeFilter<$PrismaModel> | $Enums.ITRType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumITRStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRStatus | EnumITRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumITRStatusFilter<$PrismaModel> | $Enums.ITRStatus
  }

  export type ITRGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itrType?: SortOrder
    assessmentYear?: SortOrder
    fileName?: SortOrder
    checksum?: SortOrder
    jsonData?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrder
  }

  export type ITRGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itrType?: SortOrder
    assessmentYear?: SortOrder
    fileName?: SortOrder
    checksum?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrder
  }

  export type ITRGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    itrType?: SortOrder
    assessmentYear?: SortOrder
    fileName?: SortOrder
    checksum?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    downloadedAt?: SortOrder
  }

  export type EnumITRTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRType | EnumITRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumITRTypeWithAggregatesFilter<$PrismaModel> | $Enums.ITRType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumITRTypeFilter<$PrismaModel>
    _max?: NestedEnumITRTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumITRStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRStatus | EnumITRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumITRStatusWithAggregatesFilter<$PrismaModel> | $Enums.ITRStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumITRStatusFilter<$PrismaModel>
    _max?: NestedEnumITRStatusFilter<$PrismaModel>
  }

  export type TaxSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentYear?: SortOrder
    totalIncome?: SortOrder
    totalDeductions?: SortOrder
    taxableIncome?: SortOrder
    taxLiability?: SortOrder
    taxPaid?: SortOrder
    refundAmount?: SortOrder
    filingStatus?: SortOrder
    filingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSummaryAvgOrderByAggregateInput = {
    totalIncome?: SortOrder
    totalDeductions?: SortOrder
    taxableIncome?: SortOrder
    taxLiability?: SortOrder
    taxPaid?: SortOrder
    refundAmount?: SortOrder
  }

  export type TaxSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentYear?: SortOrder
    totalIncome?: SortOrder
    totalDeductions?: SortOrder
    taxableIncome?: SortOrder
    taxLiability?: SortOrder
    taxPaid?: SortOrder
    refundAmount?: SortOrder
    filingStatus?: SortOrder
    filingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentYear?: SortOrder
    totalIncome?: SortOrder
    totalDeductions?: SortOrder
    taxableIncome?: SortOrder
    taxLiability?: SortOrder
    taxPaid?: SortOrder
    refundAmount?: SortOrder
    filingStatus?: SortOrder
    filingDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxSummarySumOrderByAggregateInput = {
    totalIncome?: SortOrder
    totalDeductions?: SortOrder
    taxableIncome?: SortOrder
    taxLiability?: SortOrder
    taxPaid?: SortOrder
    refundAmount?: SortOrder
  }

  export type PersonalDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalDetailCreateWithoutUserInput, PersonalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailCreateOrConnectWithoutUserInput
    connect?: PersonalDetailWhereUniqueInput
  }

  export type ContactDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<ContactDetailCreateWithoutUserInput, ContactDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactDetailCreateOrConnectWithoutUserInput
    connect?: ContactDetailWhereUniqueInput
  }

  export type BankDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<BankDetailCreateWithoutUserInput, BankDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: BankDetailCreateOrConnectWithoutUserInput
    connect?: BankDetailWhereUniqueInput
  }

  export type AddressDetailCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressDetailCreateWithoutUserInput, AddressDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressDetailCreateOrConnectWithoutUserInput
    connect?: AddressDetailWhereUniqueInput
  }

  export type Form16DataCreateNestedManyWithoutUserInput = {
    create?: XOR<Form16DataCreateWithoutUserInput, Form16DataUncheckedCreateWithoutUserInput> | Form16DataCreateWithoutUserInput[] | Form16DataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Form16DataCreateOrConnectWithoutUserInput | Form16DataCreateOrConnectWithoutUserInput[]
    createMany?: Form16DataCreateManyUserInputEnvelope
    connect?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type CapitalGainCreateNestedManyWithoutUserInput = {
    create?: XOR<CapitalGainCreateWithoutUserInput, CapitalGainUncheckedCreateWithoutUserInput> | CapitalGainCreateWithoutUserInput[] | CapitalGainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CapitalGainCreateOrConnectWithoutUserInput | CapitalGainCreateOrConnectWithoutUserInput[]
    createMany?: CapitalGainCreateManyUserInputEnvelope
    connect?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
  }

  export type BusinessIncomeCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessIncomeCreateWithoutUserInput, BusinessIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutUserInput
    connect?: BusinessIncomeWhereUniqueInput
  }

  export type ProfessionalIncomeCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfessionalIncomeCreateWithoutUserInput, ProfessionalIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfessionalIncomeCreateOrConnectWithoutUserInput
    connect?: ProfessionalIncomeWhereUniqueInput
  }

  export type CryptoIncomeCreateNestedManyWithoutUserInput = {
    create?: XOR<CryptoIncomeCreateWithoutUserInput, CryptoIncomeUncheckedCreateWithoutUserInput> | CryptoIncomeCreateWithoutUserInput[] | CryptoIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoIncomeCreateOrConnectWithoutUserInput | CryptoIncomeCreateOrConnectWithoutUserInput[]
    createMany?: CryptoIncomeCreateManyUserInputEnvelope
    connect?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
  }

  export type TaxSavingInvestmentCreateNestedOneWithoutUserInput = {
    create?: XOR<TaxSavingInvestmentCreateWithoutUserInput, TaxSavingInvestmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: TaxSavingInvestmentCreateOrConnectWithoutUserInput
    connect?: TaxSavingInvestmentWhereUniqueInput
  }

  export type DonationCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type MedicalInsuranceCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicalInsuranceCreateWithoutUserInput, MedicalInsuranceUncheckedCreateWithoutUserInput> | MedicalInsuranceCreateWithoutUserInput[] | MedicalInsuranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalInsuranceCreateOrConnectWithoutUserInput | MedicalInsuranceCreateOrConnectWithoutUserInput[]
    createMany?: MedicalInsuranceCreateManyUserInputEnvelope
    connect?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
  }

  export type TaxPaidCreateNestedManyWithoutUserInput = {
    create?: XOR<TaxPaidCreateWithoutUserInput, TaxPaidUncheckedCreateWithoutUserInput> | TaxPaidCreateWithoutUserInput[] | TaxPaidUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxPaidCreateOrConnectWithoutUserInput | TaxPaidCreateOrConnectWithoutUserInput[]
    createMany?: TaxPaidCreateManyUserInputEnvelope
    connect?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
  }

  export type InterestIncomeCreateNestedManyWithoutUserInput = {
    create?: XOR<InterestIncomeCreateWithoutUserInput, InterestIncomeUncheckedCreateWithoutUserInput> | InterestIncomeCreateWithoutUserInput[] | InterestIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterestIncomeCreateOrConnectWithoutUserInput | InterestIncomeCreateOrConnectWithoutUserInput[]
    createMany?: InterestIncomeCreateManyUserInputEnvelope
    connect?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
  }

  export type DividendIncomeCreateNestedManyWithoutUserInput = {
    create?: XOR<DividendIncomeCreateWithoutUserInput, DividendIncomeUncheckedCreateWithoutUserInput> | DividendIncomeCreateWithoutUserInput[] | DividendIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DividendIncomeCreateOrConnectWithoutUserInput | DividendIncomeCreateOrConnectWithoutUserInput[]
    createMany?: DividendIncomeCreateManyUserInputEnvelope
    connect?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
  }

  export type AgriculturalIncomeCreateNestedManyWithoutUserInput = {
    create?: XOR<AgriculturalIncomeCreateWithoutUserInput, AgriculturalIncomeUncheckedCreateWithoutUserInput> | AgriculturalIncomeCreateWithoutUserInput[] | AgriculturalIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgriculturalIncomeCreateOrConnectWithoutUserInput | AgriculturalIncomeCreateOrConnectWithoutUserInput[]
    createMany?: AgriculturalIncomeCreateManyUserInputEnvelope
    connect?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
  }

  export type ExemptIncomeCreateNestedManyWithoutUserInput = {
    create?: XOR<ExemptIncomeCreateWithoutUserInput, ExemptIncomeUncheckedCreateWithoutUserInput> | ExemptIncomeCreateWithoutUserInput[] | ExemptIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExemptIncomeCreateOrConnectWithoutUserInput | ExemptIncomeCreateOrConnectWithoutUserInput[]
    createMany?: ExemptIncomeCreateManyUserInputEnvelope
    connect?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type ITRGenerationCreateNestedManyWithoutUserInput = {
    create?: XOR<ITRGenerationCreateWithoutUserInput, ITRGenerationUncheckedCreateWithoutUserInput> | ITRGenerationCreateWithoutUserInput[] | ITRGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ITRGenerationCreateOrConnectWithoutUserInput | ITRGenerationCreateOrConnectWithoutUserInput[]
    createMany?: ITRGenerationCreateManyUserInputEnvelope
    connect?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
  }

  export type TaxSummaryCreateNestedManyWithoutUserInput = {
    create?: XOR<TaxSummaryCreateWithoutUserInput, TaxSummaryUncheckedCreateWithoutUserInput> | TaxSummaryCreateWithoutUserInput[] | TaxSummaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxSummaryCreateOrConnectWithoutUserInput | TaxSummaryCreateOrConnectWithoutUserInput[]
    createMany?: TaxSummaryCreateManyUserInputEnvelope
    connect?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
  }

  export type ProfitLossCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfitLossCreateWithoutUserInput, ProfitLossUncheckedCreateWithoutUserInput> | ProfitLossCreateWithoutUserInput[] | ProfitLossUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutUserInput | ProfitLossCreateOrConnectWithoutUserInput[]
    createMany?: ProfitLossCreateManyUserInputEnvelope
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
  }

  export type BalanceSheetCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceSheetCreateWithoutUserInput, BalanceSheetUncheckedCreateWithoutUserInput> | BalanceSheetCreateWithoutUserInput[] | BalanceSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutUserInput | BalanceSheetCreateOrConnectWithoutUserInput[]
    createMany?: BalanceSheetCreateManyUserInputEnvelope
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
  }

  export type DepreciationEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<DepreciationEntryCreateWithoutUserInput, DepreciationEntryUncheckedCreateWithoutUserInput> | DepreciationEntryCreateWithoutUserInput[] | DepreciationEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutUserInput | DepreciationEntryCreateOrConnectWithoutUserInput[]
    createMany?: DepreciationEntryCreateManyUserInputEnvelope
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
  }

  export type PersonalDetailUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonalDetailCreateWithoutUserInput, PersonalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailCreateOrConnectWithoutUserInput
    connect?: PersonalDetailWhereUniqueInput
  }

  export type ContactDetailUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ContactDetailCreateWithoutUserInput, ContactDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactDetailCreateOrConnectWithoutUserInput
    connect?: ContactDetailWhereUniqueInput
  }

  export type BankDetailUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BankDetailCreateWithoutUserInput, BankDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: BankDetailCreateOrConnectWithoutUserInput
    connect?: BankDetailWhereUniqueInput
  }

  export type AddressDetailUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressDetailCreateWithoutUserInput, AddressDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressDetailCreateOrConnectWithoutUserInput
    connect?: AddressDetailWhereUniqueInput
  }

  export type Form16DataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Form16DataCreateWithoutUserInput, Form16DataUncheckedCreateWithoutUserInput> | Form16DataCreateWithoutUserInput[] | Form16DataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Form16DataCreateOrConnectWithoutUserInput | Form16DataCreateOrConnectWithoutUserInput[]
    createMany?: Form16DataCreateManyUserInputEnvelope
    connect?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type CapitalGainUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CapitalGainCreateWithoutUserInput, CapitalGainUncheckedCreateWithoutUserInput> | CapitalGainCreateWithoutUserInput[] | CapitalGainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CapitalGainCreateOrConnectWithoutUserInput | CapitalGainCreateOrConnectWithoutUserInput[]
    createMany?: CapitalGainCreateManyUserInputEnvelope
    connect?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
  }

  export type BusinessIncomeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BusinessIncomeCreateWithoutUserInput, BusinessIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutUserInput
    connect?: BusinessIncomeWhereUniqueInput
  }

  export type ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfessionalIncomeCreateWithoutUserInput, ProfessionalIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfessionalIncomeCreateOrConnectWithoutUserInput
    connect?: ProfessionalIncomeWhereUniqueInput
  }

  export type CryptoIncomeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CryptoIncomeCreateWithoutUserInput, CryptoIncomeUncheckedCreateWithoutUserInput> | CryptoIncomeCreateWithoutUserInput[] | CryptoIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoIncomeCreateOrConnectWithoutUserInput | CryptoIncomeCreateOrConnectWithoutUserInput[]
    createMany?: CryptoIncomeCreateManyUserInputEnvelope
    connect?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
  }

  export type TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TaxSavingInvestmentCreateWithoutUserInput, TaxSavingInvestmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: TaxSavingInvestmentCreateOrConnectWithoutUserInput
    connect?: TaxSavingInvestmentWhereUniqueInput
  }

  export type DonationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicalInsuranceCreateWithoutUserInput, MedicalInsuranceUncheckedCreateWithoutUserInput> | MedicalInsuranceCreateWithoutUserInput[] | MedicalInsuranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalInsuranceCreateOrConnectWithoutUserInput | MedicalInsuranceCreateOrConnectWithoutUserInput[]
    createMany?: MedicalInsuranceCreateManyUserInputEnvelope
    connect?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
  }

  export type TaxPaidUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaxPaidCreateWithoutUserInput, TaxPaidUncheckedCreateWithoutUserInput> | TaxPaidCreateWithoutUserInput[] | TaxPaidUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxPaidCreateOrConnectWithoutUserInput | TaxPaidCreateOrConnectWithoutUserInput[]
    createMany?: TaxPaidCreateManyUserInputEnvelope
    connect?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
  }

  export type InterestIncomeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterestIncomeCreateWithoutUserInput, InterestIncomeUncheckedCreateWithoutUserInput> | InterestIncomeCreateWithoutUserInput[] | InterestIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterestIncomeCreateOrConnectWithoutUserInput | InterestIncomeCreateOrConnectWithoutUserInput[]
    createMany?: InterestIncomeCreateManyUserInputEnvelope
    connect?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
  }

  export type DividendIncomeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DividendIncomeCreateWithoutUserInput, DividendIncomeUncheckedCreateWithoutUserInput> | DividendIncomeCreateWithoutUserInput[] | DividendIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DividendIncomeCreateOrConnectWithoutUserInput | DividendIncomeCreateOrConnectWithoutUserInput[]
    createMany?: DividendIncomeCreateManyUserInputEnvelope
    connect?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
  }

  export type AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgriculturalIncomeCreateWithoutUserInput, AgriculturalIncomeUncheckedCreateWithoutUserInput> | AgriculturalIncomeCreateWithoutUserInput[] | AgriculturalIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgriculturalIncomeCreateOrConnectWithoutUserInput | AgriculturalIncomeCreateOrConnectWithoutUserInput[]
    createMany?: AgriculturalIncomeCreateManyUserInputEnvelope
    connect?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
  }

  export type ExemptIncomeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExemptIncomeCreateWithoutUserInput, ExemptIncomeUncheckedCreateWithoutUserInput> | ExemptIncomeCreateWithoutUserInput[] | ExemptIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExemptIncomeCreateOrConnectWithoutUserInput | ExemptIncomeCreateOrConnectWithoutUserInput[]
    createMany?: ExemptIncomeCreateManyUserInputEnvelope
    connect?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type ITRGenerationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ITRGenerationCreateWithoutUserInput, ITRGenerationUncheckedCreateWithoutUserInput> | ITRGenerationCreateWithoutUserInput[] | ITRGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ITRGenerationCreateOrConnectWithoutUserInput | ITRGenerationCreateOrConnectWithoutUserInput[]
    createMany?: ITRGenerationCreateManyUserInputEnvelope
    connect?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
  }

  export type TaxSummaryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaxSummaryCreateWithoutUserInput, TaxSummaryUncheckedCreateWithoutUserInput> | TaxSummaryCreateWithoutUserInput[] | TaxSummaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxSummaryCreateOrConnectWithoutUserInput | TaxSummaryCreateOrConnectWithoutUserInput[]
    createMany?: TaxSummaryCreateManyUserInputEnvelope
    connect?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
  }

  export type ProfitLossUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfitLossCreateWithoutUserInput, ProfitLossUncheckedCreateWithoutUserInput> | ProfitLossCreateWithoutUserInput[] | ProfitLossUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutUserInput | ProfitLossCreateOrConnectWithoutUserInput[]
    createMany?: ProfitLossCreateManyUserInputEnvelope
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
  }

  export type BalanceSheetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BalanceSheetCreateWithoutUserInput, BalanceSheetUncheckedCreateWithoutUserInput> | BalanceSheetCreateWithoutUserInput[] | BalanceSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutUserInput | BalanceSheetCreateOrConnectWithoutUserInput[]
    createMany?: BalanceSheetCreateManyUserInputEnvelope
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
  }

  export type DepreciationEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DepreciationEntryCreateWithoutUserInput, DepreciationEntryUncheckedCreateWithoutUserInput> | DepreciationEntryCreateWithoutUserInput[] | DepreciationEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutUserInput | DepreciationEntryCreateOrConnectWithoutUserInput[]
    createMany?: DepreciationEntryCreateManyUserInputEnvelope
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PersonalDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalDetailCreateWithoutUserInput, PersonalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailCreateOrConnectWithoutUserInput
    upsert?: PersonalDetailUpsertWithoutUserInput
    disconnect?: PersonalDetailWhereInput | boolean
    delete?: PersonalDetailWhereInput | boolean
    connect?: PersonalDetailWhereUniqueInput
    update?: XOR<XOR<PersonalDetailUpdateToOneWithWhereWithoutUserInput, PersonalDetailUpdateWithoutUserInput>, PersonalDetailUncheckedUpdateWithoutUserInput>
  }

  export type ContactDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<ContactDetailCreateWithoutUserInput, ContactDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactDetailCreateOrConnectWithoutUserInput
    upsert?: ContactDetailUpsertWithoutUserInput
    disconnect?: ContactDetailWhereInput | boolean
    delete?: ContactDetailWhereInput | boolean
    connect?: ContactDetailWhereUniqueInput
    update?: XOR<XOR<ContactDetailUpdateToOneWithWhereWithoutUserInput, ContactDetailUpdateWithoutUserInput>, ContactDetailUncheckedUpdateWithoutUserInput>
  }

  export type BankDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<BankDetailCreateWithoutUserInput, BankDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: BankDetailCreateOrConnectWithoutUserInput
    upsert?: BankDetailUpsertWithoutUserInput
    disconnect?: BankDetailWhereInput | boolean
    delete?: BankDetailWhereInput | boolean
    connect?: BankDetailWhereUniqueInput
    update?: XOR<XOR<BankDetailUpdateToOneWithWhereWithoutUserInput, BankDetailUpdateWithoutUserInput>, BankDetailUncheckedUpdateWithoutUserInput>
  }

  export type AddressDetailUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressDetailCreateWithoutUserInput, AddressDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressDetailCreateOrConnectWithoutUserInput
    upsert?: AddressDetailUpsertWithoutUserInput
    disconnect?: AddressDetailWhereInput | boolean
    delete?: AddressDetailWhereInput | boolean
    connect?: AddressDetailWhereUniqueInput
    update?: XOR<XOR<AddressDetailUpdateToOneWithWhereWithoutUserInput, AddressDetailUpdateWithoutUserInput>, AddressDetailUncheckedUpdateWithoutUserInput>
  }

  export type Form16DataUpdateManyWithoutUserNestedInput = {
    create?: XOR<Form16DataCreateWithoutUserInput, Form16DataUncheckedCreateWithoutUserInput> | Form16DataCreateWithoutUserInput[] | Form16DataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Form16DataCreateOrConnectWithoutUserInput | Form16DataCreateOrConnectWithoutUserInput[]
    upsert?: Form16DataUpsertWithWhereUniqueWithoutUserInput | Form16DataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Form16DataCreateManyUserInputEnvelope
    set?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    disconnect?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    delete?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    connect?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    update?: Form16DataUpdateWithWhereUniqueWithoutUserInput | Form16DataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Form16DataUpdateManyWithWhereWithoutUserInput | Form16DataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Form16DataScalarWhereInput | Form16DataScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type CapitalGainUpdateManyWithoutUserNestedInput = {
    create?: XOR<CapitalGainCreateWithoutUserInput, CapitalGainUncheckedCreateWithoutUserInput> | CapitalGainCreateWithoutUserInput[] | CapitalGainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CapitalGainCreateOrConnectWithoutUserInput | CapitalGainCreateOrConnectWithoutUserInput[]
    upsert?: CapitalGainUpsertWithWhereUniqueWithoutUserInput | CapitalGainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CapitalGainCreateManyUserInputEnvelope
    set?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    disconnect?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    delete?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    connect?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    update?: CapitalGainUpdateWithWhereUniqueWithoutUserInput | CapitalGainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CapitalGainUpdateManyWithWhereWithoutUserInput | CapitalGainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CapitalGainScalarWhereInput | CapitalGainScalarWhereInput[]
  }

  export type BusinessIncomeUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessIncomeCreateWithoutUserInput, BusinessIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutUserInput
    upsert?: BusinessIncomeUpsertWithoutUserInput
    disconnect?: BusinessIncomeWhereInput | boolean
    delete?: BusinessIncomeWhereInput | boolean
    connect?: BusinessIncomeWhereUniqueInput
    update?: XOR<XOR<BusinessIncomeUpdateToOneWithWhereWithoutUserInput, BusinessIncomeUpdateWithoutUserInput>, BusinessIncomeUncheckedUpdateWithoutUserInput>
  }

  export type ProfessionalIncomeUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfessionalIncomeCreateWithoutUserInput, ProfessionalIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfessionalIncomeCreateOrConnectWithoutUserInput
    upsert?: ProfessionalIncomeUpsertWithoutUserInput
    disconnect?: ProfessionalIncomeWhereInput | boolean
    delete?: ProfessionalIncomeWhereInput | boolean
    connect?: ProfessionalIncomeWhereUniqueInput
    update?: XOR<XOR<ProfessionalIncomeUpdateToOneWithWhereWithoutUserInput, ProfessionalIncomeUpdateWithoutUserInput>, ProfessionalIncomeUncheckedUpdateWithoutUserInput>
  }

  export type CryptoIncomeUpdateManyWithoutUserNestedInput = {
    create?: XOR<CryptoIncomeCreateWithoutUserInput, CryptoIncomeUncheckedCreateWithoutUserInput> | CryptoIncomeCreateWithoutUserInput[] | CryptoIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoIncomeCreateOrConnectWithoutUserInput | CryptoIncomeCreateOrConnectWithoutUserInput[]
    upsert?: CryptoIncomeUpsertWithWhereUniqueWithoutUserInput | CryptoIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CryptoIncomeCreateManyUserInputEnvelope
    set?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    disconnect?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    delete?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    connect?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    update?: CryptoIncomeUpdateWithWhereUniqueWithoutUserInput | CryptoIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CryptoIncomeUpdateManyWithWhereWithoutUserInput | CryptoIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CryptoIncomeScalarWhereInput | CryptoIncomeScalarWhereInput[]
  }

  export type TaxSavingInvestmentUpdateOneWithoutUserNestedInput = {
    create?: XOR<TaxSavingInvestmentCreateWithoutUserInput, TaxSavingInvestmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: TaxSavingInvestmentCreateOrConnectWithoutUserInput
    upsert?: TaxSavingInvestmentUpsertWithoutUserInput
    disconnect?: TaxSavingInvestmentWhereInput | boolean
    delete?: TaxSavingInvestmentWhereInput | boolean
    connect?: TaxSavingInvestmentWhereUniqueInput
    update?: XOR<XOR<TaxSavingInvestmentUpdateToOneWithWhereWithoutUserInput, TaxSavingInvestmentUpdateWithoutUserInput>, TaxSavingInvestmentUncheckedUpdateWithoutUserInput>
  }

  export type DonationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type MedicalInsuranceUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicalInsuranceCreateWithoutUserInput, MedicalInsuranceUncheckedCreateWithoutUserInput> | MedicalInsuranceCreateWithoutUserInput[] | MedicalInsuranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalInsuranceCreateOrConnectWithoutUserInput | MedicalInsuranceCreateOrConnectWithoutUserInput[]
    upsert?: MedicalInsuranceUpsertWithWhereUniqueWithoutUserInput | MedicalInsuranceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicalInsuranceCreateManyUserInputEnvelope
    set?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    disconnect?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    delete?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    connect?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    update?: MedicalInsuranceUpdateWithWhereUniqueWithoutUserInput | MedicalInsuranceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicalInsuranceUpdateManyWithWhereWithoutUserInput | MedicalInsuranceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicalInsuranceScalarWhereInput | MedicalInsuranceScalarWhereInput[]
  }

  export type TaxPaidUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaxPaidCreateWithoutUserInput, TaxPaidUncheckedCreateWithoutUserInput> | TaxPaidCreateWithoutUserInput[] | TaxPaidUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxPaidCreateOrConnectWithoutUserInput | TaxPaidCreateOrConnectWithoutUserInput[]
    upsert?: TaxPaidUpsertWithWhereUniqueWithoutUserInput | TaxPaidUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaxPaidCreateManyUserInputEnvelope
    set?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    disconnect?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    delete?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    connect?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    update?: TaxPaidUpdateWithWhereUniqueWithoutUserInput | TaxPaidUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaxPaidUpdateManyWithWhereWithoutUserInput | TaxPaidUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaxPaidScalarWhereInput | TaxPaidScalarWhereInput[]
  }

  export type InterestIncomeUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterestIncomeCreateWithoutUserInput, InterestIncomeUncheckedCreateWithoutUserInput> | InterestIncomeCreateWithoutUserInput[] | InterestIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterestIncomeCreateOrConnectWithoutUserInput | InterestIncomeCreateOrConnectWithoutUserInput[]
    upsert?: InterestIncomeUpsertWithWhereUniqueWithoutUserInput | InterestIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterestIncomeCreateManyUserInputEnvelope
    set?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    disconnect?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    delete?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    connect?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    update?: InterestIncomeUpdateWithWhereUniqueWithoutUserInput | InterestIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterestIncomeUpdateManyWithWhereWithoutUserInput | InterestIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterestIncomeScalarWhereInput | InterestIncomeScalarWhereInput[]
  }

  export type DividendIncomeUpdateManyWithoutUserNestedInput = {
    create?: XOR<DividendIncomeCreateWithoutUserInput, DividendIncomeUncheckedCreateWithoutUserInput> | DividendIncomeCreateWithoutUserInput[] | DividendIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DividendIncomeCreateOrConnectWithoutUserInput | DividendIncomeCreateOrConnectWithoutUserInput[]
    upsert?: DividendIncomeUpsertWithWhereUniqueWithoutUserInput | DividendIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DividendIncomeCreateManyUserInputEnvelope
    set?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    disconnect?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    delete?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    connect?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    update?: DividendIncomeUpdateWithWhereUniqueWithoutUserInput | DividendIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DividendIncomeUpdateManyWithWhereWithoutUserInput | DividendIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DividendIncomeScalarWhereInput | DividendIncomeScalarWhereInput[]
  }

  export type AgriculturalIncomeUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgriculturalIncomeCreateWithoutUserInput, AgriculturalIncomeUncheckedCreateWithoutUserInput> | AgriculturalIncomeCreateWithoutUserInput[] | AgriculturalIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgriculturalIncomeCreateOrConnectWithoutUserInput | AgriculturalIncomeCreateOrConnectWithoutUserInput[]
    upsert?: AgriculturalIncomeUpsertWithWhereUniqueWithoutUserInput | AgriculturalIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgriculturalIncomeCreateManyUserInputEnvelope
    set?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    disconnect?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    delete?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    connect?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    update?: AgriculturalIncomeUpdateWithWhereUniqueWithoutUserInput | AgriculturalIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgriculturalIncomeUpdateManyWithWhereWithoutUserInput | AgriculturalIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgriculturalIncomeScalarWhereInput | AgriculturalIncomeScalarWhereInput[]
  }

  export type ExemptIncomeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExemptIncomeCreateWithoutUserInput, ExemptIncomeUncheckedCreateWithoutUserInput> | ExemptIncomeCreateWithoutUserInput[] | ExemptIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExemptIncomeCreateOrConnectWithoutUserInput | ExemptIncomeCreateOrConnectWithoutUserInput[]
    upsert?: ExemptIncomeUpsertWithWhereUniqueWithoutUserInput | ExemptIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExemptIncomeCreateManyUserInputEnvelope
    set?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    disconnect?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    delete?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    connect?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    update?: ExemptIncomeUpdateWithWhereUniqueWithoutUserInput | ExemptIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExemptIncomeUpdateManyWithWhereWithoutUserInput | ExemptIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExemptIncomeScalarWhereInput | ExemptIncomeScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type ITRGenerationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ITRGenerationCreateWithoutUserInput, ITRGenerationUncheckedCreateWithoutUserInput> | ITRGenerationCreateWithoutUserInput[] | ITRGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ITRGenerationCreateOrConnectWithoutUserInput | ITRGenerationCreateOrConnectWithoutUserInput[]
    upsert?: ITRGenerationUpsertWithWhereUniqueWithoutUserInput | ITRGenerationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ITRGenerationCreateManyUserInputEnvelope
    set?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    disconnect?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    delete?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    connect?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    update?: ITRGenerationUpdateWithWhereUniqueWithoutUserInput | ITRGenerationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ITRGenerationUpdateManyWithWhereWithoutUserInput | ITRGenerationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ITRGenerationScalarWhereInput | ITRGenerationScalarWhereInput[]
  }

  export type TaxSummaryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaxSummaryCreateWithoutUserInput, TaxSummaryUncheckedCreateWithoutUserInput> | TaxSummaryCreateWithoutUserInput[] | TaxSummaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxSummaryCreateOrConnectWithoutUserInput | TaxSummaryCreateOrConnectWithoutUserInput[]
    upsert?: TaxSummaryUpsertWithWhereUniqueWithoutUserInput | TaxSummaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaxSummaryCreateManyUserInputEnvelope
    set?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    disconnect?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    delete?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    connect?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    update?: TaxSummaryUpdateWithWhereUniqueWithoutUserInput | TaxSummaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaxSummaryUpdateManyWithWhereWithoutUserInput | TaxSummaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaxSummaryScalarWhereInput | TaxSummaryScalarWhereInput[]
  }

  export type ProfitLossUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfitLossCreateWithoutUserInput, ProfitLossUncheckedCreateWithoutUserInput> | ProfitLossCreateWithoutUserInput[] | ProfitLossUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutUserInput | ProfitLossCreateOrConnectWithoutUserInput[]
    upsert?: ProfitLossUpsertWithWhereUniqueWithoutUserInput | ProfitLossUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfitLossCreateManyUserInputEnvelope
    set?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    disconnect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    delete?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    update?: ProfitLossUpdateWithWhereUniqueWithoutUserInput | ProfitLossUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfitLossUpdateManyWithWhereWithoutUserInput | ProfitLossUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfitLossScalarWhereInput | ProfitLossScalarWhereInput[]
  }

  export type BalanceSheetUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceSheetCreateWithoutUserInput, BalanceSheetUncheckedCreateWithoutUserInput> | BalanceSheetCreateWithoutUserInput[] | BalanceSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutUserInput | BalanceSheetCreateOrConnectWithoutUserInput[]
    upsert?: BalanceSheetUpsertWithWhereUniqueWithoutUserInput | BalanceSheetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceSheetCreateManyUserInputEnvelope
    set?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    disconnect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    delete?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    update?: BalanceSheetUpdateWithWhereUniqueWithoutUserInput | BalanceSheetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceSheetUpdateManyWithWhereWithoutUserInput | BalanceSheetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceSheetScalarWhereInput | BalanceSheetScalarWhereInput[]
  }

  export type DepreciationEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepreciationEntryCreateWithoutUserInput, DepreciationEntryUncheckedCreateWithoutUserInput> | DepreciationEntryCreateWithoutUserInput[] | DepreciationEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutUserInput | DepreciationEntryCreateOrConnectWithoutUserInput[]
    upsert?: DepreciationEntryUpsertWithWhereUniqueWithoutUserInput | DepreciationEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepreciationEntryCreateManyUserInputEnvelope
    set?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    disconnect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    delete?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    update?: DepreciationEntryUpdateWithWhereUniqueWithoutUserInput | DepreciationEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepreciationEntryUpdateManyWithWhereWithoutUserInput | DepreciationEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepreciationEntryScalarWhereInput | DepreciationEntryScalarWhereInput[]
  }

  export type PersonalDetailUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonalDetailCreateWithoutUserInput, PersonalDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonalDetailCreateOrConnectWithoutUserInput
    upsert?: PersonalDetailUpsertWithoutUserInput
    disconnect?: PersonalDetailWhereInput | boolean
    delete?: PersonalDetailWhereInput | boolean
    connect?: PersonalDetailWhereUniqueInput
    update?: XOR<XOR<PersonalDetailUpdateToOneWithWhereWithoutUserInput, PersonalDetailUpdateWithoutUserInput>, PersonalDetailUncheckedUpdateWithoutUserInput>
  }

  export type ContactDetailUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ContactDetailCreateWithoutUserInput, ContactDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactDetailCreateOrConnectWithoutUserInput
    upsert?: ContactDetailUpsertWithoutUserInput
    disconnect?: ContactDetailWhereInput | boolean
    delete?: ContactDetailWhereInput | boolean
    connect?: ContactDetailWhereUniqueInput
    update?: XOR<XOR<ContactDetailUpdateToOneWithWhereWithoutUserInput, ContactDetailUpdateWithoutUserInput>, ContactDetailUncheckedUpdateWithoutUserInput>
  }

  export type BankDetailUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BankDetailCreateWithoutUserInput, BankDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: BankDetailCreateOrConnectWithoutUserInput
    upsert?: BankDetailUpsertWithoutUserInput
    disconnect?: BankDetailWhereInput | boolean
    delete?: BankDetailWhereInput | boolean
    connect?: BankDetailWhereUniqueInput
    update?: XOR<XOR<BankDetailUpdateToOneWithWhereWithoutUserInput, BankDetailUpdateWithoutUserInput>, BankDetailUncheckedUpdateWithoutUserInput>
  }

  export type AddressDetailUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressDetailCreateWithoutUserInput, AddressDetailUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressDetailCreateOrConnectWithoutUserInput
    upsert?: AddressDetailUpsertWithoutUserInput
    disconnect?: AddressDetailWhereInput | boolean
    delete?: AddressDetailWhereInput | boolean
    connect?: AddressDetailWhereUniqueInput
    update?: XOR<XOR<AddressDetailUpdateToOneWithWhereWithoutUserInput, AddressDetailUpdateWithoutUserInput>, AddressDetailUncheckedUpdateWithoutUserInput>
  }

  export type Form16DataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Form16DataCreateWithoutUserInput, Form16DataUncheckedCreateWithoutUserInput> | Form16DataCreateWithoutUserInput[] | Form16DataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Form16DataCreateOrConnectWithoutUserInput | Form16DataCreateOrConnectWithoutUserInput[]
    upsert?: Form16DataUpsertWithWhereUniqueWithoutUserInput | Form16DataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Form16DataCreateManyUserInputEnvelope
    set?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    disconnect?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    delete?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    connect?: Form16DataWhereUniqueInput | Form16DataWhereUniqueInput[]
    update?: Form16DataUpdateWithWhereUniqueWithoutUserInput | Form16DataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Form16DataUpdateManyWithWhereWithoutUserInput | Form16DataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Form16DataScalarWhereInput | Form16DataScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type CapitalGainUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CapitalGainCreateWithoutUserInput, CapitalGainUncheckedCreateWithoutUserInput> | CapitalGainCreateWithoutUserInput[] | CapitalGainUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CapitalGainCreateOrConnectWithoutUserInput | CapitalGainCreateOrConnectWithoutUserInput[]
    upsert?: CapitalGainUpsertWithWhereUniqueWithoutUserInput | CapitalGainUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CapitalGainCreateManyUserInputEnvelope
    set?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    disconnect?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    delete?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    connect?: CapitalGainWhereUniqueInput | CapitalGainWhereUniqueInput[]
    update?: CapitalGainUpdateWithWhereUniqueWithoutUserInput | CapitalGainUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CapitalGainUpdateManyWithWhereWithoutUserInput | CapitalGainUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CapitalGainScalarWhereInput | CapitalGainScalarWhereInput[]
  }

  export type BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BusinessIncomeCreateWithoutUserInput, BusinessIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutUserInput
    upsert?: BusinessIncomeUpsertWithoutUserInput
    disconnect?: BusinessIncomeWhereInput | boolean
    delete?: BusinessIncomeWhereInput | boolean
    connect?: BusinessIncomeWhereUniqueInput
    update?: XOR<XOR<BusinessIncomeUpdateToOneWithWhereWithoutUserInput, BusinessIncomeUpdateWithoutUserInput>, BusinessIncomeUncheckedUpdateWithoutUserInput>
  }

  export type ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfessionalIncomeCreateWithoutUserInput, ProfessionalIncomeUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfessionalIncomeCreateOrConnectWithoutUserInput
    upsert?: ProfessionalIncomeUpsertWithoutUserInput
    disconnect?: ProfessionalIncomeWhereInput | boolean
    delete?: ProfessionalIncomeWhereInput | boolean
    connect?: ProfessionalIncomeWhereUniqueInput
    update?: XOR<XOR<ProfessionalIncomeUpdateToOneWithWhereWithoutUserInput, ProfessionalIncomeUpdateWithoutUserInput>, ProfessionalIncomeUncheckedUpdateWithoutUserInput>
  }

  export type CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CryptoIncomeCreateWithoutUserInput, CryptoIncomeUncheckedCreateWithoutUserInput> | CryptoIncomeCreateWithoutUserInput[] | CryptoIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoIncomeCreateOrConnectWithoutUserInput | CryptoIncomeCreateOrConnectWithoutUserInput[]
    upsert?: CryptoIncomeUpsertWithWhereUniqueWithoutUserInput | CryptoIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CryptoIncomeCreateManyUserInputEnvelope
    set?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    disconnect?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    delete?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    connect?: CryptoIncomeWhereUniqueInput | CryptoIncomeWhereUniqueInput[]
    update?: CryptoIncomeUpdateWithWhereUniqueWithoutUserInput | CryptoIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CryptoIncomeUpdateManyWithWhereWithoutUserInput | CryptoIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CryptoIncomeScalarWhereInput | CryptoIncomeScalarWhereInput[]
  }

  export type TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TaxSavingInvestmentCreateWithoutUserInput, TaxSavingInvestmentUncheckedCreateWithoutUserInput>
    connectOrCreate?: TaxSavingInvestmentCreateOrConnectWithoutUserInput
    upsert?: TaxSavingInvestmentUpsertWithoutUserInput
    disconnect?: TaxSavingInvestmentWhereInput | boolean
    delete?: TaxSavingInvestmentWhereInput | boolean
    connect?: TaxSavingInvestmentWhereUniqueInput
    update?: XOR<XOR<TaxSavingInvestmentUpdateToOneWithWhereWithoutUserInput, TaxSavingInvestmentUpdateWithoutUserInput>, TaxSavingInvestmentUncheckedUpdateWithoutUserInput>
  }

  export type DonationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput> | DonationCreateWithoutUserInput[] | DonationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutUserInput | DonationCreateOrConnectWithoutUserInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutUserInput | DonationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DonationCreateManyUserInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutUserInput | DonationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutUserInput | DonationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicalInsuranceCreateWithoutUserInput, MedicalInsuranceUncheckedCreateWithoutUserInput> | MedicalInsuranceCreateWithoutUserInput[] | MedicalInsuranceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicalInsuranceCreateOrConnectWithoutUserInput | MedicalInsuranceCreateOrConnectWithoutUserInput[]
    upsert?: MedicalInsuranceUpsertWithWhereUniqueWithoutUserInput | MedicalInsuranceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicalInsuranceCreateManyUserInputEnvelope
    set?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    disconnect?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    delete?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    connect?: MedicalInsuranceWhereUniqueInput | MedicalInsuranceWhereUniqueInput[]
    update?: MedicalInsuranceUpdateWithWhereUniqueWithoutUserInput | MedicalInsuranceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicalInsuranceUpdateManyWithWhereWithoutUserInput | MedicalInsuranceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicalInsuranceScalarWhereInput | MedicalInsuranceScalarWhereInput[]
  }

  export type TaxPaidUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaxPaidCreateWithoutUserInput, TaxPaidUncheckedCreateWithoutUserInput> | TaxPaidCreateWithoutUserInput[] | TaxPaidUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxPaidCreateOrConnectWithoutUserInput | TaxPaidCreateOrConnectWithoutUserInput[]
    upsert?: TaxPaidUpsertWithWhereUniqueWithoutUserInput | TaxPaidUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaxPaidCreateManyUserInputEnvelope
    set?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    disconnect?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    delete?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    connect?: TaxPaidWhereUniqueInput | TaxPaidWhereUniqueInput[]
    update?: TaxPaidUpdateWithWhereUniqueWithoutUserInput | TaxPaidUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaxPaidUpdateManyWithWhereWithoutUserInput | TaxPaidUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaxPaidScalarWhereInput | TaxPaidScalarWhereInput[]
  }

  export type InterestIncomeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterestIncomeCreateWithoutUserInput, InterestIncomeUncheckedCreateWithoutUserInput> | InterestIncomeCreateWithoutUserInput[] | InterestIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterestIncomeCreateOrConnectWithoutUserInput | InterestIncomeCreateOrConnectWithoutUserInput[]
    upsert?: InterestIncomeUpsertWithWhereUniqueWithoutUserInput | InterestIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterestIncomeCreateManyUserInputEnvelope
    set?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    disconnect?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    delete?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    connect?: InterestIncomeWhereUniqueInput | InterestIncomeWhereUniqueInput[]
    update?: InterestIncomeUpdateWithWhereUniqueWithoutUserInput | InterestIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterestIncomeUpdateManyWithWhereWithoutUserInput | InterestIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterestIncomeScalarWhereInput | InterestIncomeScalarWhereInput[]
  }

  export type DividendIncomeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DividendIncomeCreateWithoutUserInput, DividendIncomeUncheckedCreateWithoutUserInput> | DividendIncomeCreateWithoutUserInput[] | DividendIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DividendIncomeCreateOrConnectWithoutUserInput | DividendIncomeCreateOrConnectWithoutUserInput[]
    upsert?: DividendIncomeUpsertWithWhereUniqueWithoutUserInput | DividendIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DividendIncomeCreateManyUserInputEnvelope
    set?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    disconnect?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    delete?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    connect?: DividendIncomeWhereUniqueInput | DividendIncomeWhereUniqueInput[]
    update?: DividendIncomeUpdateWithWhereUniqueWithoutUserInput | DividendIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DividendIncomeUpdateManyWithWhereWithoutUserInput | DividendIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DividendIncomeScalarWhereInput | DividendIncomeScalarWhereInput[]
  }

  export type AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgriculturalIncomeCreateWithoutUserInput, AgriculturalIncomeUncheckedCreateWithoutUserInput> | AgriculturalIncomeCreateWithoutUserInput[] | AgriculturalIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgriculturalIncomeCreateOrConnectWithoutUserInput | AgriculturalIncomeCreateOrConnectWithoutUserInput[]
    upsert?: AgriculturalIncomeUpsertWithWhereUniqueWithoutUserInput | AgriculturalIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgriculturalIncomeCreateManyUserInputEnvelope
    set?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    disconnect?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    delete?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    connect?: AgriculturalIncomeWhereUniqueInput | AgriculturalIncomeWhereUniqueInput[]
    update?: AgriculturalIncomeUpdateWithWhereUniqueWithoutUserInput | AgriculturalIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgriculturalIncomeUpdateManyWithWhereWithoutUserInput | AgriculturalIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgriculturalIncomeScalarWhereInput | AgriculturalIncomeScalarWhereInput[]
  }

  export type ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExemptIncomeCreateWithoutUserInput, ExemptIncomeUncheckedCreateWithoutUserInput> | ExemptIncomeCreateWithoutUserInput[] | ExemptIncomeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExemptIncomeCreateOrConnectWithoutUserInput | ExemptIncomeCreateOrConnectWithoutUserInput[]
    upsert?: ExemptIncomeUpsertWithWhereUniqueWithoutUserInput | ExemptIncomeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExemptIncomeCreateManyUserInputEnvelope
    set?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    disconnect?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    delete?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    connect?: ExemptIncomeWhereUniqueInput | ExemptIncomeWhereUniqueInput[]
    update?: ExemptIncomeUpdateWithWhereUniqueWithoutUserInput | ExemptIncomeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExemptIncomeUpdateManyWithWhereWithoutUserInput | ExemptIncomeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExemptIncomeScalarWhereInput | ExemptIncomeScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type ITRGenerationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ITRGenerationCreateWithoutUserInput, ITRGenerationUncheckedCreateWithoutUserInput> | ITRGenerationCreateWithoutUserInput[] | ITRGenerationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ITRGenerationCreateOrConnectWithoutUserInput | ITRGenerationCreateOrConnectWithoutUserInput[]
    upsert?: ITRGenerationUpsertWithWhereUniqueWithoutUserInput | ITRGenerationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ITRGenerationCreateManyUserInputEnvelope
    set?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    disconnect?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    delete?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    connect?: ITRGenerationWhereUniqueInput | ITRGenerationWhereUniqueInput[]
    update?: ITRGenerationUpdateWithWhereUniqueWithoutUserInput | ITRGenerationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ITRGenerationUpdateManyWithWhereWithoutUserInput | ITRGenerationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ITRGenerationScalarWhereInput | ITRGenerationScalarWhereInput[]
  }

  export type TaxSummaryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaxSummaryCreateWithoutUserInput, TaxSummaryUncheckedCreateWithoutUserInput> | TaxSummaryCreateWithoutUserInput[] | TaxSummaryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaxSummaryCreateOrConnectWithoutUserInput | TaxSummaryCreateOrConnectWithoutUserInput[]
    upsert?: TaxSummaryUpsertWithWhereUniqueWithoutUserInput | TaxSummaryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaxSummaryCreateManyUserInputEnvelope
    set?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    disconnect?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    delete?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    connect?: TaxSummaryWhereUniqueInput | TaxSummaryWhereUniqueInput[]
    update?: TaxSummaryUpdateWithWhereUniqueWithoutUserInput | TaxSummaryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaxSummaryUpdateManyWithWhereWithoutUserInput | TaxSummaryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaxSummaryScalarWhereInput | TaxSummaryScalarWhereInput[]
  }

  export type ProfitLossUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfitLossCreateWithoutUserInput, ProfitLossUncheckedCreateWithoutUserInput> | ProfitLossCreateWithoutUserInput[] | ProfitLossUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutUserInput | ProfitLossCreateOrConnectWithoutUserInput[]
    upsert?: ProfitLossUpsertWithWhereUniqueWithoutUserInput | ProfitLossUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfitLossCreateManyUserInputEnvelope
    set?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    disconnect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    delete?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    update?: ProfitLossUpdateWithWhereUniqueWithoutUserInput | ProfitLossUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfitLossUpdateManyWithWhereWithoutUserInput | ProfitLossUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfitLossScalarWhereInput | ProfitLossScalarWhereInput[]
  }

  export type BalanceSheetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BalanceSheetCreateWithoutUserInput, BalanceSheetUncheckedCreateWithoutUserInput> | BalanceSheetCreateWithoutUserInput[] | BalanceSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutUserInput | BalanceSheetCreateOrConnectWithoutUserInput[]
    upsert?: BalanceSheetUpsertWithWhereUniqueWithoutUserInput | BalanceSheetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BalanceSheetCreateManyUserInputEnvelope
    set?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    disconnect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    delete?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    update?: BalanceSheetUpdateWithWhereUniqueWithoutUserInput | BalanceSheetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BalanceSheetUpdateManyWithWhereWithoutUserInput | BalanceSheetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BalanceSheetScalarWhereInput | BalanceSheetScalarWhereInput[]
  }

  export type DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DepreciationEntryCreateWithoutUserInput, DepreciationEntryUncheckedCreateWithoutUserInput> | DepreciationEntryCreateWithoutUserInput[] | DepreciationEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutUserInput | DepreciationEntryCreateOrConnectWithoutUserInput[]
    upsert?: DepreciationEntryUpsertWithWhereUniqueWithoutUserInput | DepreciationEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DepreciationEntryCreateManyUserInputEnvelope
    set?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    disconnect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    delete?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    update?: DepreciationEntryUpdateWithWhereUniqueWithoutUserInput | DepreciationEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DepreciationEntryUpdateManyWithWhereWithoutUserInput | DepreciationEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DepreciationEntryScalarWhereInput | DepreciationEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus | null
  }

  export type UserUpdateOneRequiredWithoutPersonalDetailsNestedInput = {
    create?: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalDetailsInput
    upsert?: UserUpsertWithoutPersonalDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalDetailsInput, UserUpdateWithoutPersonalDetailsInput>, UserUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type UserCreateNestedOneWithoutContactDetailsInput = {
    create?: XOR<UserCreateWithoutContactDetailsInput, UserUncheckedCreateWithoutContactDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutContactDetailsNestedInput = {
    create?: XOR<UserCreateWithoutContactDetailsInput, UserUncheckedCreateWithoutContactDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactDetailsInput
    upsert?: UserUpsertWithoutContactDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactDetailsInput, UserUpdateWithoutContactDetailsInput>, UserUncheckedUpdateWithoutContactDetailsInput>
  }

  export type UserCreateNestedOneWithoutAddressDetailsInput = {
    create?: XOR<UserCreateWithoutAddressDetailsInput, UserUncheckedCreateWithoutAddressDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressDetailsNestedInput = {
    create?: XOR<UserCreateWithoutAddressDetailsInput, UserUncheckedCreateWithoutAddressDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressDetailsInput
    upsert?: UserUpsertWithoutAddressDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressDetailsInput, UserUpdateWithoutAddressDetailsInput>, UserUncheckedUpdateWithoutAddressDetailsInput>
  }

  export type UserCreateNestedOneWithoutBankDetailsInput = {
    create?: XOR<UserCreateWithoutBankDetailsInput, UserUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBankDetailsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBankDetailsNestedInput = {
    create?: XOR<UserCreateWithoutBankDetailsInput, UserUncheckedCreateWithoutBankDetailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBankDetailsInput
    upsert?: UserUpsertWithoutBankDetailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBankDetailsInput, UserUpdateWithoutBankDetailsInput>, UserUncheckedUpdateWithoutBankDetailsInput>
  }

  export type UserCreateNestedOneWithoutForm16DataInput = {
    create?: XOR<UserCreateWithoutForm16DataInput, UserUncheckedCreateWithoutForm16DataInput>
    connectOrCreate?: UserCreateOrConnectWithoutForm16DataInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutForm16DataNestedInput = {
    create?: XOR<UserCreateWithoutForm16DataInput, UserUncheckedCreateWithoutForm16DataInput>
    connectOrCreate?: UserCreateOrConnectWithoutForm16DataInput
    upsert?: UserUpsertWithoutForm16DataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForm16DataInput, UserUpdateWithoutForm16DataInput>, UserUncheckedUpdateWithoutForm16DataInput>
  }

  export type UserCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    upsert?: UserUpsertWithoutPropertiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertiesInput, UserUpdateWithoutPropertiesInput>, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserCreateNestedOneWithoutCapitalGainsInput = {
    create?: XOR<UserCreateWithoutCapitalGainsInput, UserUncheckedCreateWithoutCapitalGainsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCapitalGainsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCapitalGainsNestedInput = {
    create?: XOR<UserCreateWithoutCapitalGainsInput, UserUncheckedCreateWithoutCapitalGainsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCapitalGainsInput
    upsert?: UserUpsertWithoutCapitalGainsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCapitalGainsInput, UserUpdateWithoutCapitalGainsInput>, UserUncheckedUpdateWithoutCapitalGainsInput>
  }

  export type UserCreateNestedOneWithoutInterestIncomeInput = {
    create?: XOR<UserCreateWithoutInterestIncomeInput, UserUncheckedCreateWithoutInterestIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInterestIncomeNestedInput = {
    create?: XOR<UserCreateWithoutInterestIncomeInput, UserUncheckedCreateWithoutInterestIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestIncomeInput
    upsert?: UserUpsertWithoutInterestIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterestIncomeInput, UserUpdateWithoutInterestIncomeInput>, UserUncheckedUpdateWithoutInterestIncomeInput>
  }

  export type UserCreateNestedOneWithoutDividendIncomeInput = {
    create?: XOR<UserCreateWithoutDividendIncomeInput, UserUncheckedCreateWithoutDividendIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutDividendIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDividendIncomeNestedInput = {
    create?: XOR<UserCreateWithoutDividendIncomeInput, UserUncheckedCreateWithoutDividendIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutDividendIncomeInput
    upsert?: UserUpsertWithoutDividendIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDividendIncomeInput, UserUpdateWithoutDividendIncomeInput>, UserUncheckedUpdateWithoutDividendIncomeInput>
  }

  export type UserCreateNestedOneWithoutBusinessIncomeInput = {
    create?: XOR<UserCreateWithoutBusinessIncomeInput, UserUncheckedCreateWithoutBusinessIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type ProfitLossCreateNestedManyWithoutBusinessIncomeInput = {
    create?: XOR<ProfitLossCreateWithoutBusinessIncomeInput, ProfitLossUncheckedCreateWithoutBusinessIncomeInput> | ProfitLossCreateWithoutBusinessIncomeInput[] | ProfitLossUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutBusinessIncomeInput | ProfitLossCreateOrConnectWithoutBusinessIncomeInput[]
    createMany?: ProfitLossCreateManyBusinessIncomeInputEnvelope
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
  }

  export type BalanceSheetCreateNestedManyWithoutBusinessIncomeInput = {
    create?: XOR<BalanceSheetCreateWithoutBusinessIncomeInput, BalanceSheetUncheckedCreateWithoutBusinessIncomeInput> | BalanceSheetCreateWithoutBusinessIncomeInput[] | BalanceSheetUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutBusinessIncomeInput | BalanceSheetCreateOrConnectWithoutBusinessIncomeInput[]
    createMany?: BalanceSheetCreateManyBusinessIncomeInputEnvelope
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
  }

  export type DepreciationEntryCreateNestedManyWithoutBusinessIncomeInput = {
    create?: XOR<DepreciationEntryCreateWithoutBusinessIncomeInput, DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput> | DepreciationEntryCreateWithoutBusinessIncomeInput[] | DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput | DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput[]
    createMany?: DepreciationEntryCreateManyBusinessIncomeInputEnvelope
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
  }

  export type ProfitLossUncheckedCreateNestedManyWithoutBusinessIncomeInput = {
    create?: XOR<ProfitLossCreateWithoutBusinessIncomeInput, ProfitLossUncheckedCreateWithoutBusinessIncomeInput> | ProfitLossCreateWithoutBusinessIncomeInput[] | ProfitLossUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutBusinessIncomeInput | ProfitLossCreateOrConnectWithoutBusinessIncomeInput[]
    createMany?: ProfitLossCreateManyBusinessIncomeInputEnvelope
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
  }

  export type BalanceSheetUncheckedCreateNestedManyWithoutBusinessIncomeInput = {
    create?: XOR<BalanceSheetCreateWithoutBusinessIncomeInput, BalanceSheetUncheckedCreateWithoutBusinessIncomeInput> | BalanceSheetCreateWithoutBusinessIncomeInput[] | BalanceSheetUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutBusinessIncomeInput | BalanceSheetCreateOrConnectWithoutBusinessIncomeInput[]
    createMany?: BalanceSheetCreateManyBusinessIncomeInputEnvelope
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
  }

  export type DepreciationEntryUncheckedCreateNestedManyWithoutBusinessIncomeInput = {
    create?: XOR<DepreciationEntryCreateWithoutBusinessIncomeInput, DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput> | DepreciationEntryCreateWithoutBusinessIncomeInput[] | DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput | DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput[]
    createMany?: DepreciationEntryCreateManyBusinessIncomeInputEnvelope
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBusinessIncomeNestedInput = {
    create?: XOR<UserCreateWithoutBusinessIncomeInput, UserUncheckedCreateWithoutBusinessIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessIncomeInput
    upsert?: UserUpsertWithoutBusinessIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBusinessIncomeInput, UserUpdateWithoutBusinessIncomeInput>, UserUncheckedUpdateWithoutBusinessIncomeInput>
  }

  export type ProfitLossUpdateManyWithoutBusinessIncomeNestedInput = {
    create?: XOR<ProfitLossCreateWithoutBusinessIncomeInput, ProfitLossUncheckedCreateWithoutBusinessIncomeInput> | ProfitLossCreateWithoutBusinessIncomeInput[] | ProfitLossUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutBusinessIncomeInput | ProfitLossCreateOrConnectWithoutBusinessIncomeInput[]
    upsert?: ProfitLossUpsertWithWhereUniqueWithoutBusinessIncomeInput | ProfitLossUpsertWithWhereUniqueWithoutBusinessIncomeInput[]
    createMany?: ProfitLossCreateManyBusinessIncomeInputEnvelope
    set?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    disconnect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    delete?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    update?: ProfitLossUpdateWithWhereUniqueWithoutBusinessIncomeInput | ProfitLossUpdateWithWhereUniqueWithoutBusinessIncomeInput[]
    updateMany?: ProfitLossUpdateManyWithWhereWithoutBusinessIncomeInput | ProfitLossUpdateManyWithWhereWithoutBusinessIncomeInput[]
    deleteMany?: ProfitLossScalarWhereInput | ProfitLossScalarWhereInput[]
  }

  export type BalanceSheetUpdateManyWithoutBusinessIncomeNestedInput = {
    create?: XOR<BalanceSheetCreateWithoutBusinessIncomeInput, BalanceSheetUncheckedCreateWithoutBusinessIncomeInput> | BalanceSheetCreateWithoutBusinessIncomeInput[] | BalanceSheetUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutBusinessIncomeInput | BalanceSheetCreateOrConnectWithoutBusinessIncomeInput[]
    upsert?: BalanceSheetUpsertWithWhereUniqueWithoutBusinessIncomeInput | BalanceSheetUpsertWithWhereUniqueWithoutBusinessIncomeInput[]
    createMany?: BalanceSheetCreateManyBusinessIncomeInputEnvelope
    set?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    disconnect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    delete?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    update?: BalanceSheetUpdateWithWhereUniqueWithoutBusinessIncomeInput | BalanceSheetUpdateWithWhereUniqueWithoutBusinessIncomeInput[]
    updateMany?: BalanceSheetUpdateManyWithWhereWithoutBusinessIncomeInput | BalanceSheetUpdateManyWithWhereWithoutBusinessIncomeInput[]
    deleteMany?: BalanceSheetScalarWhereInput | BalanceSheetScalarWhereInput[]
  }

  export type DepreciationEntryUpdateManyWithoutBusinessIncomeNestedInput = {
    create?: XOR<DepreciationEntryCreateWithoutBusinessIncomeInput, DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput> | DepreciationEntryCreateWithoutBusinessIncomeInput[] | DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput | DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput[]
    upsert?: DepreciationEntryUpsertWithWhereUniqueWithoutBusinessIncomeInput | DepreciationEntryUpsertWithWhereUniqueWithoutBusinessIncomeInput[]
    createMany?: DepreciationEntryCreateManyBusinessIncomeInputEnvelope
    set?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    disconnect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    delete?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    update?: DepreciationEntryUpdateWithWhereUniqueWithoutBusinessIncomeInput | DepreciationEntryUpdateWithWhereUniqueWithoutBusinessIncomeInput[]
    updateMany?: DepreciationEntryUpdateManyWithWhereWithoutBusinessIncomeInput | DepreciationEntryUpdateManyWithWhereWithoutBusinessIncomeInput[]
    deleteMany?: DepreciationEntryScalarWhereInput | DepreciationEntryScalarWhereInput[]
  }

  export type ProfitLossUncheckedUpdateManyWithoutBusinessIncomeNestedInput = {
    create?: XOR<ProfitLossCreateWithoutBusinessIncomeInput, ProfitLossUncheckedCreateWithoutBusinessIncomeInput> | ProfitLossCreateWithoutBusinessIncomeInput[] | ProfitLossUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: ProfitLossCreateOrConnectWithoutBusinessIncomeInput | ProfitLossCreateOrConnectWithoutBusinessIncomeInput[]
    upsert?: ProfitLossUpsertWithWhereUniqueWithoutBusinessIncomeInput | ProfitLossUpsertWithWhereUniqueWithoutBusinessIncomeInput[]
    createMany?: ProfitLossCreateManyBusinessIncomeInputEnvelope
    set?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    disconnect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    delete?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    connect?: ProfitLossWhereUniqueInput | ProfitLossWhereUniqueInput[]
    update?: ProfitLossUpdateWithWhereUniqueWithoutBusinessIncomeInput | ProfitLossUpdateWithWhereUniqueWithoutBusinessIncomeInput[]
    updateMany?: ProfitLossUpdateManyWithWhereWithoutBusinessIncomeInput | ProfitLossUpdateManyWithWhereWithoutBusinessIncomeInput[]
    deleteMany?: ProfitLossScalarWhereInput | ProfitLossScalarWhereInput[]
  }

  export type BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeNestedInput = {
    create?: XOR<BalanceSheetCreateWithoutBusinessIncomeInput, BalanceSheetUncheckedCreateWithoutBusinessIncomeInput> | BalanceSheetCreateWithoutBusinessIncomeInput[] | BalanceSheetUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: BalanceSheetCreateOrConnectWithoutBusinessIncomeInput | BalanceSheetCreateOrConnectWithoutBusinessIncomeInput[]
    upsert?: BalanceSheetUpsertWithWhereUniqueWithoutBusinessIncomeInput | BalanceSheetUpsertWithWhereUniqueWithoutBusinessIncomeInput[]
    createMany?: BalanceSheetCreateManyBusinessIncomeInputEnvelope
    set?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    disconnect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    delete?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    connect?: BalanceSheetWhereUniqueInput | BalanceSheetWhereUniqueInput[]
    update?: BalanceSheetUpdateWithWhereUniqueWithoutBusinessIncomeInput | BalanceSheetUpdateWithWhereUniqueWithoutBusinessIncomeInput[]
    updateMany?: BalanceSheetUpdateManyWithWhereWithoutBusinessIncomeInput | BalanceSheetUpdateManyWithWhereWithoutBusinessIncomeInput[]
    deleteMany?: BalanceSheetScalarWhereInput | BalanceSheetScalarWhereInput[]
  }

  export type DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeNestedInput = {
    create?: XOR<DepreciationEntryCreateWithoutBusinessIncomeInput, DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput> | DepreciationEntryCreateWithoutBusinessIncomeInput[] | DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput[]
    connectOrCreate?: DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput | DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput[]
    upsert?: DepreciationEntryUpsertWithWhereUniqueWithoutBusinessIncomeInput | DepreciationEntryUpsertWithWhereUniqueWithoutBusinessIncomeInput[]
    createMany?: DepreciationEntryCreateManyBusinessIncomeInputEnvelope
    set?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    disconnect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    delete?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    connect?: DepreciationEntryWhereUniqueInput | DepreciationEntryWhereUniqueInput[]
    update?: DepreciationEntryUpdateWithWhereUniqueWithoutBusinessIncomeInput | DepreciationEntryUpdateWithWhereUniqueWithoutBusinessIncomeInput[]
    updateMany?: DepreciationEntryUpdateManyWithWhereWithoutBusinessIncomeInput | DepreciationEntryUpdateManyWithWhereWithoutBusinessIncomeInput[]
    deleteMany?: DepreciationEntryScalarWhereInput | DepreciationEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfessionalIncomeInput = {
    create?: XOR<UserCreateWithoutProfessionalIncomeInput, UserUncheckedCreateWithoutProfessionalIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfessionalIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfessionalIncomeNestedInput = {
    create?: XOR<UserCreateWithoutProfessionalIncomeInput, UserUncheckedCreateWithoutProfessionalIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfessionalIncomeInput
    upsert?: UserUpsertWithoutProfessionalIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfessionalIncomeInput, UserUpdateWithoutProfessionalIncomeInput>, UserUncheckedUpdateWithoutProfessionalIncomeInput>
  }

  export type UserCreateNestedOneWithoutProfitLossInput = {
    create?: XOR<UserCreateWithoutProfitLossInput, UserUncheckedCreateWithoutProfitLossInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfitLossInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessIncomeCreateNestedOneWithoutProfitLossInput = {
    create?: XOR<BusinessIncomeCreateWithoutProfitLossInput, BusinessIncomeUncheckedCreateWithoutProfitLossInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutProfitLossInput
    connect?: BusinessIncomeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfitLossNestedInput = {
    create?: XOR<UserCreateWithoutProfitLossInput, UserUncheckedCreateWithoutProfitLossInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfitLossInput
    upsert?: UserUpsertWithoutProfitLossInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfitLossInput, UserUpdateWithoutProfitLossInput>, UserUncheckedUpdateWithoutProfitLossInput>
  }

  export type BusinessIncomeUpdateOneWithoutProfitLossNestedInput = {
    create?: XOR<BusinessIncomeCreateWithoutProfitLossInput, BusinessIncomeUncheckedCreateWithoutProfitLossInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutProfitLossInput
    upsert?: BusinessIncomeUpsertWithoutProfitLossInput
    disconnect?: BusinessIncomeWhereInput | boolean
    delete?: BusinessIncomeWhereInput | boolean
    connect?: BusinessIncomeWhereUniqueInput
    update?: XOR<XOR<BusinessIncomeUpdateToOneWithWhereWithoutProfitLossInput, BusinessIncomeUpdateWithoutProfitLossInput>, BusinessIncomeUncheckedUpdateWithoutProfitLossInput>
  }

  export type UserCreateNestedOneWithoutBalanceSheetsInput = {
    create?: XOR<UserCreateWithoutBalanceSheetsInput, UserUncheckedCreateWithoutBalanceSheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalanceSheetsInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessIncomeCreateNestedOneWithoutBalanceSheetInput = {
    create?: XOR<BusinessIncomeCreateWithoutBalanceSheetInput, BusinessIncomeUncheckedCreateWithoutBalanceSheetInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutBalanceSheetInput
    connect?: BusinessIncomeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBalanceSheetsNestedInput = {
    create?: XOR<UserCreateWithoutBalanceSheetsInput, UserUncheckedCreateWithoutBalanceSheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBalanceSheetsInput
    upsert?: UserUpsertWithoutBalanceSheetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBalanceSheetsInput, UserUpdateWithoutBalanceSheetsInput>, UserUncheckedUpdateWithoutBalanceSheetsInput>
  }

  export type BusinessIncomeUpdateOneWithoutBalanceSheetNestedInput = {
    create?: XOR<BusinessIncomeCreateWithoutBalanceSheetInput, BusinessIncomeUncheckedCreateWithoutBalanceSheetInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutBalanceSheetInput
    upsert?: BusinessIncomeUpsertWithoutBalanceSheetInput
    disconnect?: BusinessIncomeWhereInput | boolean
    delete?: BusinessIncomeWhereInput | boolean
    connect?: BusinessIncomeWhereUniqueInput
    update?: XOR<XOR<BusinessIncomeUpdateToOneWithWhereWithoutBalanceSheetInput, BusinessIncomeUpdateWithoutBalanceSheetInput>, BusinessIncomeUncheckedUpdateWithoutBalanceSheetInput>
  }

  export type UserCreateNestedOneWithoutDepreciationEntriesInput = {
    create?: XOR<UserCreateWithoutDepreciationEntriesInput, UserUncheckedCreateWithoutDepreciationEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepreciationEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessIncomeCreateNestedOneWithoutDepreciationInput = {
    create?: XOR<BusinessIncomeCreateWithoutDepreciationInput, BusinessIncomeUncheckedCreateWithoutDepreciationInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutDepreciationInput
    connect?: BusinessIncomeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDepreciationEntriesNestedInput = {
    create?: XOR<UserCreateWithoutDepreciationEntriesInput, UserUncheckedCreateWithoutDepreciationEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepreciationEntriesInput
    upsert?: UserUpsertWithoutDepreciationEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepreciationEntriesInput, UserUpdateWithoutDepreciationEntriesInput>, UserUncheckedUpdateWithoutDepreciationEntriesInput>
  }

  export type BusinessIncomeUpdateOneWithoutDepreciationNestedInput = {
    create?: XOR<BusinessIncomeCreateWithoutDepreciationInput, BusinessIncomeUncheckedCreateWithoutDepreciationInput>
    connectOrCreate?: BusinessIncomeCreateOrConnectWithoutDepreciationInput
    upsert?: BusinessIncomeUpsertWithoutDepreciationInput
    disconnect?: BusinessIncomeWhereInput | boolean
    delete?: BusinessIncomeWhereInput | boolean
    connect?: BusinessIncomeWhereUniqueInput
    update?: XOR<XOR<BusinessIncomeUpdateToOneWithWhereWithoutDepreciationInput, BusinessIncomeUpdateWithoutDepreciationInput>, BusinessIncomeUncheckedUpdateWithoutDepreciationInput>
  }

  export type UserCreateNestedOneWithoutCryptoIncomeInput = {
    create?: XOR<UserCreateWithoutCryptoIncomeInput, UserUncheckedCreateWithoutCryptoIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCryptoIncomeNestedInput = {
    create?: XOR<UserCreateWithoutCryptoIncomeInput, UserUncheckedCreateWithoutCryptoIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoIncomeInput
    upsert?: UserUpsertWithoutCryptoIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCryptoIncomeInput, UserUpdateWithoutCryptoIncomeInput>, UserUncheckedUpdateWithoutCryptoIncomeInput>
  }

  export type UserCreateNestedOneWithoutAgriculturalIncomeInput = {
    create?: XOR<UserCreateWithoutAgriculturalIncomeInput, UserUncheckedCreateWithoutAgriculturalIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgriculturalIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAgriculturalIncomeNestedInput = {
    create?: XOR<UserCreateWithoutAgriculturalIncomeInput, UserUncheckedCreateWithoutAgriculturalIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgriculturalIncomeInput
    upsert?: UserUpsertWithoutAgriculturalIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgriculturalIncomeInput, UserUpdateWithoutAgriculturalIncomeInput>, UserUncheckedUpdateWithoutAgriculturalIncomeInput>
  }

  export type UserCreateNestedOneWithoutExemptIncomeInput = {
    create?: XOR<UserCreateWithoutExemptIncomeInput, UserUncheckedCreateWithoutExemptIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutExemptIncomeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExemptIncomeNestedInput = {
    create?: XOR<UserCreateWithoutExemptIncomeInput, UserUncheckedCreateWithoutExemptIncomeInput>
    connectOrCreate?: UserCreateOrConnectWithoutExemptIncomeInput
    upsert?: UserUpsertWithoutExemptIncomeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExemptIncomeInput, UserUpdateWithoutExemptIncomeInput>, UserUncheckedUpdateWithoutExemptIncomeInput>
  }

  export type UserCreateNestedOneWithoutTaxSavingInvestmentsInput = {
    create?: XOR<UserCreateWithoutTaxSavingInvestmentsInput, UserUncheckedCreateWithoutTaxSavingInvestmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxSavingInvestmentsInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutTaxSavingInvestmentsNestedInput = {
    create?: XOR<UserCreateWithoutTaxSavingInvestmentsInput, UserUncheckedCreateWithoutTaxSavingInvestmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxSavingInvestmentsInput
    upsert?: UserUpsertWithoutTaxSavingInvestmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaxSavingInvestmentsInput, UserUpdateWithoutTaxSavingInvestmentsInput>, UserUncheckedUpdateWithoutTaxSavingInvestmentsInput>
  }

  export type UserCreateNestedOneWithoutDonationsInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDonationsInput
    upsert?: UserUpsertWithoutDonationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDonationsInput, UserUpdateWithoutDonationsInput>, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type UserCreateNestedOneWithoutMedicalInsuranceInput = {
    create?: XOR<UserCreateWithoutMedicalInsuranceInput, UserUncheckedCreateWithoutMedicalInsuranceInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicalInsuranceInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMedicalInsuranceNestedInput = {
    create?: XOR<UserCreateWithoutMedicalInsuranceInput, UserUncheckedCreateWithoutMedicalInsuranceInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicalInsuranceInput
    upsert?: UserUpsertWithoutMedicalInsuranceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicalInsuranceInput, UserUpdateWithoutMedicalInsuranceInput>, UserUncheckedUpdateWithoutMedicalInsuranceInput>
  }

  export type UserCreateNestedOneWithoutTaxPaidInput = {
    create?: XOR<UserCreateWithoutTaxPaidInput, UserUncheckedCreateWithoutTaxPaidInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxPaidInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTaxPaidNestedInput = {
    create?: XOR<UserCreateWithoutTaxPaidInput, UserUncheckedCreateWithoutTaxPaidInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxPaidInput
    upsert?: UserUpsertWithoutTaxPaidInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaxPaidInput, UserUpdateWithoutTaxPaidInput>, UserUncheckedUpdateWithoutTaxPaidInput>
  }

  export type WalletTransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletTransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutWalletInput | WalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutWalletInput | WalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type WalletUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    upsert?: WalletUpsertWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsInput, WalletUpdateWithoutTransactionsInput>, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutItrGenerationsInput = {
    create?: XOR<UserCreateWithoutItrGenerationsInput, UserUncheckedCreateWithoutItrGenerationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutItrGenerationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumITRTypeFieldUpdateOperationsInput = {
    set?: $Enums.ITRType
  }

  export type EnumITRStatusFieldUpdateOperationsInput = {
    set?: $Enums.ITRStatus
  }

  export type UserUpdateOneRequiredWithoutItrGenerationsNestedInput = {
    create?: XOR<UserCreateWithoutItrGenerationsInput, UserUncheckedCreateWithoutItrGenerationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutItrGenerationsInput
    upsert?: UserUpsertWithoutItrGenerationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutItrGenerationsInput, UserUpdateWithoutItrGenerationsInput>, UserUncheckedUpdateWithoutItrGenerationsInput>
  }

  export type UserCreateNestedOneWithoutTaxSummariesInput = {
    create?: XOR<UserCreateWithoutTaxSummariesInput, UserUncheckedCreateWithoutTaxSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxSummariesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTaxSummariesNestedInput = {
    create?: XOR<UserCreateWithoutTaxSummariesInput, UserUncheckedCreateWithoutTaxSummariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaxSummariesInput
    upsert?: UserUpsertWithoutTaxSummariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaxSummariesInput, UserUpdateWithoutTaxSummariesInput>, UserUncheckedUpdateWithoutTaxSummariesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumITRTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRType | EnumITRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumITRTypeFilter<$PrismaModel> | $Enums.ITRType
  }

  export type NestedEnumITRStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRStatus | EnumITRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumITRStatusFilter<$PrismaModel> | $Enums.ITRStatus
  }

  export type NestedEnumITRTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRType | EnumITRTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRType[] | ListEnumITRTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumITRTypeWithAggregatesFilter<$PrismaModel> | $Enums.ITRType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumITRTypeFilter<$PrismaModel>
    _max?: NestedEnumITRTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumITRStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ITRStatus | EnumITRStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ITRStatus[] | ListEnumITRStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumITRStatusWithAggregatesFilter<$PrismaModel> | $Enums.ITRStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumITRStatusFilter<$PrismaModel>
    _max?: NestedEnumITRStatusFilter<$PrismaModel>
  }

  export type PersonalDetailCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    gender?: $Enums.Gender | null
    maritalStatus?: $Enums.MaritalStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalDetailUncheckedCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    dob?: Date | string | null
    gender?: $Enums.Gender | null
    maritalStatus?: $Enums.MaritalStatus | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalDetailCreateOrConnectWithoutUserInput = {
    where: PersonalDetailWhereUniqueInput
    create: XOR<PersonalDetailCreateWithoutUserInput, PersonalDetailUncheckedCreateWithoutUserInput>
  }

  export type ContactDetailCreateWithoutUserInput = {
    id?: string
    email?: string | null
    phone?: string | null
    panNumber?: string | null
    aadharNumber?: string | null
    alternativeEmail?: string | null
    alternativePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactDetailUncheckedCreateWithoutUserInput = {
    id?: string
    email?: string | null
    phone?: string | null
    panNumber?: string | null
    aadharNumber?: string | null
    alternativeEmail?: string | null
    alternativePhone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactDetailCreateOrConnectWithoutUserInput = {
    where: ContactDetailWhereUniqueInput
    create: XOR<ContactDetailCreateWithoutUserInput, ContactDetailUncheckedCreateWithoutUserInput>
  }

  export type BankDetailCreateWithoutUserInput = {
    id?: string
    accountNumber?: string | null
    ifscCode?: string | null
    bankName?: string | null
    accountType?: string | null
    accountHolderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUncheckedCreateWithoutUserInput = {
    id?: string
    accountNumber?: string | null
    ifscCode?: string | null
    bankName?: string | null
    accountType?: string | null
    accountHolderName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailCreateOrConnectWithoutUserInput = {
    where: BankDetailWhereUniqueInput
    create: XOR<BankDetailCreateWithoutUserInput, BankDetailUncheckedCreateWithoutUserInput>
  }

  export type AddressDetailCreateWithoutUserInput = {
    id?: string
    flatNo?: string | null
    premiseName?: string | null
    road?: string | null
    area?: string | null
    pincode?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressDetailUncheckedCreateWithoutUserInput = {
    id?: string
    flatNo?: string | null
    premiseName?: string | null
    road?: string | null
    area?: string | null
    pincode?: string | null
    country?: string | null
    state?: string | null
    city?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressDetailCreateOrConnectWithoutUserInput = {
    where: AddressDetailWhereUniqueInput
    create: XOR<AddressDetailCreateWithoutUserInput, AddressDetailUncheckedCreateWithoutUserInput>
  }

  export type Form16DataCreateWithoutUserInput = {
    id?: string
    employerName?: string | null
    employerTAN?: string | null
    employerCategory?: string | null
    totalTax?: Decimal | DecimalJsLike | number | string | null
    grossSalary?: Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: Decimal | DecimalJsLike | number | string | null
    standardDeduction?: Decimal | DecimalJsLike | number | string | null
    professionalTax?: Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Form16DataUncheckedCreateWithoutUserInput = {
    id?: string
    employerName?: string | null
    employerTAN?: string | null
    employerCategory?: string | null
    totalTax?: Decimal | DecimalJsLike | number | string | null
    grossSalary?: Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: Decimal | DecimalJsLike | number | string | null
    standardDeduction?: Decimal | DecimalJsLike | number | string | null
    professionalTax?: Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Form16DataCreateOrConnectWithoutUserInput = {
    where: Form16DataWhereUniqueInput
    create: XOR<Form16DataCreateWithoutUserInput, Form16DataUncheckedCreateWithoutUserInput>
  }

  export type Form16DataCreateManyUserInputEnvelope = {
    data: Form16DataCreateManyUserInput | Form16DataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PropertyCreateWithoutUserInput = {
    id?: string
    propertyIndex?: string | null
    propertyType?: string | null
    netTaxableIncome?: Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: string
    propertyIndex?: string | null
    propertyType?: string | null
    netTaxableIncome?: Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateManyUserInputEnvelope = {
    data: PropertyCreateManyUserInput | PropertyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CapitalGainCreateWithoutUserInput = {
    id?: string
    assetType?: string | null
    assetSubType?: string | null
    dateOfSale?: Date | string | null
    dateOfPurchase?: Date | string | null
    description?: string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    transferExpenses?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    sttPaid?: boolean
    totalProfit?: Decimal | DecimalJsLike | number | string | null
    indexationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapitalGainUncheckedCreateWithoutUserInput = {
    id?: string
    assetType?: string | null
    assetSubType?: string | null
    dateOfSale?: Date | string | null
    dateOfPurchase?: Date | string | null
    description?: string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    transferExpenses?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    sttPaid?: boolean
    totalProfit?: Decimal | DecimalJsLike | number | string | null
    indexationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapitalGainCreateOrConnectWithoutUserInput = {
    where: CapitalGainWhereUniqueInput
    create: XOR<CapitalGainCreateWithoutUserInput, CapitalGainUncheckedCreateWithoutUserInput>
  }

  export type CapitalGainCreateManyUserInputEnvelope = {
    data: CapitalGainCreateManyUserInput | CapitalGainCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BusinessIncomeCreateWithoutUserInput = {
    id?: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profitLoss?: ProfitLossCreateNestedManyWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetUncheckedCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryUncheckedCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeCreateOrConnectWithoutUserInput = {
    where: BusinessIncomeWhereUniqueInput
    create: XOR<BusinessIncomeCreateWithoutUserInput, BusinessIncomeUncheckedCreateWithoutUserInput>
  }

  export type ProfessionalIncomeCreateWithoutUserInput = {
    id?: string
    professionType?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    section44ADA?: boolean
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfessionalIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    professionType?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    section44ADA?: boolean
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfessionalIncomeCreateOrConnectWithoutUserInput = {
    where: ProfessionalIncomeWhereUniqueInput
    create: XOR<ProfessionalIncomeCreateWithoutUserInput, ProfessionalIncomeUncheckedCreateWithoutUserInput>
  }

  export type CryptoIncomeCreateWithoutUserInput = {
    id?: string
    assetType?: string | null
    coinName?: string | null
    purchaseDate?: Date | string | null
    saleDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    exchangeName?: string | null
    transactionHash?: string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    assetType?: string | null
    coinName?: string | null
    purchaseDate?: Date | string | null
    saleDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    exchangeName?: string | null
    transactionHash?: string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoIncomeCreateOrConnectWithoutUserInput = {
    where: CryptoIncomeWhereUniqueInput
    create: XOR<CryptoIncomeCreateWithoutUserInput, CryptoIncomeUncheckedCreateWithoutUserInput>
  }

  export type CryptoIncomeCreateManyUserInputEnvelope = {
    data: CryptoIncomeCreateManyUserInput | CryptoIncomeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaxSavingInvestmentCreateWithoutUserInput = {
    id?: string
    section80C?: Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSavingInvestmentUncheckedCreateWithoutUserInput = {
    id?: string
    section80C?: Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSavingInvestmentCreateOrConnectWithoutUserInput = {
    where: TaxSavingInvestmentWhereUniqueInput
    create: XOR<TaxSavingInvestmentCreateWithoutUserInput, TaxSavingInvestmentUncheckedCreateWithoutUserInput>
  }

  export type DonationCreateWithoutUserInput = {
    id?: string
    organizationName?: string | null
    donationType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    receiptNumber?: string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationName?: string | null
    donationType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    receiptNumber?: string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateOrConnectWithoutUserInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationCreateManyUserInputEnvelope = {
    data: DonationCreateManyUserInput | DonationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MedicalInsuranceCreateWithoutUserInput = {
    id?: string
    policyType?: string | null
    insuredPersons?: string | null
    premiumPaid?: Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    policyNumber?: string | null
    insuranceCompany?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInsuranceUncheckedCreateWithoutUserInput = {
    id?: string
    policyType?: string | null
    insuredPersons?: string | null
    premiumPaid?: Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    policyNumber?: string | null
    insuranceCompany?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInsuranceCreateOrConnectWithoutUserInput = {
    where: MedicalInsuranceWhereUniqueInput
    create: XOR<MedicalInsuranceCreateWithoutUserInput, MedicalInsuranceUncheckedCreateWithoutUserInput>
  }

  export type MedicalInsuranceCreateManyUserInputEnvelope = {
    data: MedicalInsuranceCreateManyUserInput | MedicalInsuranceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaxPaidCreateWithoutUserInput = {
    id?: string
    taxType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    challanNumber?: string | null
    bankName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxPaidUncheckedCreateWithoutUserInput = {
    id?: string
    taxType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    challanNumber?: string | null
    bankName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxPaidCreateOrConnectWithoutUserInput = {
    where: TaxPaidWhereUniqueInput
    create: XOR<TaxPaidCreateWithoutUserInput, TaxPaidUncheckedCreateWithoutUserInput>
  }

  export type TaxPaidCreateManyUserInputEnvelope = {
    data: TaxPaidCreateManyUserInput | TaxPaidCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterestIncomeCreateWithoutUserInput = {
    id?: string
    sourceType?: string | null
    bankName?: string | null
    accountNumber?: string | null
    interestAmount?: Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: Decimal | DecimalJsLike | number | string | null
    financialYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    sourceType?: string | null
    bankName?: string | null
    accountNumber?: string | null
    interestAmount?: Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: Decimal | DecimalJsLike | number | string | null
    financialYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestIncomeCreateOrConnectWithoutUserInput = {
    where: InterestIncomeWhereUniqueInput
    create: XOR<InterestIncomeCreateWithoutUserInput, InterestIncomeUncheckedCreateWithoutUserInput>
  }

  export type InterestIncomeCreateManyUserInputEnvelope = {
    data: InterestIncomeCreateManyUserInput | InterestIncomeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DividendIncomeCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    taxDeducted?: Decimal | DecimalJsLike | number | string | null
    dateReceived?: Date | string | null
    shareQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DividendIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    taxDeducted?: Decimal | DecimalJsLike | number | string | null
    dateReceived?: Date | string | null
    shareQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DividendIncomeCreateOrConnectWithoutUserInput = {
    where: DividendIncomeWhereUniqueInput
    create: XOR<DividendIncomeCreateWithoutUserInput, DividendIncomeUncheckedCreateWithoutUserInput>
  }

  export type DividendIncomeCreateManyUserInputEnvelope = {
    data: DividendIncomeCreateManyUserInput | DividendIncomeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgriculturalIncomeCreateWithoutUserInput = {
    id?: string
    landArea?: Decimal | DecimalJsLike | number | string | null
    location?: string | null
    cropType?: string | null
    annualIncome?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    netIncome?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgriculturalIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    landArea?: Decimal | DecimalJsLike | number | string | null
    location?: string | null
    cropType?: string | null
    annualIncome?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    netIncome?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgriculturalIncomeCreateOrConnectWithoutUserInput = {
    where: AgriculturalIncomeWhereUniqueInput
    create: XOR<AgriculturalIncomeCreateWithoutUserInput, AgriculturalIncomeUncheckedCreateWithoutUserInput>
  }

  export type AgriculturalIncomeCreateManyUserInputEnvelope = {
    data: AgriculturalIncomeCreateManyUserInput | AgriculturalIncomeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExemptIncomeCreateWithoutUserInput = {
    id?: string
    incomeType?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExemptIncomeUncheckedCreateWithoutUserInput = {
    id?: string
    incomeType?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExemptIncomeCreateOrConnectWithoutUserInput = {
    where: ExemptIncomeWhereUniqueInput
    create: XOR<ExemptIncomeCreateWithoutUserInput, ExemptIncomeUncheckedCreateWithoutUserInput>
  }

  export type ExemptIncomeCreateManyUserInputEnvelope = {
    data: ExemptIncomeCreateManyUserInput | ExemptIncomeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type ITRGenerationCreateWithoutUserInput = {
    id?: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonNullValueInput | InputJsonValue
    status?: $Enums.ITRStatus
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
  }

  export type ITRGenerationUncheckedCreateWithoutUserInput = {
    id?: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonNullValueInput | InputJsonValue
    status?: $Enums.ITRStatus
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
  }

  export type ITRGenerationCreateOrConnectWithoutUserInput = {
    where: ITRGenerationWhereUniqueInput
    create: XOR<ITRGenerationCreateWithoutUserInput, ITRGenerationUncheckedCreateWithoutUserInput>
  }

  export type ITRGenerationCreateManyUserInputEnvelope = {
    data: ITRGenerationCreateManyUserInput | ITRGenerationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaxSummaryCreateWithoutUserInput = {
    id?: string
    assessmentYear?: string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    totalDeductions?: Decimal | DecimalJsLike | number | string | null
    taxableIncome?: Decimal | DecimalJsLike | number | string | null
    taxLiability?: Decimal | DecimalJsLike | number | string | null
    taxPaid?: Decimal | DecimalJsLike | number | string | null
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    filingStatus?: string | null
    filingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSummaryUncheckedCreateWithoutUserInput = {
    id?: string
    assessmentYear?: string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    totalDeductions?: Decimal | DecimalJsLike | number | string | null
    taxableIncome?: Decimal | DecimalJsLike | number | string | null
    taxLiability?: Decimal | DecimalJsLike | number | string | null
    taxPaid?: Decimal | DecimalJsLike | number | string | null
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    filingStatus?: string | null
    filingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxSummaryCreateOrConnectWithoutUserInput = {
    where: TaxSummaryWhereUniqueInput
    create: XOR<TaxSummaryCreateWithoutUserInput, TaxSummaryUncheckedCreateWithoutUserInput>
  }

  export type TaxSummaryCreateManyUserInputEnvelope = {
    data: TaxSummaryCreateManyUserInput | TaxSummaryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfitLossCreateWithoutUserInput = {
    id?: string
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessIncome?: BusinessIncomeCreateNestedOneWithoutProfitLossInput
  }

  export type ProfitLossUncheckedCreateWithoutUserInput = {
    id?: string
    businessIncomeId?: string | null
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfitLossCreateOrConnectWithoutUserInput = {
    where: ProfitLossWhereUniqueInput
    create: XOR<ProfitLossCreateWithoutUserInput, ProfitLossUncheckedCreateWithoutUserInput>
  }

  export type ProfitLossCreateManyUserInputEnvelope = {
    data: ProfitLossCreateManyUserInput | ProfitLossCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BalanceSheetCreateWithoutUserInput = {
    id?: string
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    businessIncome?: BusinessIncomeCreateNestedOneWithoutBalanceSheetInput
  }

  export type BalanceSheetUncheckedCreateWithoutUserInput = {
    id?: string
    businessIncomeId?: string | null
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceSheetCreateOrConnectWithoutUserInput = {
    where: BalanceSheetWhereUniqueInput
    create: XOR<BalanceSheetCreateWithoutUserInput, BalanceSheetUncheckedCreateWithoutUserInput>
  }

  export type BalanceSheetCreateManyUserInputEnvelope = {
    data: BalanceSheetCreateManyUserInput | BalanceSheetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepreciationEntryCreateWithoutUserInput = {
    id?: string
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessIncome?: BusinessIncomeCreateNestedOneWithoutDepreciationInput
  }

  export type DepreciationEntryUncheckedCreateWithoutUserInput = {
    id?: string
    businessIncomeId?: string | null
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationEntryCreateOrConnectWithoutUserInput = {
    where: DepreciationEntryWhereUniqueInput
    create: XOR<DepreciationEntryCreateWithoutUserInput, DepreciationEntryUncheckedCreateWithoutUserInput>
  }

  export type DepreciationEntryCreateManyUserInputEnvelope = {
    data: DepreciationEntryCreateManyUserInput | DepreciationEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PersonalDetailUpsertWithoutUserInput = {
    update: XOR<PersonalDetailUpdateWithoutUserInput, PersonalDetailUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalDetailCreateWithoutUserInput, PersonalDetailUncheckedCreateWithoutUserInput>
    where?: PersonalDetailWhereInput
  }

  export type PersonalDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: PersonalDetailWhereInput
    data: XOR<PersonalDetailUpdateWithoutUserInput, PersonalDetailUncheckedUpdateWithoutUserInput>
  }

  export type PersonalDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactDetailUpsertWithoutUserInput = {
    update: XOR<ContactDetailUpdateWithoutUserInput, ContactDetailUncheckedUpdateWithoutUserInput>
    create: XOR<ContactDetailCreateWithoutUserInput, ContactDetailUncheckedCreateWithoutUserInput>
    where?: ContactDetailWhereInput
  }

  export type ContactDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: ContactDetailWhereInput
    data: XOR<ContactDetailUpdateWithoutUserInput, ContactDetailUncheckedUpdateWithoutUserInput>
  }

  export type ContactDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    panNumber?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    alternativeEmail?: NullableStringFieldUpdateOperationsInput | string | null
    alternativePhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUpsertWithoutUserInput = {
    update: XOR<BankDetailUpdateWithoutUserInput, BankDetailUncheckedUpdateWithoutUserInput>
    create: XOR<BankDetailCreateWithoutUserInput, BankDetailUncheckedCreateWithoutUserInput>
    where?: BankDetailWhereInput
  }

  export type BankDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: BankDetailWhereInput
    data: XOR<BankDetailUpdateWithoutUserInput, BankDetailUncheckedUpdateWithoutUserInput>
  }

  export type BankDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ifscCode?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    accountHolderName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressDetailUpsertWithoutUserInput = {
    update: XOR<AddressDetailUpdateWithoutUserInput, AddressDetailUncheckedUpdateWithoutUserInput>
    create: XOR<AddressDetailCreateWithoutUserInput, AddressDetailUncheckedCreateWithoutUserInput>
    where?: AddressDetailWhereInput
  }

  export type AddressDetailUpdateToOneWithWhereWithoutUserInput = {
    where?: AddressDetailWhereInput
    data: XOR<AddressDetailUpdateWithoutUserInput, AddressDetailUncheckedUpdateWithoutUserInput>
  }

  export type AddressDetailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    premiseName?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressDetailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    flatNo?: NullableStringFieldUpdateOperationsInput | string | null
    premiseName?: NullableStringFieldUpdateOperationsInput | string | null
    road?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Form16DataUpsertWithWhereUniqueWithoutUserInput = {
    where: Form16DataWhereUniqueInput
    update: XOR<Form16DataUpdateWithoutUserInput, Form16DataUncheckedUpdateWithoutUserInput>
    create: XOR<Form16DataCreateWithoutUserInput, Form16DataUncheckedCreateWithoutUserInput>
  }

  export type Form16DataUpdateWithWhereUniqueWithoutUserInput = {
    where: Form16DataWhereUniqueInput
    data: XOR<Form16DataUpdateWithoutUserInput, Form16DataUncheckedUpdateWithoutUserInput>
  }

  export type Form16DataUpdateManyWithWhereWithoutUserInput = {
    where: Form16DataScalarWhereInput
    data: XOR<Form16DataUpdateManyMutationInput, Form16DataUncheckedUpdateManyWithoutUserInput>
  }

  export type Form16DataScalarWhereInput = {
    AND?: Form16DataScalarWhereInput | Form16DataScalarWhereInput[]
    OR?: Form16DataScalarWhereInput[]
    NOT?: Form16DataScalarWhereInput | Form16DataScalarWhereInput[]
    id?: StringFilter<"Form16Data"> | string
    userId?: StringFilter<"Form16Data"> | string
    employerName?: StringNullableFilter<"Form16Data"> | string | null
    employerTAN?: StringNullableFilter<"Form16Data"> | string | null
    employerCategory?: StringNullableFilter<"Form16Data"> | string | null
    totalTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    grossSalary?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: JsonNullableFilter<"Form16Data">
    perquisitesAmount?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    perquisites?: JsonNullableFilter<"Form16Data">
    profitAmount?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: JsonNullableFilter<"Form16Data">
    notifiedCountry?: JsonNullableFilter<"Form16Data">
    notifiedIncomeOtherCountry?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: JsonNullableFilter<"Form16Data">
    balance?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    professionalTax?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: DecimalNullableFilter<"Form16Data"> | Decimal | DecimalJsLike | number | string | null
    address?: JsonNullableFilter<"Form16Data">
    createdAt?: DateTimeFilter<"Form16Data"> | Date | string
    updatedAt?: DateTimeFilter<"Form16Data"> | Date | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithWhereWithoutUserInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    userId?: StringFilter<"Property"> | string
    propertyIndex?: StringNullableFilter<"Property"> | string | null
    propertyType?: StringNullableFilter<"Property"> | string | null
    netTaxableIncome?: DecimalNullableFilter<"Property"> | Decimal | DecimalJsLike | number | string | null
    houseAddress?: JsonNullableFilter<"Property">
    ownerDetails?: JsonNullableFilter<"Property">
    taxSavings?: JsonNullableFilter<"Property">
    rentalIncomeDetails?: JsonNullableFilter<"Property">
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
  }

  export type CapitalGainUpsertWithWhereUniqueWithoutUserInput = {
    where: CapitalGainWhereUniqueInput
    update: XOR<CapitalGainUpdateWithoutUserInput, CapitalGainUncheckedUpdateWithoutUserInput>
    create: XOR<CapitalGainCreateWithoutUserInput, CapitalGainUncheckedCreateWithoutUserInput>
  }

  export type CapitalGainUpdateWithWhereUniqueWithoutUserInput = {
    where: CapitalGainWhereUniqueInput
    data: XOR<CapitalGainUpdateWithoutUserInput, CapitalGainUncheckedUpdateWithoutUserInput>
  }

  export type CapitalGainUpdateManyWithWhereWithoutUserInput = {
    where: CapitalGainScalarWhereInput
    data: XOR<CapitalGainUpdateManyMutationInput, CapitalGainUncheckedUpdateManyWithoutUserInput>
  }

  export type CapitalGainScalarWhereInput = {
    AND?: CapitalGainScalarWhereInput | CapitalGainScalarWhereInput[]
    OR?: CapitalGainScalarWhereInput[]
    NOT?: CapitalGainScalarWhereInput | CapitalGainScalarWhereInput[]
    id?: StringFilter<"CapitalGain"> | string
    userId?: StringFilter<"CapitalGain"> | string
    assetType?: StringNullableFilter<"CapitalGain"> | string | null
    assetSubType?: StringNullableFilter<"CapitalGain"> | string | null
    dateOfSale?: DateTimeNullableFilter<"CapitalGain"> | Date | string | null
    dateOfPurchase?: DateTimeNullableFilter<"CapitalGain"> | Date | string | null
    description?: StringNullableFilter<"CapitalGain"> | string | null
    salePrice?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFilter<"CapitalGain"> | boolean
    totalProfit?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    indexationCost?: DecimalNullableFilter<"CapitalGain"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CapitalGain"> | Date | string
    updatedAt?: DateTimeFilter<"CapitalGain"> | Date | string
  }

  export type BusinessIncomeUpsertWithoutUserInput = {
    update: XOR<BusinessIncomeUpdateWithoutUserInput, BusinessIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<BusinessIncomeCreateWithoutUserInput, BusinessIncomeUncheckedCreateWithoutUserInput>
    where?: BusinessIncomeWhereInput
  }

  export type BusinessIncomeUpdateToOneWithWhereWithoutUserInput = {
    where?: BusinessIncomeWhereInput
    data: XOR<BusinessIncomeUpdateWithoutUserInput, BusinessIncomeUncheckedUpdateWithoutUserInput>
  }

  export type BusinessIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profitLoss?: ProfitLossUpdateManyWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type BusinessIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type ProfessionalIncomeUpsertWithoutUserInput = {
    update: XOR<ProfessionalIncomeUpdateWithoutUserInput, ProfessionalIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<ProfessionalIncomeCreateWithoutUserInput, ProfessionalIncomeUncheckedCreateWithoutUserInput>
    where?: ProfessionalIncomeWhereInput
  }

  export type ProfessionalIncomeUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfessionalIncomeWhereInput
    data: XOR<ProfessionalIncomeUpdateWithoutUserInput, ProfessionalIncomeUncheckedUpdateWithoutUserInput>
  }

  export type ProfessionalIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionType?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFieldUpdateOperationsInput | boolean
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfessionalIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    professionType?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44ADA?: BoolFieldUpdateOperationsInput | boolean
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeUpsertWithWhereUniqueWithoutUserInput = {
    where: CryptoIncomeWhereUniqueInput
    update: XOR<CryptoIncomeUpdateWithoutUserInput, CryptoIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<CryptoIncomeCreateWithoutUserInput, CryptoIncomeUncheckedCreateWithoutUserInput>
  }

  export type CryptoIncomeUpdateWithWhereUniqueWithoutUserInput = {
    where: CryptoIncomeWhereUniqueInput
    data: XOR<CryptoIncomeUpdateWithoutUserInput, CryptoIncomeUncheckedUpdateWithoutUserInput>
  }

  export type CryptoIncomeUpdateManyWithWhereWithoutUserInput = {
    where: CryptoIncomeScalarWhereInput
    data: XOR<CryptoIncomeUpdateManyMutationInput, CryptoIncomeUncheckedUpdateManyWithoutUserInput>
  }

  export type CryptoIncomeScalarWhereInput = {
    AND?: CryptoIncomeScalarWhereInput | CryptoIncomeScalarWhereInput[]
    OR?: CryptoIncomeScalarWhereInput[]
    NOT?: CryptoIncomeScalarWhereInput | CryptoIncomeScalarWhereInput[]
    id?: StringFilter<"CryptoIncome"> | string
    userId?: StringFilter<"CryptoIncome"> | string
    assetType?: StringNullableFilter<"CryptoIncome"> | string | null
    coinName?: StringNullableFilter<"CryptoIncome"> | string | null
    purchaseDate?: DateTimeNullableFilter<"CryptoIncome"> | Date | string | null
    saleDate?: DateTimeNullableFilter<"CryptoIncome"> | Date | string | null
    purchasePrice?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    salePrice?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    quantity?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    exchangeName?: StringNullableFilter<"CryptoIncome"> | string | null
    transactionHash?: StringNullableFilter<"CryptoIncome"> | string | null
    profit?: DecimalNullableFilter<"CryptoIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"CryptoIncome"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoIncome"> | Date | string
  }

  export type TaxSavingInvestmentUpsertWithoutUserInput = {
    update: XOR<TaxSavingInvestmentUpdateWithoutUserInput, TaxSavingInvestmentUncheckedUpdateWithoutUserInput>
    create: XOR<TaxSavingInvestmentCreateWithoutUserInput, TaxSavingInvestmentUncheckedCreateWithoutUserInput>
    where?: TaxSavingInvestmentWhereInput
  }

  export type TaxSavingInvestmentUpdateToOneWithWhereWithoutUserInput = {
    where?: TaxSavingInvestmentWhereInput
    data: XOR<TaxSavingInvestmentUpdateWithoutUserInput, TaxSavingInvestmentUncheckedUpdateWithoutUserInput>
  }

  export type TaxSavingInvestmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    section80C?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSavingInvestmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    section80C?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    savingsInterest80TTA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pensionContribution80CCC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployeeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    npsEmployerContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpsertWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
    create: XOR<DonationCreateWithoutUserInput, DonationUncheckedCreateWithoutUserInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutUserInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutUserInput, DonationUncheckedUpdateWithoutUserInput>
  }

  export type DonationUpdateManyWithWhereWithoutUserInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutUserInput>
  }

  export type DonationScalarWhereInput = {
    AND?: DonationScalarWhereInput | DonationScalarWhereInput[]
    OR?: DonationScalarWhereInput[]
    NOT?: DonationScalarWhereInput | DonationScalarWhereInput[]
    id?: StringFilter<"Donation"> | string
    userId?: StringFilter<"Donation"> | string
    organizationName?: StringNullableFilter<"Donation"> | string | null
    donationType?: StringNullableFilter<"Donation"> | string | null
    amount?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableFilter<"Donation"> | Date | string | null
    receiptNumber?: StringNullableFilter<"Donation"> | string | null
    eligibleAmount?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: DecimalNullableFilter<"Donation"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableFilter<"Donation"> | string | null
    createdAt?: DateTimeFilter<"Donation"> | Date | string
    updatedAt?: DateTimeFilter<"Donation"> | Date | string
  }

  export type MedicalInsuranceUpsertWithWhereUniqueWithoutUserInput = {
    where: MedicalInsuranceWhereUniqueInput
    update: XOR<MedicalInsuranceUpdateWithoutUserInput, MedicalInsuranceUncheckedUpdateWithoutUserInput>
    create: XOR<MedicalInsuranceCreateWithoutUserInput, MedicalInsuranceUncheckedCreateWithoutUserInput>
  }

  export type MedicalInsuranceUpdateWithWhereUniqueWithoutUserInput = {
    where: MedicalInsuranceWhereUniqueInput
    data: XOR<MedicalInsuranceUpdateWithoutUserInput, MedicalInsuranceUncheckedUpdateWithoutUserInput>
  }

  export type MedicalInsuranceUpdateManyWithWhereWithoutUserInput = {
    where: MedicalInsuranceScalarWhereInput
    data: XOR<MedicalInsuranceUpdateManyMutationInput, MedicalInsuranceUncheckedUpdateManyWithoutUserInput>
  }

  export type MedicalInsuranceScalarWhereInput = {
    AND?: MedicalInsuranceScalarWhereInput | MedicalInsuranceScalarWhereInput[]
    OR?: MedicalInsuranceScalarWhereInput[]
    NOT?: MedicalInsuranceScalarWhereInput | MedicalInsuranceScalarWhereInput[]
    id?: StringFilter<"MedicalInsurance"> | string
    userId?: StringFilter<"MedicalInsurance"> | string
    policyType?: StringNullableFilter<"MedicalInsurance"> | string | null
    insuredPersons?: StringNullableFilter<"MedicalInsurance"> | string | null
    premiumPaid?: DecimalNullableFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: DecimalNullableFilter<"MedicalInsurance"> | Decimal | DecimalJsLike | number | string | null
    policyNumber?: StringNullableFilter<"MedicalInsurance"> | string | null
    insuranceCompany?: StringNullableFilter<"MedicalInsurance"> | string | null
    createdAt?: DateTimeFilter<"MedicalInsurance"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalInsurance"> | Date | string
  }

  export type TaxPaidUpsertWithWhereUniqueWithoutUserInput = {
    where: TaxPaidWhereUniqueInput
    update: XOR<TaxPaidUpdateWithoutUserInput, TaxPaidUncheckedUpdateWithoutUserInput>
    create: XOR<TaxPaidCreateWithoutUserInput, TaxPaidUncheckedCreateWithoutUserInput>
  }

  export type TaxPaidUpdateWithWhereUniqueWithoutUserInput = {
    where: TaxPaidWhereUniqueInput
    data: XOR<TaxPaidUpdateWithoutUserInput, TaxPaidUncheckedUpdateWithoutUserInput>
  }

  export type TaxPaidUpdateManyWithWhereWithoutUserInput = {
    where: TaxPaidScalarWhereInput
    data: XOR<TaxPaidUpdateManyMutationInput, TaxPaidUncheckedUpdateManyWithoutUserInput>
  }

  export type TaxPaidScalarWhereInput = {
    AND?: TaxPaidScalarWhereInput | TaxPaidScalarWhereInput[]
    OR?: TaxPaidScalarWhereInput[]
    NOT?: TaxPaidScalarWhereInput | TaxPaidScalarWhereInput[]
    id?: StringFilter<"TaxPaid"> | string
    userId?: StringFilter<"TaxPaid"> | string
    taxType?: StringNullableFilter<"TaxPaid"> | string | null
    amount?: DecimalNullableFilter<"TaxPaid"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeNullableFilter<"TaxPaid"> | Date | string | null
    challanNumber?: StringNullableFilter<"TaxPaid"> | string | null
    bankName?: StringNullableFilter<"TaxPaid"> | string | null
    createdAt?: DateTimeFilter<"TaxPaid"> | Date | string
    updatedAt?: DateTimeFilter<"TaxPaid"> | Date | string
  }

  export type InterestIncomeUpsertWithWhereUniqueWithoutUserInput = {
    where: InterestIncomeWhereUniqueInput
    update: XOR<InterestIncomeUpdateWithoutUserInput, InterestIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<InterestIncomeCreateWithoutUserInput, InterestIncomeUncheckedCreateWithoutUserInput>
  }

  export type InterestIncomeUpdateWithWhereUniqueWithoutUserInput = {
    where: InterestIncomeWhereUniqueInput
    data: XOR<InterestIncomeUpdateWithoutUserInput, InterestIncomeUncheckedUpdateWithoutUserInput>
  }

  export type InterestIncomeUpdateManyWithWhereWithoutUserInput = {
    where: InterestIncomeScalarWhereInput
    data: XOR<InterestIncomeUpdateManyMutationInput, InterestIncomeUncheckedUpdateManyWithoutUserInput>
  }

  export type InterestIncomeScalarWhereInput = {
    AND?: InterestIncomeScalarWhereInput | InterestIncomeScalarWhereInput[]
    OR?: InterestIncomeScalarWhereInput[]
    NOT?: InterestIncomeScalarWhereInput | InterestIncomeScalarWhereInput[]
    id?: StringFilter<"InterestIncome"> | string
    userId?: StringFilter<"InterestIncome"> | string
    sourceType?: StringNullableFilter<"InterestIncome"> | string | null
    bankName?: StringNullableFilter<"InterestIncome"> | string | null
    accountNumber?: StringNullableFilter<"InterestIncome"> | string | null
    interestAmount?: DecimalNullableFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: DecimalNullableFilter<"InterestIncome"> | Decimal | DecimalJsLike | number | string | null
    financialYear?: StringNullableFilter<"InterestIncome"> | string | null
    createdAt?: DateTimeFilter<"InterestIncome"> | Date | string
    updatedAt?: DateTimeFilter<"InterestIncome"> | Date | string
  }

  export type DividendIncomeUpsertWithWhereUniqueWithoutUserInput = {
    where: DividendIncomeWhereUniqueInput
    update: XOR<DividendIncomeUpdateWithoutUserInput, DividendIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<DividendIncomeCreateWithoutUserInput, DividendIncomeUncheckedCreateWithoutUserInput>
  }

  export type DividendIncomeUpdateWithWhereUniqueWithoutUserInput = {
    where: DividendIncomeWhereUniqueInput
    data: XOR<DividendIncomeUpdateWithoutUserInput, DividendIncomeUncheckedUpdateWithoutUserInput>
  }

  export type DividendIncomeUpdateManyWithWhereWithoutUserInput = {
    where: DividendIncomeScalarWhereInput
    data: XOR<DividendIncomeUpdateManyMutationInput, DividendIncomeUncheckedUpdateManyWithoutUserInput>
  }

  export type DividendIncomeScalarWhereInput = {
    AND?: DividendIncomeScalarWhereInput | DividendIncomeScalarWhereInput[]
    OR?: DividendIncomeScalarWhereInput[]
    NOT?: DividendIncomeScalarWhereInput | DividendIncomeScalarWhereInput[]
    id?: StringFilter<"DividendIncome"> | string
    userId?: StringFilter<"DividendIncome"> | string
    companyName?: StringNullableFilter<"DividendIncome"> | string | null
    dividendAmount?: DecimalNullableFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: DecimalNullableFilter<"DividendIncome"> | Decimal | DecimalJsLike | number | string | null
    dateReceived?: DateTimeNullableFilter<"DividendIncome"> | Date | string | null
    shareQuantity?: IntNullableFilter<"DividendIncome"> | number | null
    createdAt?: DateTimeFilter<"DividendIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DividendIncome"> | Date | string
  }

  export type AgriculturalIncomeUpsertWithWhereUniqueWithoutUserInput = {
    where: AgriculturalIncomeWhereUniqueInput
    update: XOR<AgriculturalIncomeUpdateWithoutUserInput, AgriculturalIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<AgriculturalIncomeCreateWithoutUserInput, AgriculturalIncomeUncheckedCreateWithoutUserInput>
  }

  export type AgriculturalIncomeUpdateWithWhereUniqueWithoutUserInput = {
    where: AgriculturalIncomeWhereUniqueInput
    data: XOR<AgriculturalIncomeUpdateWithoutUserInput, AgriculturalIncomeUncheckedUpdateWithoutUserInput>
  }

  export type AgriculturalIncomeUpdateManyWithWhereWithoutUserInput = {
    where: AgriculturalIncomeScalarWhereInput
    data: XOR<AgriculturalIncomeUpdateManyMutationInput, AgriculturalIncomeUncheckedUpdateManyWithoutUserInput>
  }

  export type AgriculturalIncomeScalarWhereInput = {
    AND?: AgriculturalIncomeScalarWhereInput | AgriculturalIncomeScalarWhereInput[]
    OR?: AgriculturalIncomeScalarWhereInput[]
    NOT?: AgriculturalIncomeScalarWhereInput | AgriculturalIncomeScalarWhereInput[]
    id?: StringFilter<"AgriculturalIncome"> | string
    userId?: StringFilter<"AgriculturalIncome"> | string
    landArea?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    location?: StringNullableFilter<"AgriculturalIncome"> | string | null
    cropType?: StringNullableFilter<"AgriculturalIncome"> | string | null
    annualIncome?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    netIncome?: DecimalNullableFilter<"AgriculturalIncome"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AgriculturalIncome"> | Date | string
    updatedAt?: DateTimeFilter<"AgriculturalIncome"> | Date | string
  }

  export type ExemptIncomeUpsertWithWhereUniqueWithoutUserInput = {
    where: ExemptIncomeWhereUniqueInput
    update: XOR<ExemptIncomeUpdateWithoutUserInput, ExemptIncomeUncheckedUpdateWithoutUserInput>
    create: XOR<ExemptIncomeCreateWithoutUserInput, ExemptIncomeUncheckedCreateWithoutUserInput>
  }

  export type ExemptIncomeUpdateWithWhereUniqueWithoutUserInput = {
    where: ExemptIncomeWhereUniqueInput
    data: XOR<ExemptIncomeUpdateWithoutUserInput, ExemptIncomeUncheckedUpdateWithoutUserInput>
  }

  export type ExemptIncomeUpdateManyWithWhereWithoutUserInput = {
    where: ExemptIncomeScalarWhereInput
    data: XOR<ExemptIncomeUpdateManyMutationInput, ExemptIncomeUncheckedUpdateManyWithoutUserInput>
  }

  export type ExemptIncomeScalarWhereInput = {
    AND?: ExemptIncomeScalarWhereInput | ExemptIncomeScalarWhereInput[]
    OR?: ExemptIncomeScalarWhereInput[]
    NOT?: ExemptIncomeScalarWhereInput | ExemptIncomeScalarWhereInput[]
    id?: StringFilter<"ExemptIncome"> | string
    userId?: StringFilter<"ExemptIncome"> | string
    incomeType?: StringNullableFilter<"ExemptIncome"> | string | null
    description?: StringNullableFilter<"ExemptIncome"> | string | null
    amount?: DecimalNullableFilter<"ExemptIncome"> | Decimal | DecimalJsLike | number | string | null
    section?: StringNullableFilter<"ExemptIncome"> | string | null
    createdAt?: DateTimeFilter<"ExemptIncome"> | Date | string
    updatedAt?: DateTimeFilter<"ExemptIncome"> | Date | string
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type ITRGenerationUpsertWithWhereUniqueWithoutUserInput = {
    where: ITRGenerationWhereUniqueInput
    update: XOR<ITRGenerationUpdateWithoutUserInput, ITRGenerationUncheckedUpdateWithoutUserInput>
    create: XOR<ITRGenerationCreateWithoutUserInput, ITRGenerationUncheckedCreateWithoutUserInput>
  }

  export type ITRGenerationUpdateWithWhereUniqueWithoutUserInput = {
    where: ITRGenerationWhereUniqueInput
    data: XOR<ITRGenerationUpdateWithoutUserInput, ITRGenerationUncheckedUpdateWithoutUserInput>
  }

  export type ITRGenerationUpdateManyWithWhereWithoutUserInput = {
    where: ITRGenerationScalarWhereInput
    data: XOR<ITRGenerationUpdateManyMutationInput, ITRGenerationUncheckedUpdateManyWithoutUserInput>
  }

  export type ITRGenerationScalarWhereInput = {
    AND?: ITRGenerationScalarWhereInput | ITRGenerationScalarWhereInput[]
    OR?: ITRGenerationScalarWhereInput[]
    NOT?: ITRGenerationScalarWhereInput | ITRGenerationScalarWhereInput[]
    id?: StringFilter<"ITRGeneration"> | string
    userId?: StringFilter<"ITRGeneration"> | string
    itrType?: EnumITRTypeFilter<"ITRGeneration"> | $Enums.ITRType
    assessmentYear?: StringFilter<"ITRGeneration"> | string
    fileName?: StringFilter<"ITRGeneration"> | string
    checksum?: StringFilter<"ITRGeneration"> | string
    jsonData?: JsonFilter<"ITRGeneration">
    status?: EnumITRStatusFilter<"ITRGeneration"> | $Enums.ITRStatus
    generatedAt?: DateTimeFilter<"ITRGeneration"> | Date | string
    downloadedAt?: DateTimeNullableFilter<"ITRGeneration"> | Date | string | null
  }

  export type TaxSummaryUpsertWithWhereUniqueWithoutUserInput = {
    where: TaxSummaryWhereUniqueInput
    update: XOR<TaxSummaryUpdateWithoutUserInput, TaxSummaryUncheckedUpdateWithoutUserInput>
    create: XOR<TaxSummaryCreateWithoutUserInput, TaxSummaryUncheckedCreateWithoutUserInput>
  }

  export type TaxSummaryUpdateWithWhereUniqueWithoutUserInput = {
    where: TaxSummaryWhereUniqueInput
    data: XOR<TaxSummaryUpdateWithoutUserInput, TaxSummaryUncheckedUpdateWithoutUserInput>
  }

  export type TaxSummaryUpdateManyWithWhereWithoutUserInput = {
    where: TaxSummaryScalarWhereInput
    data: XOR<TaxSummaryUpdateManyMutationInput, TaxSummaryUncheckedUpdateManyWithoutUserInput>
  }

  export type TaxSummaryScalarWhereInput = {
    AND?: TaxSummaryScalarWhereInput | TaxSummaryScalarWhereInput[]
    OR?: TaxSummaryScalarWhereInput[]
    NOT?: TaxSummaryScalarWhereInput | TaxSummaryScalarWhereInput[]
    id?: StringFilter<"TaxSummary"> | string
    userId?: StringFilter<"TaxSummary"> | string
    assessmentYear?: StringNullableFilter<"TaxSummary"> | string | null
    totalIncome?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxLiability?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    taxPaid?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    refundAmount?: DecimalNullableFilter<"TaxSummary"> | Decimal | DecimalJsLike | number | string | null
    filingStatus?: StringNullableFilter<"TaxSummary"> | string | null
    filingDate?: DateTimeNullableFilter<"TaxSummary"> | Date | string | null
    createdAt?: DateTimeFilter<"TaxSummary"> | Date | string
    updatedAt?: DateTimeFilter<"TaxSummary"> | Date | string
  }

  export type ProfitLossUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfitLossWhereUniqueInput
    update: XOR<ProfitLossUpdateWithoutUserInput, ProfitLossUncheckedUpdateWithoutUserInput>
    create: XOR<ProfitLossCreateWithoutUserInput, ProfitLossUncheckedCreateWithoutUserInput>
  }

  export type ProfitLossUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfitLossWhereUniqueInput
    data: XOR<ProfitLossUpdateWithoutUserInput, ProfitLossUncheckedUpdateWithoutUserInput>
  }

  export type ProfitLossUpdateManyWithWhereWithoutUserInput = {
    where: ProfitLossScalarWhereInput
    data: XOR<ProfitLossUpdateManyMutationInput, ProfitLossUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfitLossScalarWhereInput = {
    AND?: ProfitLossScalarWhereInput | ProfitLossScalarWhereInput[]
    OR?: ProfitLossScalarWhereInput[]
    NOT?: ProfitLossScalarWhereInput | ProfitLossScalarWhereInput[]
    id?: StringFilter<"ProfitLoss"> | string
    userId?: StringFilter<"ProfitLoss"> | string
    businessIncomeId?: StringNullableFilter<"ProfitLoss"> | string | null
    year?: StringNullableFilter<"ProfitLoss"> | string | null
    income?: JsonNullableFilter<"ProfitLoss">
    expenses?: JsonNullableFilter<"ProfitLoss">
    netProfit?: DecimalNullableFilter<"ProfitLoss"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"ProfitLoss"> | Date | string
    updatedAt?: DateTimeFilter<"ProfitLoss"> | Date | string
  }

  export type BalanceSheetUpsertWithWhereUniqueWithoutUserInput = {
    where: BalanceSheetWhereUniqueInput
    update: XOR<BalanceSheetUpdateWithoutUserInput, BalanceSheetUncheckedUpdateWithoutUserInput>
    create: XOR<BalanceSheetCreateWithoutUserInput, BalanceSheetUncheckedCreateWithoutUserInput>
  }

  export type BalanceSheetUpdateWithWhereUniqueWithoutUserInput = {
    where: BalanceSheetWhereUniqueInput
    data: XOR<BalanceSheetUpdateWithoutUserInput, BalanceSheetUncheckedUpdateWithoutUserInput>
  }

  export type BalanceSheetUpdateManyWithWhereWithoutUserInput = {
    where: BalanceSheetScalarWhereInput
    data: XOR<BalanceSheetUpdateManyMutationInput, BalanceSheetUncheckedUpdateManyWithoutUserInput>
  }

  export type BalanceSheetScalarWhereInput = {
    AND?: BalanceSheetScalarWhereInput | BalanceSheetScalarWhereInput[]
    OR?: BalanceSheetScalarWhereInput[]
    NOT?: BalanceSheetScalarWhereInput | BalanceSheetScalarWhereInput[]
    id?: StringFilter<"BalanceSheet"> | string
    userId?: StringFilter<"BalanceSheet"> | string
    businessIncomeId?: StringNullableFilter<"BalanceSheet"> | string | null
    year?: StringNullableFilter<"BalanceSheet"> | string | null
    assets?: JsonNullableFilter<"BalanceSheet">
    liabilities?: JsonNullableFilter<"BalanceSheet">
    createdAt?: DateTimeFilter<"BalanceSheet"> | Date | string
    updatedAt?: DateTimeFilter<"BalanceSheet"> | Date | string
  }

  export type DepreciationEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: DepreciationEntryWhereUniqueInput
    update: XOR<DepreciationEntryUpdateWithoutUserInput, DepreciationEntryUncheckedUpdateWithoutUserInput>
    create: XOR<DepreciationEntryCreateWithoutUserInput, DepreciationEntryUncheckedCreateWithoutUserInput>
  }

  export type DepreciationEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: DepreciationEntryWhereUniqueInput
    data: XOR<DepreciationEntryUpdateWithoutUserInput, DepreciationEntryUncheckedUpdateWithoutUserInput>
  }

  export type DepreciationEntryUpdateManyWithWhereWithoutUserInput = {
    where: DepreciationEntryScalarWhereInput
    data: XOR<DepreciationEntryUpdateManyMutationInput, DepreciationEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type DepreciationEntryScalarWhereInput = {
    AND?: DepreciationEntryScalarWhereInput | DepreciationEntryScalarWhereInput[]
    OR?: DepreciationEntryScalarWhereInput[]
    NOT?: DepreciationEntryScalarWhereInput | DepreciationEntryScalarWhereInput[]
    id?: StringFilter<"DepreciationEntry"> | string
    userId?: StringFilter<"DepreciationEntry"> | string
    businessIncomeId?: StringNullableFilter<"DepreciationEntry"> | string | null
    assetName?: StringNullableFilter<"DepreciationEntry"> | string | null
    assetCategory?: StringNullableFilter<"DepreciationEntry"> | string | null
    purchaseDate?: DateTimeNullableFilter<"DepreciationEntry"> | Date | string | null
    purchaseCost?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: DecimalNullableFilter<"DepreciationEntry"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"DepreciationEntry"> | Date | string
    updatedAt?: DateTimeFilter<"DepreciationEntry"> | Date | string
  }

  export type UserCreateWithoutPersonalDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type UserUpsertWithoutPersonalDetailsInput = {
    update: XOR<UserUpdateWithoutPersonalDetailsInput, UserUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<UserCreateWithoutPersonalDetailsInput, UserUncheckedCreateWithoutPersonalDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalDetailsInput, UserUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type UserUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutContactDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactDetailsInput, UserUncheckedCreateWithoutContactDetailsInput>
  }

  export type UserUpsertWithoutContactDetailsInput = {
    update: XOR<UserUpdateWithoutContactDetailsInput, UserUncheckedUpdateWithoutContactDetailsInput>
    create: XOR<UserCreateWithoutContactDetailsInput, UserUncheckedCreateWithoutContactDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactDetailsInput, UserUncheckedUpdateWithoutContactDetailsInput>
  }

  export type UserUpdateWithoutContactDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAddressDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressDetailsInput, UserUncheckedCreateWithoutAddressDetailsInput>
  }

  export type UserUpsertWithoutAddressDetailsInput = {
    update: XOR<UserUpdateWithoutAddressDetailsInput, UserUncheckedUpdateWithoutAddressDetailsInput>
    create: XOR<UserCreateWithoutAddressDetailsInput, UserUncheckedCreateWithoutAddressDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressDetailsInput, UserUncheckedUpdateWithoutAddressDetailsInput>
  }

  export type UserUpdateWithoutAddressDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBankDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBankDetailsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBankDetailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBankDetailsInput, UserUncheckedCreateWithoutBankDetailsInput>
  }

  export type UserUpsertWithoutBankDetailsInput = {
    update: XOR<UserUpdateWithoutBankDetailsInput, UserUncheckedUpdateWithoutBankDetailsInput>
    create: XOR<UserCreateWithoutBankDetailsInput, UserUncheckedCreateWithoutBankDetailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBankDetailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBankDetailsInput, UserUncheckedUpdateWithoutBankDetailsInput>
  }

  export type UserUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBankDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutForm16DataInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForm16DataInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForm16DataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForm16DataInput, UserUncheckedCreateWithoutForm16DataInput>
  }

  export type UserUpsertWithoutForm16DataInput = {
    update: XOR<UserUpdateWithoutForm16DataInput, UserUncheckedUpdateWithoutForm16DataInput>
    create: XOR<UserCreateWithoutForm16DataInput, UserUncheckedCreateWithoutForm16DataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForm16DataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForm16DataInput, UserUncheckedUpdateWithoutForm16DataInput>
  }

  export type UserUpdateWithoutForm16DataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForm16DataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPropertiesInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPropertiesInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPropertiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
  }

  export type UserUpsertWithoutPropertiesInput = {
    update: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCapitalGainsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCapitalGainsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCapitalGainsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCapitalGainsInput, UserUncheckedCreateWithoutCapitalGainsInput>
  }

  export type UserUpsertWithoutCapitalGainsInput = {
    update: XOR<UserUpdateWithoutCapitalGainsInput, UserUncheckedUpdateWithoutCapitalGainsInput>
    create: XOR<UserCreateWithoutCapitalGainsInput, UserUncheckedCreateWithoutCapitalGainsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCapitalGainsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCapitalGainsInput, UserUncheckedUpdateWithoutCapitalGainsInput>
  }

  export type UserUpdateWithoutCapitalGainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCapitalGainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInterestIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterestIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterestIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterestIncomeInput, UserUncheckedCreateWithoutInterestIncomeInput>
  }

  export type UserUpsertWithoutInterestIncomeInput = {
    update: XOR<UserUpdateWithoutInterestIncomeInput, UserUncheckedUpdateWithoutInterestIncomeInput>
    create: XOR<UserCreateWithoutInterestIncomeInput, UserUncheckedCreateWithoutInterestIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterestIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterestIncomeInput, UserUncheckedUpdateWithoutInterestIncomeInput>
  }

  export type UserUpdateWithoutInterestIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterestIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDividendIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDividendIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDividendIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDividendIncomeInput, UserUncheckedCreateWithoutDividendIncomeInput>
  }

  export type UserUpsertWithoutDividendIncomeInput = {
    update: XOR<UserUpdateWithoutDividendIncomeInput, UserUncheckedUpdateWithoutDividendIncomeInput>
    create: XOR<UserCreateWithoutDividendIncomeInput, UserUncheckedCreateWithoutDividendIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDividendIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDividendIncomeInput, UserUncheckedUpdateWithoutDividendIncomeInput>
  }

  export type UserUpdateWithoutDividendIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDividendIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBusinessIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBusinessIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBusinessIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBusinessIncomeInput, UserUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type ProfitLossCreateWithoutBusinessIncomeInput = {
    id?: string
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfitLossInput
  }

  export type ProfitLossUncheckedCreateWithoutBusinessIncomeInput = {
    id?: string
    userId: string
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfitLossCreateOrConnectWithoutBusinessIncomeInput = {
    where: ProfitLossWhereUniqueInput
    create: XOR<ProfitLossCreateWithoutBusinessIncomeInput, ProfitLossUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type ProfitLossCreateManyBusinessIncomeInputEnvelope = {
    data: ProfitLossCreateManyBusinessIncomeInput | ProfitLossCreateManyBusinessIncomeInput[]
    skipDuplicates?: boolean
  }

  export type BalanceSheetCreateWithoutBusinessIncomeInput = {
    id?: string
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBalanceSheetsInput
  }

  export type BalanceSheetUncheckedCreateWithoutBusinessIncomeInput = {
    id?: string
    userId: string
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceSheetCreateOrConnectWithoutBusinessIncomeInput = {
    where: BalanceSheetWhereUniqueInput
    create: XOR<BalanceSheetCreateWithoutBusinessIncomeInput, BalanceSheetUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type BalanceSheetCreateManyBusinessIncomeInputEnvelope = {
    data: BalanceSheetCreateManyBusinessIncomeInput | BalanceSheetCreateManyBusinessIncomeInput[]
    skipDuplicates?: boolean
  }

  export type DepreciationEntryCreateWithoutBusinessIncomeInput = {
    id?: string
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDepreciationEntriesInput
  }

  export type DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput = {
    id?: string
    userId: string
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationEntryCreateOrConnectWithoutBusinessIncomeInput = {
    where: DepreciationEntryWhereUniqueInput
    create: XOR<DepreciationEntryCreateWithoutBusinessIncomeInput, DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type DepreciationEntryCreateManyBusinessIncomeInputEnvelope = {
    data: DepreciationEntryCreateManyBusinessIncomeInput | DepreciationEntryCreateManyBusinessIncomeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBusinessIncomeInput = {
    update: XOR<UserUpdateWithoutBusinessIncomeInput, UserUncheckedUpdateWithoutBusinessIncomeInput>
    create: XOR<UserCreateWithoutBusinessIncomeInput, UserUncheckedCreateWithoutBusinessIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBusinessIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBusinessIncomeInput, UserUncheckedUpdateWithoutBusinessIncomeInput>
  }

  export type UserUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProfitLossUpsertWithWhereUniqueWithoutBusinessIncomeInput = {
    where: ProfitLossWhereUniqueInput
    update: XOR<ProfitLossUpdateWithoutBusinessIncomeInput, ProfitLossUncheckedUpdateWithoutBusinessIncomeInput>
    create: XOR<ProfitLossCreateWithoutBusinessIncomeInput, ProfitLossUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type ProfitLossUpdateWithWhereUniqueWithoutBusinessIncomeInput = {
    where: ProfitLossWhereUniqueInput
    data: XOR<ProfitLossUpdateWithoutBusinessIncomeInput, ProfitLossUncheckedUpdateWithoutBusinessIncomeInput>
  }

  export type ProfitLossUpdateManyWithWhereWithoutBusinessIncomeInput = {
    where: ProfitLossScalarWhereInput
    data: XOR<ProfitLossUpdateManyMutationInput, ProfitLossUncheckedUpdateManyWithoutBusinessIncomeInput>
  }

  export type BalanceSheetUpsertWithWhereUniqueWithoutBusinessIncomeInput = {
    where: BalanceSheetWhereUniqueInput
    update: XOR<BalanceSheetUpdateWithoutBusinessIncomeInput, BalanceSheetUncheckedUpdateWithoutBusinessIncomeInput>
    create: XOR<BalanceSheetCreateWithoutBusinessIncomeInput, BalanceSheetUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type BalanceSheetUpdateWithWhereUniqueWithoutBusinessIncomeInput = {
    where: BalanceSheetWhereUniqueInput
    data: XOR<BalanceSheetUpdateWithoutBusinessIncomeInput, BalanceSheetUncheckedUpdateWithoutBusinessIncomeInput>
  }

  export type BalanceSheetUpdateManyWithWhereWithoutBusinessIncomeInput = {
    where: BalanceSheetScalarWhereInput
    data: XOR<BalanceSheetUpdateManyMutationInput, BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeInput>
  }

  export type DepreciationEntryUpsertWithWhereUniqueWithoutBusinessIncomeInput = {
    where: DepreciationEntryWhereUniqueInput
    update: XOR<DepreciationEntryUpdateWithoutBusinessIncomeInput, DepreciationEntryUncheckedUpdateWithoutBusinessIncomeInput>
    create: XOR<DepreciationEntryCreateWithoutBusinessIncomeInput, DepreciationEntryUncheckedCreateWithoutBusinessIncomeInput>
  }

  export type DepreciationEntryUpdateWithWhereUniqueWithoutBusinessIncomeInput = {
    where: DepreciationEntryWhereUniqueInput
    data: XOR<DepreciationEntryUpdateWithoutBusinessIncomeInput, DepreciationEntryUncheckedUpdateWithoutBusinessIncomeInput>
  }

  export type DepreciationEntryUpdateManyWithWhereWithoutBusinessIncomeInput = {
    where: DepreciationEntryScalarWhereInput
    data: XOR<DepreciationEntryUpdateManyMutationInput, DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeInput>
  }

  export type UserCreateWithoutProfessionalIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfessionalIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfessionalIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfessionalIncomeInput, UserUncheckedCreateWithoutProfessionalIncomeInput>
  }

  export type UserUpsertWithoutProfessionalIncomeInput = {
    update: XOR<UserUpdateWithoutProfessionalIncomeInput, UserUncheckedUpdateWithoutProfessionalIncomeInput>
    create: XOR<UserCreateWithoutProfessionalIncomeInput, UserUncheckedCreateWithoutProfessionalIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfessionalIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfessionalIncomeInput, UserUncheckedUpdateWithoutProfessionalIncomeInput>
  }

  export type UserUpdateWithoutProfessionalIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfessionalIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfitLossInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfitLossInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfitLossInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfitLossInput, UserUncheckedCreateWithoutProfitLossInput>
  }

  export type BusinessIncomeCreateWithoutProfitLossInput = {
    id?: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeUncheckedCreateWithoutProfitLossInput = {
    id?: string
    userId: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    balanceSheet?: BalanceSheetUncheckedCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryUncheckedCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeCreateOrConnectWithoutProfitLossInput = {
    where: BusinessIncomeWhereUniqueInput
    create: XOR<BusinessIncomeCreateWithoutProfitLossInput, BusinessIncomeUncheckedCreateWithoutProfitLossInput>
  }

  export type UserUpsertWithoutProfitLossInput = {
    update: XOR<UserUpdateWithoutProfitLossInput, UserUncheckedUpdateWithoutProfitLossInput>
    create: XOR<UserCreateWithoutProfitLossInput, UserUncheckedCreateWithoutProfitLossInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfitLossInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfitLossInput, UserUncheckedUpdateWithoutProfitLossInput>
  }

  export type UserUpdateWithoutProfitLossInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfitLossInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessIncomeUpsertWithoutProfitLossInput = {
    update: XOR<BusinessIncomeUpdateWithoutProfitLossInput, BusinessIncomeUncheckedUpdateWithoutProfitLossInput>
    create: XOR<BusinessIncomeCreateWithoutProfitLossInput, BusinessIncomeUncheckedCreateWithoutProfitLossInput>
    where?: BusinessIncomeWhereInput
  }

  export type BusinessIncomeUpdateToOneWithWhereWithoutProfitLossInput = {
    where?: BusinessIncomeWhereInput
    data: XOR<BusinessIncomeUpdateWithoutProfitLossInput, BusinessIncomeUncheckedUpdateWithoutProfitLossInput>
  }

  export type BusinessIncomeUpdateWithoutProfitLossInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type BusinessIncomeUncheckedUpdateWithoutProfitLossInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balanceSheet?: BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type UserCreateWithoutBalanceSheetsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBalanceSheetsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBalanceSheetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBalanceSheetsInput, UserUncheckedCreateWithoutBalanceSheetsInput>
  }

  export type BusinessIncomeCreateWithoutBalanceSheetInput = {
    id?: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessIncomeInput
    profitLoss?: ProfitLossCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeUncheckedCreateWithoutBalanceSheetInput = {
    id?: string
    userId: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutBusinessIncomeInput
    depreciation?: DepreciationEntryUncheckedCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeCreateOrConnectWithoutBalanceSheetInput = {
    where: BusinessIncomeWhereUniqueInput
    create: XOR<BusinessIncomeCreateWithoutBalanceSheetInput, BusinessIncomeUncheckedCreateWithoutBalanceSheetInput>
  }

  export type UserUpsertWithoutBalanceSheetsInput = {
    update: XOR<UserUpdateWithoutBalanceSheetsInput, UserUncheckedUpdateWithoutBalanceSheetsInput>
    create: XOR<UserCreateWithoutBalanceSheetsInput, UserUncheckedCreateWithoutBalanceSheetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBalanceSheetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBalanceSheetsInput, UserUncheckedUpdateWithoutBalanceSheetsInput>
  }

  export type UserUpdateWithoutBalanceSheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBalanceSheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessIncomeUpsertWithoutBalanceSheetInput = {
    update: XOR<BusinessIncomeUpdateWithoutBalanceSheetInput, BusinessIncomeUncheckedUpdateWithoutBalanceSheetInput>
    create: XOR<BusinessIncomeCreateWithoutBalanceSheetInput, BusinessIncomeUncheckedCreateWithoutBalanceSheetInput>
    where?: BusinessIncomeWhereInput
  }

  export type BusinessIncomeUpdateToOneWithWhereWithoutBalanceSheetInput = {
    where?: BusinessIncomeWhereInput
    data: XOR<BusinessIncomeUpdateWithoutBalanceSheetInput, BusinessIncomeUncheckedUpdateWithoutBalanceSheetInput>
  }

  export type BusinessIncomeUpdateWithoutBalanceSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessIncomeNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type BusinessIncomeUncheckedUpdateWithoutBalanceSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    depreciation?: DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type UserCreateWithoutDepreciationEntriesInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepreciationEntriesInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepreciationEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepreciationEntriesInput, UserUncheckedCreateWithoutDepreciationEntriesInput>
  }

  export type BusinessIncomeCreateWithoutDepreciationInput = {
    id?: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessIncomeInput
    profitLoss?: ProfitLossCreateNestedManyWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeUncheckedCreateWithoutDepreciationInput = {
    id?: string
    userId: string
    businessName?: string | null
    businessType?: string | null
    businessAddress?: string | null
    grossReceipts?: Decimal | DecimalJsLike | number | string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    businessExpenses?: Decimal | DecimalJsLike | number | string | null
    netProfit?: Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: Decimal | DecimalJsLike | number | string | null
    section44AD?: boolean
    section44AE?: boolean
    auditRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutBusinessIncomeInput
    balanceSheet?: BalanceSheetUncheckedCreateNestedManyWithoutBusinessIncomeInput
  }

  export type BusinessIncomeCreateOrConnectWithoutDepreciationInput = {
    where: BusinessIncomeWhereUniqueInput
    create: XOR<BusinessIncomeCreateWithoutDepreciationInput, BusinessIncomeUncheckedCreateWithoutDepreciationInput>
  }

  export type UserUpsertWithoutDepreciationEntriesInput = {
    update: XOR<UserUpdateWithoutDepreciationEntriesInput, UserUncheckedUpdateWithoutDepreciationEntriesInput>
    create: XOR<UserCreateWithoutDepreciationEntriesInput, UserUncheckedCreateWithoutDepreciationEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepreciationEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepreciationEntriesInput, UserUncheckedUpdateWithoutDepreciationEntriesInput>
  }

  export type UserUpdateWithoutDepreciationEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepreciationEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusinessIncomeUpsertWithoutDepreciationInput = {
    update: XOR<BusinessIncomeUpdateWithoutDepreciationInput, BusinessIncomeUncheckedUpdateWithoutDepreciationInput>
    create: XOR<BusinessIncomeCreateWithoutDepreciationInput, BusinessIncomeUncheckedCreateWithoutDepreciationInput>
    where?: BusinessIncomeWhereInput
  }

  export type BusinessIncomeUpdateToOneWithWhereWithoutDepreciationInput = {
    where?: BusinessIncomeWhereInput
    data: XOR<BusinessIncomeUpdateWithoutDepreciationInput, BusinessIncomeUncheckedUpdateWithoutDepreciationInput>
  }

  export type BusinessIncomeUpdateWithoutDepreciationInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessIncomeNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type BusinessIncomeUncheckedUpdateWithoutDepreciationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    businessAddress?: NullableStringFieldUpdateOperationsInput | string | null
    grossReceipts?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    businessExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    presumptiveIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section44AD?: BoolFieldUpdateOperationsInput | boolean
    section44AE?: BoolFieldUpdateOperationsInput | boolean
    auditRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutBusinessIncomeNestedInput
    balanceSheet?: BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeNestedInput
  }

  export type UserCreateWithoutCryptoIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCryptoIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCryptoIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCryptoIncomeInput, UserUncheckedCreateWithoutCryptoIncomeInput>
  }

  export type UserUpsertWithoutCryptoIncomeInput = {
    update: XOR<UserUpdateWithoutCryptoIncomeInput, UserUncheckedUpdateWithoutCryptoIncomeInput>
    create: XOR<UserCreateWithoutCryptoIncomeInput, UserUncheckedCreateWithoutCryptoIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCryptoIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCryptoIncomeInput, UserUncheckedUpdateWithoutCryptoIncomeInput>
  }

  export type UserUpdateWithoutCryptoIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCryptoIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAgriculturalIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgriculturalIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgriculturalIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgriculturalIncomeInput, UserUncheckedCreateWithoutAgriculturalIncomeInput>
  }

  export type UserUpsertWithoutAgriculturalIncomeInput = {
    update: XOR<UserUpdateWithoutAgriculturalIncomeInput, UserUncheckedUpdateWithoutAgriculturalIncomeInput>
    create: XOR<UserCreateWithoutAgriculturalIncomeInput, UserUncheckedCreateWithoutAgriculturalIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgriculturalIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgriculturalIncomeInput, UserUncheckedUpdateWithoutAgriculturalIncomeInput>
  }

  export type UserUpdateWithoutAgriculturalIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgriculturalIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutExemptIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExemptIncomeInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExemptIncomeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExemptIncomeInput, UserUncheckedCreateWithoutExemptIncomeInput>
  }

  export type UserUpsertWithoutExemptIncomeInput = {
    update: XOR<UserUpdateWithoutExemptIncomeInput, UserUncheckedUpdateWithoutExemptIncomeInput>
    create: XOR<UserCreateWithoutExemptIncomeInput, UserUncheckedCreateWithoutExemptIncomeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExemptIncomeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExemptIncomeInput, UserUncheckedUpdateWithoutExemptIncomeInput>
  }

  export type UserUpdateWithoutExemptIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExemptIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTaxSavingInvestmentsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaxSavingInvestmentsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaxSavingInvestmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaxSavingInvestmentsInput, UserUncheckedCreateWithoutTaxSavingInvestmentsInput>
  }

  export type UserUpsertWithoutTaxSavingInvestmentsInput = {
    update: XOR<UserUpdateWithoutTaxSavingInvestmentsInput, UserUncheckedUpdateWithoutTaxSavingInvestmentsInput>
    create: XOR<UserCreateWithoutTaxSavingInvestmentsInput, UserUncheckedCreateWithoutTaxSavingInvestmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaxSavingInvestmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaxSavingInvestmentsInput, UserUncheckedUpdateWithoutTaxSavingInvestmentsInput>
  }

  export type UserUpdateWithoutTaxSavingInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaxSavingInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDonationsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDonationsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDonationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
  }

  export type UserUpsertWithoutDonationsInput = {
    update: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
    create: XOR<UserCreateWithoutDonationsInput, UserUncheckedCreateWithoutDonationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDonationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDonationsInput, UserUncheckedUpdateWithoutDonationsInput>
  }

  export type UserUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDonationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMedicalInsuranceInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMedicalInsuranceInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMedicalInsuranceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicalInsuranceInput, UserUncheckedCreateWithoutMedicalInsuranceInput>
  }

  export type UserUpsertWithoutMedicalInsuranceInput = {
    update: XOR<UserUpdateWithoutMedicalInsuranceInput, UserUncheckedUpdateWithoutMedicalInsuranceInput>
    create: XOR<UserCreateWithoutMedicalInsuranceInput, UserUncheckedCreateWithoutMedicalInsuranceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicalInsuranceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicalInsuranceInput, UserUncheckedUpdateWithoutMedicalInsuranceInput>
  }

  export type UserUpdateWithoutMedicalInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicalInsuranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTaxPaidInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaxPaidInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaxPaidInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaxPaidInput, UserUncheckedCreateWithoutTaxPaidInput>
  }

  export type UserUpsertWithoutTaxPaidInput = {
    update: XOR<UserUpdateWithoutTaxPaidInput, UserUncheckedUpdateWithoutTaxPaidInput>
    create: XOR<UserCreateWithoutTaxPaidInput, UserUncheckedCreateWithoutTaxPaidInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaxPaidInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaxPaidInput, UserUncheckedUpdateWithoutTaxPaidInput>
  }

  export type UserUpdateWithoutTaxPaidInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaxPaidInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WalletTransactionCreateWithoutWalletInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
  }

  export type WalletTransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionCreateManyWalletInputEnvelope = {
    data: WalletTransactionCreateManyWalletInput | WalletTransactionCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutWalletInput, WalletTransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutWalletInput, WalletTransactionUncheckedUpdateWithoutWalletInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutWalletInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    transactionType?: EnumTransactionTypeFilter<"WalletTransaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    razorpayPaymentId?: StringNullableFilter<"WalletTransaction"> | string | null
    razorpayOrderId?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"WalletTransaction"> | $Enums.TransactionStatus
    timestamp?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WalletCreateWithoutTransactionsInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    balance?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutTransactionsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
  }

  export type WalletUpsertWithoutTransactionsInput = {
    update: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutItrGenerationsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    taxSummaries?: TaxSummaryCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutItrGenerationsInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    taxSummaries?: TaxSummaryUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutItrGenerationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutItrGenerationsInput, UserUncheckedCreateWithoutItrGenerationsInput>
  }

  export type UserUpsertWithoutItrGenerationsInput = {
    update: XOR<UserUpdateWithoutItrGenerationsInput, UserUncheckedUpdateWithoutItrGenerationsInput>
    create: XOR<UserCreateWithoutItrGenerationsInput, UserUncheckedCreateWithoutItrGenerationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutItrGenerationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutItrGenerationsInput, UserUncheckedUpdateWithoutItrGenerationsInput>
  }

  export type UserUpdateWithoutItrGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    taxSummaries?: TaxSummaryUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutItrGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    taxSummaries?: TaxSummaryUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTaxSummariesInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailCreateNestedOneWithoutUserInput
    form16Data?: Form16DataCreateNestedManyWithoutUserInput
    properties?: PropertyCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentCreateNestedOneWithoutUserInput
    donations?: DonationCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaxSummariesInput = {
    id?: string
    name: string
    phone?: string | null
    email: string
    password?: string | null
    role?: $Enums.Role
    emailVerified?: boolean
    emailVerificationDate?: Date | string | null
    lastVerificationEmailSent?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personalDetails?: PersonalDetailUncheckedCreateNestedOneWithoutUserInput
    contactDetails?: ContactDetailUncheckedCreateNestedOneWithoutUserInput
    bankDetails?: BankDetailUncheckedCreateNestedOneWithoutUserInput
    addressDetails?: AddressDetailUncheckedCreateNestedOneWithoutUserInput
    form16Data?: Form16DataUncheckedCreateNestedManyWithoutUserInput
    properties?: PropertyUncheckedCreateNestedManyWithoutUserInput
    capitalGains?: CapitalGainUncheckedCreateNestedManyWithoutUserInput
    businessIncome?: BusinessIncomeUncheckedCreateNestedOneWithoutUserInput
    professionalIncome?: ProfessionalIncomeUncheckedCreateNestedOneWithoutUserInput
    cryptoIncome?: CryptoIncomeUncheckedCreateNestedManyWithoutUserInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedCreateNestedOneWithoutUserInput
    donations?: DonationUncheckedCreateNestedManyWithoutUserInput
    medicalInsurance?: MedicalInsuranceUncheckedCreateNestedManyWithoutUserInput
    taxPaid?: TaxPaidUncheckedCreateNestedManyWithoutUserInput
    interestIncome?: InterestIncomeUncheckedCreateNestedManyWithoutUserInput
    dividendIncome?: DividendIncomeUncheckedCreateNestedManyWithoutUserInput
    agriculturalIncome?: AgriculturalIncomeUncheckedCreateNestedManyWithoutUserInput
    exemptIncome?: ExemptIncomeUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    itrGenerations?: ITRGenerationUncheckedCreateNestedManyWithoutUserInput
    profitLoss?: ProfitLossUncheckedCreateNestedManyWithoutUserInput
    balanceSheets?: BalanceSheetUncheckedCreateNestedManyWithoutUserInput
    depreciationEntries?: DepreciationEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaxSummariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaxSummariesInput, UserUncheckedCreateWithoutTaxSummariesInput>
  }

  export type UserUpsertWithoutTaxSummariesInput = {
    update: XOR<UserUpdateWithoutTaxSummariesInput, UserUncheckedUpdateWithoutTaxSummariesInput>
    create: XOR<UserCreateWithoutTaxSummariesInput, UserUncheckedCreateWithoutTaxSummariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaxSummariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaxSummariesInput, UserUncheckedUpdateWithoutTaxSummariesInput>
  }

  export type UserUpdateWithoutTaxSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUpdateManyWithoutUserNestedInput
    properties?: PropertyUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUpdateOneWithoutUserNestedInput
    donations?: DonationUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaxSummariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastVerificationEmailSent?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalDetails?: PersonalDetailUncheckedUpdateOneWithoutUserNestedInput
    contactDetails?: ContactDetailUncheckedUpdateOneWithoutUserNestedInput
    bankDetails?: BankDetailUncheckedUpdateOneWithoutUserNestedInput
    addressDetails?: AddressDetailUncheckedUpdateOneWithoutUserNestedInput
    form16Data?: Form16DataUncheckedUpdateManyWithoutUserNestedInput
    properties?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    capitalGains?: CapitalGainUncheckedUpdateManyWithoutUserNestedInput
    businessIncome?: BusinessIncomeUncheckedUpdateOneWithoutUserNestedInput
    professionalIncome?: ProfessionalIncomeUncheckedUpdateOneWithoutUserNestedInput
    cryptoIncome?: CryptoIncomeUncheckedUpdateManyWithoutUserNestedInput
    taxSavingInvestments?: TaxSavingInvestmentUncheckedUpdateOneWithoutUserNestedInput
    donations?: DonationUncheckedUpdateManyWithoutUserNestedInput
    medicalInsurance?: MedicalInsuranceUncheckedUpdateManyWithoutUserNestedInput
    taxPaid?: TaxPaidUncheckedUpdateManyWithoutUserNestedInput
    interestIncome?: InterestIncomeUncheckedUpdateManyWithoutUserNestedInput
    dividendIncome?: DividendIncomeUncheckedUpdateManyWithoutUserNestedInput
    agriculturalIncome?: AgriculturalIncomeUncheckedUpdateManyWithoutUserNestedInput
    exemptIncome?: ExemptIncomeUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    itrGenerations?: ITRGenerationUncheckedUpdateManyWithoutUserNestedInput
    profitLoss?: ProfitLossUncheckedUpdateManyWithoutUserNestedInput
    balanceSheets?: BalanceSheetUncheckedUpdateManyWithoutUserNestedInput
    depreciationEntries?: DepreciationEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Form16DataCreateManyUserInput = {
    id?: string
    employerName?: string | null
    employerTAN?: string | null
    employerCategory?: string | null
    totalTax?: Decimal | DecimalJsLike | number | string | null
    grossSalary?: Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: Decimal | DecimalJsLike | number | string | null
    standardDeduction?: Decimal | DecimalJsLike | number | string | null
    professionalTax?: Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCreateManyUserInput = {
    id?: string
    propertyIndex?: string | null
    propertyType?: string | null
    netTaxableIncome?: Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CapitalGainCreateManyUserInput = {
    id?: string
    assetType?: string | null
    assetSubType?: string | null
    dateOfSale?: Date | string | null
    dateOfPurchase?: Date | string | null
    description?: string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    transferExpenses?: Decimal | DecimalJsLike | number | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    sttPaid?: boolean
    totalProfit?: Decimal | DecimalJsLike | number | string | null
    indexationCost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoIncomeCreateManyUserInput = {
    id?: string
    assetType?: string | null
    coinName?: string | null
    purchaseDate?: Date | string | null
    saleDate?: Date | string | null
    purchasePrice?: Decimal | DecimalJsLike | number | string | null
    salePrice?: Decimal | DecimalJsLike | number | string | null
    quantity?: Decimal | DecimalJsLike | number | string | null
    exchangeName?: string | null
    transactionHash?: string | null
    profit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DonationCreateManyUserInput = {
    id?: string
    organizationName?: string | null
    donationType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    receiptNumber?: string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalInsuranceCreateManyUserInput = {
    id?: string
    policyType?: string | null
    insuredPersons?: string | null
    premiumPaid?: Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: Decimal | DecimalJsLike | number | string | null
    policyNumber?: string | null
    insuranceCompany?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxPaidCreateManyUserInput = {
    id?: string
    taxType?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    date?: Date | string | null
    challanNumber?: string | null
    bankName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterestIncomeCreateManyUserInput = {
    id?: string
    sourceType?: string | null
    bankName?: string | null
    accountNumber?: string | null
    interestAmount?: Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: Decimal | DecimalJsLike | number | string | null
    financialYear?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DividendIncomeCreateManyUserInput = {
    id?: string
    companyName?: string | null
    dividendAmount?: Decimal | DecimalJsLike | number | string | null
    taxDeducted?: Decimal | DecimalJsLike | number | string | null
    dateReceived?: Date | string | null
    shareQuantity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgriculturalIncomeCreateManyUserInput = {
    id?: string
    landArea?: Decimal | DecimalJsLike | number | string | null
    location?: string | null
    cropType?: string | null
    annualIncome?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    netIncome?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExemptIncomeCreateManyUserInput = {
    id?: string
    incomeType?: string | null
    description?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    section?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ITRGenerationCreateManyUserInput = {
    id?: string
    itrType: $Enums.ITRType
    assessmentYear: string
    fileName: string
    checksum: string
    jsonData: JsonNullValueInput | InputJsonValue
    status?: $Enums.ITRStatus
    generatedAt?: Date | string
    downloadedAt?: Date | string | null
  }

  export type TaxSummaryCreateManyUserInput = {
    id?: string
    assessmentYear?: string | null
    totalIncome?: Decimal | DecimalJsLike | number | string | null
    totalDeductions?: Decimal | DecimalJsLike | number | string | null
    taxableIncome?: Decimal | DecimalJsLike | number | string | null
    taxLiability?: Decimal | DecimalJsLike | number | string | null
    taxPaid?: Decimal | DecimalJsLike | number | string | null
    refundAmount?: Decimal | DecimalJsLike | number | string | null
    filingStatus?: string | null
    filingDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfitLossCreateManyUserInput = {
    id?: string
    businessIncomeId?: string | null
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceSheetCreateManyUserInput = {
    id?: string
    businessIncomeId?: string | null
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationEntryCreateManyUserInput = {
    id?: string
    businessIncomeId?: string | null
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Form16DataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Form16DataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Form16DataUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employerName?: NullableStringFieldUpdateOperationsInput | string | null
    employerTAN?: NullableStringFieldUpdateOperationsInput | string | null
    employerCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossSalary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notifiedIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salaryBreakup?: NullableJsonNullValueInput | InputJsonValue
    perquisitesAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    perquisites?: NullableJsonNullValueInput | InputJsonValue
    profitAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    profitsInLieu?: NullableJsonNullValueInput | InputJsonValue
    notifiedCountry?: NullableJsonNullValueInput | InputJsonValue
    notifiedIncomeOtherCountry?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    previousYearIncomeTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exemptAllowanceBreakup?: NullableJsonNullValueInput | InputJsonValue
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    standardDeduction?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    professionalTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reliefUnder89?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    incomeClaimed?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyIndex?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    netTaxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    houseAddress?: NullableJsonNullValueInput | InputJsonValue
    ownerDetails?: NullableJsonNullValueInput | InputJsonValue
    taxSavings?: NullableJsonNullValueInput | InputJsonValue
    rentalIncomeDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapitalGainUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapitalGainUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CapitalGainUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    assetSubType?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfSale?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateOfPurchase?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferExpenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sttPaid?: BoolFieldUpdateOperationsInput | boolean
    totalProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    indexationCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoIncomeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetType?: NullableStringFieldUpdateOperationsInput | string | null
    coinName?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchasePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    exchangeName?: NullableStringFieldUpdateOperationsInput | string | null
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationName?: NullableStringFieldUpdateOperationsInput | string | null
    donationType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deductionPercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInsuranceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInsuranceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalInsuranceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyType?: NullableStringFieldUpdateOperationsInput | string | null
    insuredPersons?: NullableStringFieldUpdateOperationsInput | string | null
    premiumPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    eligibleAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceCompany?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPaidUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPaidUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxPaidUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challanNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestIncomeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    interestAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tdsDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    financialYear?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DividendIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DividendIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DividendIncomeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    dividendAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxDeducted?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dateReceived?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shareQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgriculturalIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgriculturalIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgriculturalIncomeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    landArea?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    annualIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExemptIncomeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExemptIncomeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExemptIncomeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomeType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ITRGenerationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ITRGenerationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ITRGenerationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itrType?: EnumITRTypeFieldUpdateOperationsInput | $Enums.ITRType
    assessmentYear?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    checksum?: StringFieldUpdateOperationsInput | string
    jsonData?: JsonNullValueInput | InputJsonValue
    status?: EnumITRStatusFieldUpdateOperationsInput | $Enums.ITRStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaxSummaryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSummaryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxSummaryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentYear?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxableIncome?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxLiability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refundAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    filingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    filingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessIncome?: BusinessIncomeUpdateOneWithoutProfitLossNestedInput
  }

  export type ProfitLossUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessIncome?: BusinessIncomeUpdateOneWithoutBalanceSheetNestedInput
  }

  export type BalanceSheetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessIncome?: BusinessIncomeUpdateOneWithoutDepreciationNestedInput
  }

  export type DepreciationEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessIncomeId?: NullableStringFieldUpdateOperationsInput | string | null
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossCreateManyBusinessIncomeInput = {
    id?: string
    userId: string
    year?: string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalanceSheetCreateManyBusinessIncomeInput = {
    id?: string
    userId: string
    year?: string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepreciationEntryCreateManyBusinessIncomeInput = {
    id?: string
    userId: string
    assetName?: string | null
    assetCategory?: string | null
    purchaseDate?: Date | string | null
    purchaseCost?: Decimal | DecimalJsLike | number | string | null
    depreciationRate?: Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfitLossUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfitLossNestedInput
  }

  export type ProfitLossUncheckedUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfitLossUncheckedUpdateManyWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableJsonNullValueInput | InputJsonValue
    expenses?: NullableJsonNullValueInput | InputJsonValue
    netProfit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBalanceSheetsNestedInput
  }

  export type BalanceSheetUncheckedUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceSheetUncheckedUpdateManyWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: NullableJsonNullValueInput | InputJsonValue
    liabilities?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepreciationEntriesNestedInput
  }

  export type DepreciationEntryUncheckedUpdateWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepreciationEntryUncheckedUpdateManyWithoutBusinessIncomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assetName?: NullableStringFieldUpdateOperationsInput | string | null
    assetCategory?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    purchaseCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    depreciationRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accumulatedDepreciation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    writtenDownValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyWalletInput = {
    id?: string
    transactionType: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    description?: string | null
    razorpayPaymentId?: string | null
    razorpayOrderId?: string | null
    status?: $Enums.TransactionStatus
    timestamp?: Date | string
  }

  export type WalletTransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionType?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}